<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="page_title">Delta Green Agent Character Creator</title>
    <meta name="description" content="Create detailed agent character sheets for your Delta Green RPG sessions with this easy-to-use online character creator. Supports custom professions, skills, and more. No Log-in, no ads, free of costs.">
    <meta name="google-site-verification" content="bz_uz4BtBwAXCsKC8RHZXKlqEY0KaTULTd4DrRX0i_w" />
    <script src="https://cdn.counter.dev/script.js" data-id="ebd38259-4f23-48a0-b169-bfa1c5f86192" data-utcoffset="2"></script>
    
    <style>
        @font-face {
          font-family: 'Roboto Slab';
          font-style: normal;
          font-weight: 400;
          src: url('./fonts/roboto-slab-v34-latin-regular.woff2') format('woff2');
        }
        
        @font-face {
          font-family: 'Roboto Slab';
          font-style: normal;
          font-weight: 700;
          src: url('./fonts/roboto-slab-v34-latin-700.woff2') format('woff2');
        }
        
        @font-face {
          font-family: 'Special Elite';
          font-style: normal;
          font-weight: 400;
          src: url('./fonts/special-elite-v19-latin-regular.woff2') format('woff2');
        }
        /* --- Global Styles & Reset --- */
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto Slab', serif;
            background-color: #f4f1e8; /* Parchment/Aged paper */
            color: #222;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding-bottom: 80px; /* Für Sticky Footer, Wert an Footer-Höhe anpassen */
            padding-bottom: 90px;
        }

        #app-container {
            width: 100%;
            max-width: 800px;
            background-color: #fff;
            border: 1px solid #ccc;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.1);
            padding: 20px 30px;
            border-radius: 3px; /* Slight rounding for document feel */
        }

        /* --- Header & Language Switcher --- */
        header {
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        header h1 {
            font-family: 'Special Elite', cursive;
            color: #000;
            margin: 0;
            font-size: 1.8em;
        }
        #language-switcher button {
            font-family: 'Roboto Slab', serif;
            background: none;
            border: 1px solid #aaa;
            padding: 5px 10px;
            margin-left: 5px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        #language-switcher button.active {
            background-color: #475c47; /* Darker, desaturated green */
            color: white;
            border-color: #475c47;
        }
        #language-switcher button:not(.active):hover {
            background-color: #e0e0e0;
        }

        /* --- Progress Bar --- */
        #progress-bar-container {
            text-align: center;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #555;
        }
        
        /* --- Step Content & Forms --- */
        .step {
            animation: fadeIn 0.4s ease-in-out;
            margin-bottom: 20px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .info-box {
            background-color: #e9efeB; /* Light, slightly greenish grey */
            border-left: 4px solid #5a7a5a; /* Darker green accent */
            padding: 12px 18px;
            margin-bottom: 20px;
            font-size: 0.95em;
            border-radius: 2px;
        }
        .info-box p:first-child { margin-top: 0; }
        .info-box p:last-child { margin-bottom: 0; }

        h2, h3 {
            font-family: 'Special Elite', cursive;
            margin-top: 25px;
            margin-bottom: 15px;
            color: #333;
        }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.3em; }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
            color: #444;
        }
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
            /* box-sizing: border-box; -- Wurde durch * {} ersetzt */
            font-family: 'Roboto Slab', serif;
            border-radius: 2px;
            transition: border-color 0.2s;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            border-color: #5a7a5a;
            outline: none;
            box-shadow: 0 0 0 2px rgba(90, 122, 90, 0.2);
        }
        select {
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20width%3D%2220%22%20height%3D%2220%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M5%208l5%205%205-5z%22%20fill%3D%22%23555%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 30px;
        }
        input[type="radio"], input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle;
        }
        .inline-label {
            font-weight: normal;
            margin-right: 15px;
            display: inline-block;
        }

        /* --- Skill List Styling (Step 1.3) --- */
        .skill-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 5px; 
            border-bottom: 1px dotted #ddd;
        }
        .skill-list-item:last-child {
            border-bottom: none;
        }
        .skill-name-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
            margin-right: 10px; 
        }
        .skill-name {
            margin-right: 8px;
        }
         .skill-type-input-inline { 
            width: 150px;
            margin-left: 8px;
            font-size: 0.9em;
            padding: 3px 5px;
            border: 1px solid #ccc;
            border-radius: 2px;
        }
        .skill-info-icon {
            cursor: help; color: #5a7a5a; font-size: 0.85em; border: 1px solid #99b099;
            border-radius: 50%; width: 18px; height: 18px; display: inline-flex;
            justify-content: center; align-items: center; position: relative;
            font-weight: bold; transition: background-color 0.2s;
        }
        .skill-info-icon:hover { background-color: #dde5dd; }
        .tooltip {
            visibility: hidden; width: 220px; background-color: #2b2b2b; color: #f0f0f0;
            text-align: left; border-radius: 4px; padding: 8px 12px; position: absolute;
            z-index: 10; bottom: 130%; left: 50%; margin-left: -110px; opacity: 0;
            transition: opacity 0.3s, visibility 0s 0.3s; font-size: 0.9em;
            line-height: 1.4; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .skill-info-icon:hover .tooltip { visibility: visible; opacity: 1; transition-delay: 0s; }
        .skill-value-controls { display: flex; align-items: center; flex-shrink: 0; }
        .skill-value { font-weight: bold; min-width: 35px; text-align: right; margin-right: 5px; }
        .skill-increase-count { font-size: 0.8em; color: #666; min-width: 60px; text-align: left; margin-right: 8px; }
        .skill-increase-button, .skill-decrease-button {
            padding: 3px 7px; font-size: 0.8em; border: 1px solid #ccc;
            cursor: pointer; border-radius: 2px; transition: background-color 0.2s;
        }
        .skill-increase-button { background-color: #e8e8e8; }
        .skill-decrease-button { background-color: #f0e0e0; margin-right: 4px; }
        .skill-increase-button:hover:not(:disabled) { background-color: #d8d8d8; }
        .skill-decrease-button:hover:not(:disabled) { background-color: #e0d0d0; }
        .skill-increase-button:disabled, .skill-decrease-button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* --- Profession Specific Choices (Step 1.2) --- */
        #profession-details ul { list-style-type: none; padding-left: 0; }
        #profession-details li { margin-bottom: 8px; }
        #profession-details input[type="text"].skill-type-input {
            width: auto; min-width: 150px; margin-left: 10px; padding: 6px; font-size: 0.9em;
        }

        /* --- Custom Profession (Step 1 Custom) --- */
        .custom-skill-item-base > .base-skill-line {
            display: flex; justify-content: space-between; align-items: center; padding: 8px 0;
        }
        .custom-skill-item-base > .base-skill-line > div:first-child { display: flex; align-items: center; }
        #custom-profession-skill-list .skill-instance-controls {
            display: flex; flex-wrap: nowrap; align-items: center; gap: 5px; padding: 5px 0;
            margin-left: 25px; border-left: 2px solid #eee; margin-top: 5px;
            font-size: 0.85em; min-height: 34px;
        }
        #custom-profession-skill-list .custom-instance-type-input,
        #custom-profession-skill-list .custom-instance-type-input-placeholder {
            flex-grow: 0; flex-shrink: 0; width: 130px; padding: 6px; font-size: 1em;
        }
        #custom-profession-skill-list .custom-instance-type-input-placeholder {
            margin-right: 5px; border: 1px solid transparent; line-height: normal;
        }
        #custom-profession-skill-list .skill-instance-controls > span:first-of-type { white-space: nowrap; margin-right: 3px; flex-shrink: 0; }
        #custom-profession-skill-list .custom-skill-point-btn { padding: 3px 6px; font-size: 0.9em; line-height: 1.2; min-width: auto; flex-shrink: 0; }
        #custom-profession-skill-list .custom-skill-assigned-points { min-width: 20px; text-align: center; font-weight: bold; margin: 0 3px; flex-shrink: 0; }
        #custom-profession-skill-list .skill-instance-controls .custom-skill-total-value { white-space: nowrap; font-weight: bold; margin-left: 5px; flex-shrink: 0; }
        #custom-profession-skill-list .skill-instance-controls .remove-custom-skill-instance-btn { margin-left: auto; padding: 0 4px; flex-shrink: 0; font-size: 1.1em; line-height: 1; }
        @media (max-width: 750px) {
            #custom-profession-skill-list .skill-instance-controls { flex-wrap: wrap; gap: 8px; }
            #custom-profession-skill-list .custom-instance-type-input,
            #custom-profession-skill-list .custom-instance-type-input-placeholder { width: calc(100% - 10px); margin-bottom: 5px; }
            #custom-profession-skill-list .skill-instance-controls > span:first-of-type { width: 100%; text-align: left; margin-bottom: 3px; }
            #custom-profession-skill-list .skill-instance-controls .custom-skill-total-value { width: 100%; text-align: left; margin-top: 5px; margin-left: 0; }
        }
        .custom-prof-actions-container { display: flex; justify-content: flex-end; margin-top: 20px; }
        #btn-confirm-custom-skills { margin-top: 0; }
        label.disabled-choice { opacity: 0.6; cursor: not-allowed; }
        label.disabled-choice input[type="checkbox"] { cursor: not-allowed; }


        /* --- Statistics Allocation (Step 2) --- */
        .stat-allocation-row { display: flex; justify-content: space-between; margin-bottom: 10px; align-items: center; }
        .stat-allocation-row label { width: auto; min-width:120px; margin-bottom:0; }
        .stat-allocation-row select { width: 100px; margin-bottom: 0; }
        .stat-allocation-row .stat-percentile { width: 60px; text-align: right; font-weight: bold; }
        .distinguishing-feature-input-container { margin-top: 5px; margin-bottom: 10px; }
        .distinguishing-feature-input-container label.distinguishing-feature-label { font-size: 0.9em; font-weight: normal; margin-bottom: 3px;}
        .distinguishing-feature-input { width:100%; font-size: 0.9em; }
        .pointbuy-stat-row label { width: auto; min-width: 160px; margin-bottom:0; font-weight:bold; }
        .pointbuy-stat-row input[type="number"] { width: 70px; margin: 0 5px 0 auto; text-align:center; padding: 6px; font-size:1em; margin-bottom:0; }
        .pointbuy-stat-row .stat-percentile { font-weight:bold; min-width:40px; text-align:right; }
        .manual-entry-stat-row label { width: auto; min-width: 160px; margin-bottom:0; font-weight:bold; }
        .manual-entry-stat-row input[type="number"] { width: 70px; margin: 0 5px 0 auto; text-align:center; padding: 6px; font-size:1em; margin-bottom:0; }
        .manual-entry-stat-row .stat-percentile { font-weight:bold; min-width:40px; text-align:right; }

        /* --- Derived Attributes (Step 3) --- */
        .derived-attributes-display { margin-top: 20px; border-top: 1px solid #ccc; }
        .derived-attr-row { display: flex; align-items: flex-start; padding: 10px 0; border-bottom: 1px dotted #eee; }
        .derived-attr-row:last-child { border-bottom: none; }
        .derived-attr-row > :nth-child(1) { flex-basis: 200px; flex-shrink: 0; font-weight: bold; text-align: right; padding-right: 15px; }
        .derived-attr-row > :nth-child(2) { flex-basis: 60px; flex-shrink: 0; font-weight: bold; text-align: center; }
        .derived-attr-row > :nth-child(3) { flex-grow: 1; font-size: 0.9em; color: #555; padding-left: 15px; line-height: 1.4; }
        .derived-attr-header > strong { font-weight: bold; color: #333; }
        .derived-attr-header > :nth-child(1) { text-align: right; }
        .derived-attr-header > :nth-child(2) { text-align: center; }
        .derived-attr-header > :nth-child(3) { text-align: left; }

        /* --- Bonds & Motivations (Step 4) --- */
        .bond-entry, .motivation-entry { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px dashed #eee; }
        .bond-entry:last-child, .motivation-entry:last-child { border-bottom: none; }
        .bond-entry label, .motivation-entry label { display: block; margin-bottom: 3px; font-size: 0.95em; }
        .bond-entry input[type="text"] { margin-bottom: 5px; }
        .bond-entry span[data-i18n="bond_score_label"] + span { font-weight: bold; margin-left: 5px; }

        /* --- Summary Page (Step 5) --- */
        #step5-summary h3.summary-block-title {
            background-color: #333; color: white; padding: 8px 15px;
            margin: -15px -20px 15px -20px; font-family: 'Special Elite', cursive;
            font-size: 1.2em; text-transform: uppercase; letter-spacing: 1px;
            border-top-left-radius: 3px; border-top-right-radius: 3px;
        }
        #step5-summary h4.summary-subsection-title {
            font-family: 'Special Elite', cursive; font-size: 1.1em; margin-top: 20px;
            margin-bottom: 8px; color: #444; border-bottom: 1px solid #ddd; padding-bottom: 5px;
        }
        #step5-summary h4.summary-subsection-title:first-of-type { margin-top: 0; }
        .summary-block {
            background-color: #f9f9f9; border: 1px solid #ccc; border-radius: 3px;
            padding: 15px 20px; margin-bottom: 25px;
        }
        .summary-personal-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 8px 20px; font-size: 0.95em;
        }
        .summary-personal-grid div { padding: 2px 0; display: flex; flex-wrap: nowrap; align-items: baseline; }
        .summary-personal-grid strong { display: inline-block; min-width: 100px; margin-right: 5px; white-space: nowrap;}
        span.placeholder-field { display: inline-block; border-bottom: 1px solid #aaa; min-width: 100px; flex-grow:1; height: 1.2em; vertical-align: bottom; }
        span.placeholder-field.long { min-width: 150px; }
        span.placeholder-field.short { min-width: 60px; }
        span.value-field { font-weight: normal; color: #222; flex-grow:1; word-break: break-word; }

        .summary-grid-stats-psych { display: grid; gap: 25px; margin-bottom: 25px; grid-template-columns: 1fr; }
        @media (min-width: 768px) {
            .summary-grid-stats-psych { grid-template-columns: 1fr 1fr; }
        }
        .summary-table { width: 100%; border-collapse: collapse; font-size: 0.9em; margin-bottom: 15px; }
        .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; vertical-align: top; }
        .summary-table th { background-color: #e9e9e9; font-weight: bold; }
        .summary-table td.value-cell { text-align: center; font-weight: bold; }
        .summary-derived-table td.placeholder-cell { min-width: 60px; background-color: #fdfdfd; }

        ul.summary-list { list-style-type: none; padding-left: 0; font-size: 0.95em; }
        ul.summary-list li { padding: 3px 0; border-bottom: 1px dotted #eee; }
        ul.summary-list li:last-child { border-bottom: none; }

        /* Skills - Summary Section */
        .summary-block-skills .summary-skills-multicolumn { /* Dieser Div ist der direkte Parent der UL */
            margin-top: 0;
            border-top: none;
            padding-top: 0;
        }
        .summary-skills-multicolumn ul.skills-flat-list { /* Die UL, die die LIs enthält */
            list-style-type: disc;
            padding-left: 20px; /* Für die Aufzählungspunkte */
            margin: 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Standard: 3 Spalten */
            gap: 0px 20px; /* Kein vertikaler Gap, 20px horizontal */
            align-items: start;
        }
        /* Responsive Anpassung der Spalten für Skills in der Zusammenfassung */
        @media (max-width: 750px) {
            .summary-skills-multicolumn ul.skills-flat-list {
                grid-template-columns: repeat(2, 1fr); /* 2 Spalten */
            }
        }
        @media (max-width: 520px) {
            .summary-skills-multicolumn ul.skills-flat-list {
                grid-template-columns: 1fr; /* 1 Spalte */
            }
        }
        .summary-skills-multicolumn ul.skills-flat-list li {
            padding: 2px 0; 
            font-size: 0.9em; 
            word-break: break-word;
        }
        .summary-skills-multicolumn .base-value {
            font-size: 0.85em;
            color: #666;
            margin-left: 4px;
        }
        .summary-actions .action-button { margin-right: 10px; margin-top:15px; }
        /* Bestehendes .summary-table Styling (wird als Basis wiederverwendet) */
        .summary-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em; /* Schriftgröße leicht reduziert für mehr Kompaktheit */
            margin-bottom: 10px; /* Weniger Abstand unter den Tabellen */
        }
        .summary-table th, .summary-table td {
            border: 1px solid #ddd;
            padding: 4px 6px; /* Padding reduziert (war 6px 8px) */
            text-align: left;
            vertical-align: middle; /* Vertikal zentrieren kann kompakter wirken */
        }
        .summary-table th {
            background-color: #e9e9e9;
            font-weight: bold;
        }
        .summary-table td.value-cell {
            text-align: center;
            font-weight: bold;
        }

        /* Speziell für die "Current"-Zellen in der Derived Attributes Tabelle */
        .summary-derived-table td.placeholder-cell {
            min-width: 50px; /* Etwas schmaler, wenn nötig */
            background-color: #fdfdfd;
            height: 1.5em; /* Feste Höhe, um die Zeilenhöhe zu kontrollieren, an Schrift anpassen */
            line-height: 1.5em; /* Stellt sicher, dass Text darin zentriert ist, falls mal welcher kommt */
        }

        /* Optional: Schriftgröße der Unterüberschriften auch leicht reduzieren */
        #step5-summary h4.summary-subsection-title {
            font-size: 1.05em; /* War 1.1em */
            margin-top: 15px;  /* War 20px */
            margin-bottom: 6px;  /* War 8px */
            padding-bottom: 4px; /* War 5px */
        }


        /* --- Sticky Footer Navigation --- */
        #sticky-nav-footer {
            position: fixed; left: 0; bottom: 0; width: 100%;
            background-color: #e8e4d9;
            border-top: 1px solid #c5bfb0;
            padding: 8px 15px;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.08);
            z-index: 1000;
        }
        #navigation-container-wrapper {
            display: flex; justify-content: space-between; align-items: center;
            max-width: 800px; margin: 0 auto;
        }
        /* ▼▼▼ CSS FÜR #navigation-container (URSPRÜNGLICH UND JETZT STICKY) ▼▼▼ */
        #navigation-container {
            /* Ursprüngliche Styles für Abstand und interne Anordnung: */
            margin-top: 30px;
            display: flex;
            justify-content: space-between;
            border-top: 2px solid #eee;
            padding-top: 20px;

            /* NEU: Styles, um es sticky am unteren Rand zu machen */
            position: fixed;
            margin-left:25%;
            left: 0;
            bottom: 0;
            width: 50%;
            background-color: #fefefe; /* Hintergrund passend zum Body oder eine andere Farbe */
            padding: 15px 30px; /* Padding anpassen, um app-container-Padding zu entsprechen */
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1); /* Leichter Schatten oben */
            z-index: 1000; /* Über anderen Elementen */
            /* border-top von oben bleibt bestehen */

            /* Damit der Inhalt des #navigation-container sich an #app-container ausrichtet: */
            /* Dieses direkte Styling hier ist nicht ideal, besser wäre ein innerer Wrapper.
               Aber für eine schnelle Lösung, um es mit der max-width von app-container
               in Einklang zu bringen, ohne die HTML-Struktur stark zu ändern: */
        }
        footer {
            opacity: 0.7; /* War vorher 30%, vielleicht etwas lesbarer? */
            border-top-style: solid;
            border-width: thin;
            border-color: #ccc; /* Explizite Farbe für den Rand */
            margin-top: 25px;
            padding-top: 15px; /* Etwas Abstand über dem Text */
            font-style: italic;
            text-align: center; /* Zentriert den Copyright-Text */
        }
        footer p {
            margin: 0; /* Entfernt Standard-Margin vom p-Tag */
        }

        #sticky-nav-footer .nav-button {
            padding: 8px 18px;
            font-size: 0.85em;
            margin: 0;
        }
        .nav-button, .action-button { /* Diese Klasse gilt auch für btn-back/next */
            font-family: 'Roboto Slab', serif;
            background-color: #444;
            color: white;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 0.5px;
            border-radius: 2px;
            transition: background-color 0.2s;
        }
        .nav-button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        .nav-button:hover:not(:disabled), .action-button:hover {
            background-color: #222;
        }
        /* --- Print Styles --- */
        @media print {
            body { padding: 0 !important; background-color: #fff !important; font-size: 10pt !important; color: #000 !important; padding-bottom: 0 !important; }
            #navigation-container { /* Die Navigationsleiste im Druck ausblenden */
                display: none !important;
            }
            #app-container { box-shadow: none !important; border: none !important; max-width: 100% !important; padding: 0 !important; }
            header, #sticky-nav-footer, footer, #language-switcher, #progress-bar-container, .summary-actions { display: none !important; }
            .info-box { border-left-width: 2px !important; padding: 8px 10px !important; background-color: #f8f8f8 !important; }
            h1, h2, h3 { margin-top: 15px !important; margin-bottom: 8px !important; color: #000 !important; }
            .summary-block { border: 1px solid #666 !important; margin-bottom: 15px !important; padding: 10px 15px !important; background-color: #fff !important; }
            #step5-summary h3.summary-block-title { background-color: #ccc !important; color: #000 !important; margin: -10px -15px 10px -15px !important; font-size: 1.1em !important;}
            .summary-grid-stats-psych {
                /* Attempt to keep two columns for print if content is not too wide */
                grid-template-columns: 1fr 1fr !important; 
                gap: 10px !important; /* Reduce gap for print */
            }
            .summary-table { font-size: 8.5pt !important; }
            .summary-table th, .summary-table td { padding: 4px 6px !important;}
            
            /* Skills im Druck - IMMER 3 Spalten */
            .summary-skills-multicolumn ul.skills-flat-list {
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                gap: 0 10px !important;
                font-size: 8.5pt !important;
                padding-left: 20px !important;
                list-style-type: disc !important;
            }
            .summary-skills-multicolumn ul.skills-flat-list li {
                padding: 1px 0 !important;
                font-size: 8.5pt !important; /* Überschreibt ggf. das ul-font-size */
                margin-bottom: 1px !important;
            }
            .summary-table {
                font-size: 8pt !important; /* Noch kleiner für Druck, falls nötig */
                margin-bottom: 8px !important;
            }
            .summary-table th, .summary-table td {
                padding: 3px 5px !important; /* Noch kleineres Padding für Druck */
            }
            .summary-derived-table td.placeholder-cell {
                height: 1.4em !important; /* Höhe an 8pt Schrift anpassen */
                line-height: 1.4em !important;
                min-width: 40px !important;
            }
            #step5-summary h4.summary-subsection-title {
                font-size: 1em !important; /* Oder 10pt */
                margin-top: 10px !important;
                margin-bottom: 5px !important;
            }
            .summary-skills-multicolumn .base-value {
                font-size: 0.9em; /* Relativ zu 8.5pt */
            }
            footer { /* Den normalen Footer im Druck auch ausblenden */
                display: none !important;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header>
            <h1 data-i18n="app_header">Delta Green Agent Dossier</h1>
            <div id="language-switcher">
                <button id="lang-de">DE</button>
                <button id="lang-en">EN</button>
            </div>
        </header>

        <main>
            <div id="progress-bar-container"></div>
            <div id="step-content-container">
                <!-- Content dynamically inserted here -->
            </div>
            <div id="navigation-container">
                <button id="btn-back" data-i18n="btn_back_text" class="nav-button" disabled>Back</button>
                <button id="btn-next" data-i18n="btn_next_text" class="nav-button">Next</button>
            </div>
        </main>

        <footer>
            <p data-i18n="footer_text">© DG Character Creator - Based on Delta Green</p>
        </footer>
    </div>

    <script>
        // --- DATA: Embedded Skill Data ---
        const ALL_SKILLS = {
            "accounting":     { base: 10, nameKey: "skill_accounting_name", descKey: "skill_accounting_desc" },
            "alertness":      { base: 20, nameKey: "skill_alertness_name", descKey: "skill_alertness_desc" },
            "anthropology":   { base: 0,  nameKey: "skill_anthropology_name", descKey: "skill_anthropology_desc" },
            "archeology":     { base: 0,  nameKey: "skill_archeology_name", descKey: "skill_archeology_desc" },
            "art":            { base: 0,  nameKey: "skill_art_name", descKey: "skill_art_desc", type: true },
            "artillery":      { base: 0,  nameKey: "skill_artillery_name", descKey: "skill_artillery_desc" },
            "athletics":      { base: 30, nameKey: "skill_athletics_name", descKey: "skill_athletics_desc" },
            "bureaucracy":    { base: 10, nameKey: "skill_bureaucracy_name", descKey: "skill_bureaucracy_desc" },
            "computer_science":{ base: 0, nameKey: "skill_computer_science_name", descKey: "skill_computer_science_desc" },
            "craft":          { base: 0,  nameKey: "skill_craft_name", descKey: "skill_craft_desc", type: true },
            "criminology":    { base: 10, nameKey: "skill_criminology_name", descKey: "skill_criminology_desc" },
            "demolitions":    { base: 0,  nameKey: "skill_demolitions_name", descKey: "skill_demolitions_desc" },
            "disguise":       { base: 10, nameKey: "skill_disguise_name", descKey: "skill_disguise_desc" },
            "dodge":          { base: 30, nameKey: "skill_dodge_name", descKey: "skill_dodge_desc" },
            "drive":          { base: 20, nameKey: "skill_drive_name", descKey: "skill_drive_desc" },
            "firearms":       { base: 20, nameKey: "skill_firearms_name", descKey: "skill_firearms_desc" },
            "first_aid":      { base: 10, nameKey: "skill_first_aid_name", descKey: "skill_first_aid_desc" },
            "foreign_language":{ base: 0, nameKey: "skill_foreign_language_name", descKey: "skill_foreign_language_desc", type: true },
            "forensics":      { base: 0,  nameKey: "skill_forensics_name", descKey: "skill_forensics_desc" },
            "heavy_machinery":{ base: 10, nameKey: "skill_heavy_machinery_name", descKey: "skill_heavy_machinery_desc" },
            "heavy_weapons":  { base: 0,  nameKey: "skill_heavy_weapons_name", descKey: "skill_heavy_weapons_desc" },
            "history":        { base: 10, nameKey: "skill_history_name", descKey: "skill_history_desc" },
            "humint":         { base: 10, nameKey: "skill_humint_name", descKey: "skill_humint_desc" },
            "law":            { base: 0,  nameKey: "skill_law_name", descKey: "skill_law_desc" },
            "medicine":       { base: 0,  nameKey: "skill_medicine_name", descKey: "skill_medicine_desc" },
            "melee_weapons":  { base: 30, nameKey: "skill_melee_weapons_name", descKey: "skill_melee_weapons_desc" },
            "military_science":{ base: 0, nameKey: "skill_military_science_name", descKey: "skill_military_science_desc", type: true },
            "navigate":       { base: 10, nameKey: "skill_navigate_name", descKey: "skill_navigate_desc" },
            "occult":         { base: 10, nameKey: "skill_occult_name", descKey: "skill_occult_desc" },
            "persuade":       { base: 20, nameKey: "skill_persuade_name", descKey: "skill_persuade_desc" },
            "pharmacy":       { base: 0,  nameKey: "skill_pharmacy_name", descKey: "skill_pharmacy_desc" },
            "pilot":          { base: 0,  nameKey: "skill_pilot_name", descKey: "skill_pilot_desc", type: true },
            "psychotherapy":  { base: 10, nameKey: "skill_psychotherapy_name", descKey: "skill_psychotherapy_desc" },
            "ride":           { base: 10, nameKey: "skill_ride_name", descKey: "skill_ride_desc" },
            "science":        { base: 0,  nameKey: "skill_science_name", descKey: "skill_science_desc", type: true },
            "search":         { base: 20, nameKey: "skill_search_name", descKey: "skill_search_desc" },
            "sigint":         { base: 0,  nameKey: "skill_sigint_name", descKey: "skill_sigint_desc" },
            "stealth":        { base: 10, nameKey: "skill_stealth_name", descKey: "skill_stealth_desc" },
            "surgery":        { base: 0,  nameKey: "skill_surgery_name", descKey: "skill_surgery_desc" },
            "survival":       { base: 10, nameKey: "skill_survival_name", descKey: "skill_survival_desc" },
            "swim":           { base: 20, nameKey: "skill_swim_name", descKey: "skill_swim_desc" },
            "unarmed_combat": { base: 40, nameKey: "skill_unarmed_combat_name", descKey: "skill_unarmed_combat_desc" },
            "unnatural":      { base: 0,  nameKey: "skill_unnatural_name", descKey: "skill_unnatural_desc" }
        };

        // --- DATA: Embedded Profession Data ---
        const PROFESSIONS = {
            "anthropologist_archaeologist_historian": {
                nameKey: "profession_anthropologist_name",
                bonds: 4,
                baseSkills: [
                    { orSkills: [{ key: "anthropology", value: 50 }, { key: "archeology", value: 50 }], id: "anth_arch" },
                    { key: "bureaucracy", value: 40 },
                    { key: "foreign_language", value: 50, type: true, id: "fl1" },
                    { key: "foreign_language", value: 30, type: true, id: "fl2" },
                    { key: "history", value: 60 },
                    { key: "occult", value: 40 },
                    { key: "persuade", value: 40 }
                ],
                choiceSkills: {
                    count: 2,
                    options: [
                        { key: "anthropology", value: 40 }, { key: "archeology", value: 40 },
                        { key: "humint", value: 50 }, { key: "navigate", value: 50 },
                        { key: "ride", value: 50 }, { key: "search", value: 60 },
                        { key: "survival", value: 50 }
                    ]
                }
            },
            "computer_scientist_engineer": {
                nameKey: "profession_computer_scientist_name",
                bonds: 3,
                baseSkills: [
                    { key: "computer_science", value: 60 },
                    { key: "craft", value: 30, typeNameDefault: "Electrician", id:"craft_elec", type:true },
                    { key: "craft", value: 30, typeNameDefault: "Mechanic", id:"craft_mech", type:true },
                    { key: "craft", value: 40, typeNameDefault: "Microelectronics", id:"craft_micro", type:true },
                    { key: "science", value: 40, typeNameDefault: "Mathematics", id:"sci_math", type:true },
                    { key: "sigint", value: 40 }
                ],
                choiceSkills: {
                    count: 4,
                    options: [
                        { key: "accounting", value: 50 }, { key: "bureaucracy", value: 50 },
                        { key: "craft", value: 40, type: true, id:"craft_choice" },
                        { key: "foreign_language", value: 40, type: true, id:"fl_cs" },
                        { key: "heavy_machinery", value: 50 }, { key: "law", value: 40 },
                        { key: "science", value: 40, type: true, id:"sci_choice" }
                    ]
                }
            },
            "federal_agent": {
                nameKey: "profession_federal_agent_name",
                bonds: 3,
                baseSkills: [
                    { key: "alertness", value: 50 }, { key: "bureaucracy", value: 40 },
                    { key: "criminology", value: 50 }, { key: "drive", value: 50 },
                    { key: "firearms", value: 50 }, { key: "forensics", value: 30 },
                    { key: "humint", value: 60 }, { key: "law", value: 30 },
                    { key: "persuade", value: 50 }, { key: "search", value: 50 },
                    { key: "unarmed_combat", value: 60 }
                ],
                choiceSkills: {
                    count: 1,
                    options: [
                        { key: "accounting", value: 60 }, { key: "computer_science", value: 50 },
                        { key: "foreign_language", value: 50, type: true, id: "fl_fed" },
                        { key: "heavy_weapons", value: 50 }, { key: "pharmacy", value: 50 }
                    ]
                }
            },
            "physician": {
                nameKey: "profession_physician_name",
                bonds: 3,
                baseSkills: [
                    { key: "bureaucracy", value: 50 }, { key: "first_aid", value: 60 },
                    { key: "medicine", value: 60 }, { key: "persuade", value: 40 },
                    { key: "pharmacy", value: 50 },
                    { key: "science", value: 60, typeNameDefault: "Biology", id:"sci_bio", type:true },
                    { key: "search", value: 40 }
                ],
                choiceSkills: {
                    count: 2,
                    options: [
                        { key: "forensics", value: 50 }, { key: "psychotherapy", value: 60 },
                        { key: "science", value: 50, type: true, id:"sci_choice_phy" },
                        { key: "surgery", value: 50 }
                    ]
                }
            },
            "scientist": {
                nameKey: "profession_scientist_name",
                bonds: 4,
                baseSkills: [
                    { key: "bureaucracy", value: 40 }, { key: "computer_science", value: 40 },
                    { key: "science", value: 60, type: true, id:"sci1" },
                    { key: "science", value: 50, type: true, id:"sci2" },
                    { key: "science", value: 50, type: true, id:"sci3" }
                ],
                choiceSkills: {
                    count: 3,
                    options: [
                        { key: "accounting", value: 50 }, { key: "craft", value: 40, type: true, id:"craft_sci" },
                        { key: "foreign_language", value: 40, type: true, id:"fl_sci" },
                        { key: "forensics", value: 40 }, { key: "law", value: 40 },
                        { key: "pharmacy", value: 40 }
                    ]
                }
            },
            "special_operator": {
                nameKey: "profession_special_operator_name",
                bonds: 2,
                baseSkills: [
                    { key: "alertness", value: 60 }, { key: "athletics", value: 60 },
                    { key: "demolitions", value: 40 }, { key: "firearms", value: 60 },
                    { key: "heavy_weapons", value: 50 }, { key: "melee_weapons", value: 50 },
                    { key: "military_science", value: 60, typeNameDefault: "Land", id:"ms_land", type:true },
                    { key: "navigate", value: 50 }, { key: "stealth", value: 50 },
                    { key: "survival", value: 50 }, { key: "swim", value: 50 },
                    { key: "unarmed_combat", value: 60 }
                ],
                choiceSkills: null
            },
            "custom_profession": { // Eindeutiger Schlüssel
            nameKey: "profession_custom_build_name", // Für die Übersetzung im Dropdown
            isCustom: true // Ein Flag, um es leicht zu identifizieren
            // Bonds und Skills werden dynamisch gesetzt
            }
        };

        // --- DATA: Embedded i18n Translations ---
        const i18nData = {
             en: {
                "remaining_boost_pool_label": "Remaining Boost Points:",
                "confirm_incomplete_skill_boosts": "You have not distributed all {maxBoosts} skill boosts. Do you want to continue anyway?",
                "page_title": "Delta Green Agent Creator",
                "app_header": "Delta Green Agent Creation",
                "footer_text": "Published by arrangement with the Delta Green Partnership. The intellectual property known as Delta Green is a trademark and copyright owned by the Delta Green Partnership, who has licensed its use here. This includes allelements that are components of the Delta Green intellectual property.", // Slight change
                "btn_back_text": "Back",
                "btn_next_text": "Next",
                "btn_finish_text": "View Summary",
                "progress_bar_text": "Step {current} of {total}: {stepName}",
                "select_one_option": "-- Select One --",
                "specify_type_placeholder": "Specify type (e.g., Physics, French, Acting)",
                "choose_one_label": "Choose one",
                "choose_N_label": "Choose {N} of the following",

                "intro_quote_dg": "Crafting a Delta Green agent involves several key stages: selecting a profession and associated skills, defining core physical and mental statistics to calculate further attributes, and finally, establishing the agent's personal connections and driving motivations.",
                "intro_welcome_text": "Welcome to the Agent Dossier Creator for Delta Green. Proceed by clicking 'Next' to begin shaping your operative.",
                "step_name_0": "Introduction",
                "step_name_1": "Profession & Skills",
                "step_name_2": "Statistics",
                "step_name_3": "Derived Attributes",
                "step_name_4": "Bonds & Motivations",
                "step_name_5": "Summary",

                "step1_info1": "An agent's profession is foundational, influencing their skill set, initial number of interpersonal Bonds, available resources, and the scope of their authority and duties. The occupations listed below represent common backgrounds for Delta Green agents.",
                "step1_info2": "Each profession grants a specific list of skills with initial ratings that override the default base values. Beyond these professional skills, you have 8 points (each worth +20%) to distribute among any skills on your sheet. A single skill can receive multiple boosts, but no skill may exceed an initial rating of 80%.",
                "add_specialization_button_text": "Add Specialization for {skillName}",
"remove_button_title": "Remove this specialization",
                "step1_select_profession_label": "Step 1.1: Select a Profession",
                "step1_2_profession_specific_label": "Step 1.2: Profession-Specific Choices",
                "bonds_label": "Bonds", // This is a label, likely fine as is.
                "step1_increase_skills_label": "Step 1.3: Distribute Skill Boosts (8 available, +20% each)",
                "increases_chosen_label": "Boosts applied:",
                "alert_select_profession": "Please choose a profession to continue.",
                "alert_max_choices_reached": "You have reached the maximum of {N} selections for this category.",
                "alert_skill_increase_limit": "All 8 skill boosts have been allocated.",
                "alert_skill_max_value_reached": "This skill's rating cannot surpass 80% at character creation.",
                "alert_type_for_skill_needed": "A specific type is required for the skill \"{skillName}\".",

                "profession_anthropologist_name": "Anthropologist, Archaeologist, or Historian",
                "profession_computer_scientist_name": "Computer Scientist or Engineer",
                "profession_federal_agent_name": "Federal Agent",
                "profession_physician_name": "Physician",
                "profession_scientist_name": "Scientist",
                "profession_special_operator_name": "Special Operator",

                "skill_accounting_name": "Accounting", "skill_accounting_desc": "Understanding financial records, business practices, and uncovering fiscal irregularities.",
                "skill_alertness_name": "Alertness", "skill_alertness_desc": "Perceiving subtle details, potential threats, or noticing the unusual in one's surroundings.",
                "skill_anthropology_name": "Anthropology", "skill_anthropology_desc": "The academic study of human societies, cultures, and their development.",
                "skill_archeology_name": "Archeology", "skill_archeology_desc": "Investigating human history and prehistory through excavation and analysis of artifacts.",
                "skill_art_name": "Art", "skill_art_desc": "Proficiency in creating or performing a specific art form (e.g., Painting, Music, Theatre).",
                "skill_artillery_name": "Artillery", "skill_artillery_desc": "Operating and accurately deploying heavy-bore projectile weapons like mortars or missile launchers.",
                "skill_athletics_name": "Athletics", "skill_athletics_desc": "Physical prowess in activities requiring strength, agility, and coordination like running, jumping, or climbing.",
                "skill_bureaucracy_name": "Bureaucracy", "skill_bureaucracy_desc": "Navigating complex organizational structures, procedures, and influencing official channels.",
                "skill_computer_science_name": "Computer Science", "skill_computer_science_desc": "In-depth understanding of computer hardware, software, networks, and data analysis.",
                "skill_craft_name": "Craft", "skill_craft_desc": "Skill in a specific trade or manual creation (e.g., Mechanics, Electronics, Lockpicking).",
                "skill_criminology_name": "Criminology", "skill_criminology_desc": "Knowledge of criminal behavior, investigation techniques, and the workings of illegal enterprises.",
                "skill_demolitions_name": "Demolitions", "skill_demolitions_desc": "The safe and effective use of explosives for breaching, destruction, or creating diversions.",
                "skill_disguise_name": "Disguise", "skill_disguise_desc": "Altering one's appearance, voice, and mannerisms to convincingly impersonate someone else or create a false identity.",
                "skill_dodge_name": "Dodge", "skill_dodge_desc": "Reactively evading physical attacks or sudden hazards through quick reflexes.",
                "skill_drive_name": "Drive", "skill_drive_desc": "Operating ground vehicles like cars or motorcycles proficiently, especially under pressure.",
                "skill_firearms_name": "Firearms", "skill_firearms_desc": "Accurate and safe use of handguns, rifles, and shotguns in combat situations.",
                "skill_first_aid_name": "First Aid", "skill_first_aid_desc": "Providing immediate medical care to stabilize injuries and prevent further harm.",
                "skill_foreign_language_name": "Foreign Language", "skill_foreign_language_desc": "Fluency in a language other than one's native tongue (specify language).",
                "skill_forensics_name": "Forensics", "skill_forensics_desc": "Collecting, analyzing, and interpreting physical evidence from a scene using scientific methods.",
                "skill_heavy_machinery_name": "Heavy Machinery", "skill_heavy_machinery_desc": "Operating large or complex machinery such as construction equipment or industrial tools.",
                "skill_heavy_weapons_name": "Heavy Weapons", "skill_heavy_weapons_desc": "Proficient use of man-portable heavy armaments like machine guns or grenade launchers.",
                "skill_history_name": "History", "skill_history_desc": "Knowledge of past events, societies, and their significance (may require specialization).",
                "skill_humint_name": "HUMINT", "skill_humint_desc": "Human Intelligence: Gathering information through interpersonal contact, interviews, and interrogation.",
                "skill_law_name": "Law", "skill_law_desc": "Understanding legal systems, procedures, and using them to one's advantage or for investigation.",
                "skill_medicine_name": "Medicine", "skill_medicine_desc": "Advanced diagnosis, treatment of illnesses and injuries, beyond basic first aid.",
                "skill_melee_weapons_name": "Melee Weapons", "skill_melee_desc": "Effective use of hand-to-hand combat weapons like knives, clubs, or swords.", // Corrected key
                "skill_military_science_name": "Military Science", "skill_military_science_desc": "Knowledge of military tactics, strategy, organization, and culture (specify branch or focus).",
                "skill_navigate_name": "Navigate", "skill_navigate_desc": "Determining position and planning routes using maps, compasses, or other tools.",
                "skill_occult_name": "Occult", "skill_occult_desc": "Familiarity with esoteric lore, paranormal claims, secret societies, and arcane knowledge.",
                "skill_persuade_name": "Persuade", "skill_persuade_desc": "Influencing others' thoughts, decisions, or actions through argument, charm, or negotiation.",
                "skill_pharmacy_name": "Pharmacy", "skill_pharmacy_desc": "Understanding drugs, their effects, interactions, and preparation.",
                "skill_pilot_name": "Pilot", "skill_pilot_desc": "Operating and navigating aircraft, watercraft, or spacecraft (specify vehicle type).",
                "skill_psychotherapy_name": "Psychotherapy", "skill_psychotherapy_desc": "Diagnosing and treating mental health conditions and emotional distress.",
                "skill_ride_name": "Ride", "skill_ride_desc": "Skill in controlling and riding animals, typically horses or similar mounts.",
                "skill_science_name": "Science", "skill_science_desc": "Expertise in a specific scientific field (e.g., Biology, Chemistry, Physics).",
                "skill_search_name": "Search", "skill_search_desc": "Methodically finding hidden objects, information, or individuals in a given area.",
                "skill_sigint_name": "SIGINT", "skill_sigint_desc": "Signals Intelligence: Intercepting, analyzing, and decrypting electronic communications.",
                "skill_stealth_name": "Stealth", "skill_stealth_desc": "Moving悄悄地 and acting without being detected by sight or sound.",
                "skill_surgery_name": "Surgery", "skill_surgery_desc": "Performing invasive medical procedures to treat severe injuries or complex conditions.",
                "skill_survival_name": "Survival", "skill_survival_desc": "Sustaining oneself in hostile environments using knowledge of nature and improvisation.",
                "skill_swim_name": "Swim", "skill_swim_desc": "Proficiency in swimming, especially in challenging or dangerous water conditions.",
                "skill_unarmed_combat_name": "Unarmed Combat", "skill_unarmed_combat_desc": "Effectiveness in hand-to-hand fighting without weapons, incorporating various martial techniques.",
                "skill_unnatural_name": "Unnatural", "skill_unnatural_desc": "Grasping the sanity-shattering truths and entities that defy conventional understanding of reality.",

                //------------ Step 2 --------------
                "step2_info_stats": "An agent's six core statistics define their innate physical and mental capabilities. These values typically range from 3 to 18.",
                "stat_str_name": "Strength (STR)", "stat_str_desc": "Measures sheer physical force and brawn.",
                "stat_con_name": "Constitution (CON)", "stat_con_desc": "Indicates an agent's health, resilience, and stamina.",
                "stat_dex_name": "Dexterity (DEX)", "stat_dex_desc": "Reflects an agent's agility, coordination, and reaction speed.",
                "stat_int_name": "Intelligence (INT)", "stat_int_desc": "Represents an agent's reasoning, memory, and problem-solving ability.",
                "stat_pow_name": "Power (POW)", "stat_pow_desc": "Signifies willpower, mental fortitude, and psychic potential.",
                "stat_cha_name": "Charisma (CHA)", "stat_cha_desc": "Measures an agent's force of personality, persuasiveness, and social appeal.",
                "step2_select_array_label": "Step 2.1: Choose a Stat Array", // Modified to be more active
                "step2_assign_stats_label": "Step 2.2: Allocate the chosen values to your Statistics:", // Modified for clarity
                "step2_info_percentile": "For each statistic, note its percentile value (Stat Value × 5). If a statistic is notably low (below 9) or high (above 12), it's considered a distinguishing trait. Briefly describe this trait.", // Reworded
                "distinguishing_feature_label": "Defining Trait:", // Reworded
                "distinguishing_feature_placeholder": "e.g., Exceptionally Strong, Awkward, Sharp Witted, Easily Distracted", // New examples
                "alert_assign_all_stats": "Ensure a value is assigned to every statistic.",
                "alert_unique_stat_values": "Each value from the selected array must be assigned to only one statistic.",
                "step2_select_method_label": "Step 2.1: Choose Stat Generation Method",
                "stat_method_array": "Use Predefined Array",
                "stat_method_roll": "Roll Stats (4d6 drop lowest)",
                "step2_select_array_sublabel": "Select an Array:",
                "btn_roll_stats_text": "Roll New Stats",
                "rolled_values_label": "Your rolled values:",
                "click_to_roll_stats_label": "Click the button to roll your stats.",
                "step2_select_method_or_roll_label": "Please select a generation method and then an array, or roll your stats to proceed.",
                "stat_method_pointbuy": "Use Point Buy (72 Points)",
                "pointbuy_info_text": "Distribute {totalPoints} points among the six statistics. Each statistic must have a value between 3 and 18.",
                "pointbuy_points_remaining_label": "Points to Assign:", // Oder "Points Remaining:"
                "step2_assign_stats_label_or_features": "Step 2.2: Assign Values / Define Features", // Allgemeinerer Titel
                "step2_define_features_label": "Step 2.2: Define Distinguishing Features",
                "pointbuy_error_total_points": "You must assign exactly {total} points. You have currently assigned {spent}.",
                "pointbuy_error_stat_range": "Each statistic must be between 3 and 18 for Point Buy.",
                "pointbuy_points_summary_label": "Points Assigned: {spent} / {total}  (Points to Assign: {remaining})",
                "stat_method_manual": "Manual Entry",
                "manual_entry_info_text": "Enter values for each statistic directly. Each statistic must have a value between 3 and 18.",
                "manual_entry_error_stat_range": "For Manual Entry, each statistic must be between 3 and 18.",
                
                //------------ Step 3 --------------
                "step3_info_derived": "Derived attributes are secondary characteristics calculated using your agent's primary statistics.",
                "attr_hp_name": "Hit Points (HP)", "attr_hp_desc": "Indicate an agent's capacity to withstand physical damage. Calculated as (STR + CON) / 2, rounded up.",
                "attr_wp_name": "Willpower Points (WP)", "attr_wp_desc": "Represent an agent's mental energy and resolve. This value is equal to their POW statistic.",
                "attr_san_name": "Sanity (SAN)", "attr_san_desc": "Measures an agent's grip on conventional reality. Calculated as POW × 5.",
                "attr_bp_name": "Breaking Point (BP)", "attr_bp_desc": "The Sanity threshold at which further trauma may induce a new mental disorder. Calculated as SAN - POW.",
                "derived_attributes_title": "Step 3: Derived Attributes",

                //------------ Step 4 --------------
                "step4_info_bonds_mot": "While your profession, skills, and statistics outline your agent's capabilities, their Bonds and Motivations give depth to who they are as an individual.",
                "step4_1_bonds_title": "Step 4.1: Define Bonds", // More active
                "step4_info_bonds1": "A Bond signifies a crucial human connection in your agent's life. Each Bond starts with a score equal to the agent's Charisma (CHA).",
                "step4_info_bonds2": "Professions with greater demands often limit the number of Bonds an agent can maintain. Initially, Bonds require just a name and the nature of the relationship.",
                "bond_examples_label": "Bond Examples:", // Reworded
                "bond_examples_list": "Partner or former partner; Child; Close friend; Trusted colleague; Members of a support network; A mentor figure.", // New examples
                "bond_name_label": "Bond Relationship", // Reworded
                "bond_score_label": "Initial Score", // Reworded
                "step4_2_motivations_title": "Step 4.2: Establish Motivations (up to 5)", // More active
                "step4_info_motivations1": "Motivations are the personal beliefs, drives, or core principles that guide your agent. These can evolve as your agent's experiences shape them during play.",
                "step4_info_motivations2": "Should an agent's Sanity drop to their Breaking Point, one Motivation is typically replaced by a newly acquired mental disorder.",
                "motivation_label": "Motivation",
                "alert_define_bonds": "Please provide a brief description for each of your agent's Bonds.",

                //------------ Summary --------------
                "summary_label_name": "Name:",
                "summary_label_profession": "Profession:",
                "summary_label_employer": "Employer:",
                "summary_label_nationality": "Nationality:",
                "summary_label_sex": "Sex:",
                "summary_label_age_dob": "Age/D.O.B.:",
                "summary_label_education": "Education/Occupational History:",
                "summary_label_statistical_data": "Statistical Data",
                "summary_label_psychological_data": "Psychological Data",
                "summary_col_statistic": "Statistic",
                "summary_col_score": "Score",
                "summary_col_x5": "x5",
                "summary_col_features": "Distinguishing Features",
                "summary_label_physical_desc": "Physical Description",
                "summary_title": "Agent Dossier Summary", // Slightly reworded
                "summary_col_derived_attribute": "Attribute", // Neuer Key oder Wiederverwendung von summary_col_statistic
                "summary_col_maximum_value": "Maximum",     // Neuer Key
                "summary_col_current_value": "Current",
                "profession_label": "Profession",
                "statistics_label": "Statistics",
                "derived_attributes_label": "Derived Attributes",
                "skills_label": "Skills",
                "bonds_summary_label": "Bonds",
                "motivations_summary_label": "Motivations",
                "not_selected": "Not Yet Selected",
                "not_defined": "Not Yet Defined",
                "btn_print_summary": "Print Dossier", // Reworded
                "btn_download_txt": "Download as TXT",

                "summary_section_personal_details": "Personal Details",
                "summary_section_profession": "Profession",
                "summary_section_statistics": "Statistics",
                "summary_section_derived_attr": "Derived Attributes",
                "summary_section_skills": "Skills",
                "summary_section_bonds": "Bonds",
                "summary_section_motivations": "Motivations",

                "summary_placeholder_name": "Name: _______________",
                "summary_placeholder_age": "Age: __________",
                "summary_placeholder_sex": "Sex: __________",
                "summary_placeholder_employer": "Employer: ________________________",
                "summary_placeholder_nationality": "Nationality: _____________________",

                "profession_custom_build_name": "Custom Profession Build", // Reworded
                "custom_prof_title_bond_setup": "Custom Profession: Part 1 - Define Bonds & Base Skill Points", // Reworded
                "custom_prof_info_rules_title": "Guidelines for Creating a Custom Profession:", // Reworded
                "custom_prof_info_pick_skills": "Select ten core skills that define this new profession.",
                "custom_prof_info_divide_points": "You have <strong>{totalPoints}</strong> points (base 400, modified by Bonds) to allocate among these ten professional skills.",
                "custom_prof_info_add_to_start": "These allocated points are added to each skill's default starting (base) rating.",
                "custom_prof_info_rule_of_thumb": "As a general guideline, aim for professional skill ratings between 30% and 50% after adding these points.",
                "custom_prof_info_max_skill": "No skill chosen as professional can exceed 60% from this initial point allocation (base + allocated).",
                "custom_prof_info_default_bonds": "A custom profession starts with 3 Bonds by default.",
                "custom_prof_info_customize_bonds": "Adjust Bonds: Gain 50 professional skill points for each Bond removed (minimum 1). Lose 50 points for each Bond added (maximum 4).",
                "custom_prof_label_current_bonds": "Current Bonds:",
                "label_custom_profession_name": "Define Profession Name:", // Reworded
                "custom_prof_label_skill_point_budget": "Total Professional Skill Points:", // Reworded
                "custom_prof_btn_confirm_bonds": "Confirm Bonds & Continue to Skill Allocation", // Reworded
                "custom_prof_title_skill_allocation": "Custom Profession: Part 2 - Allocate Skill Points", // Reworded
                "custom_prof_info_skill_allocation": "Choose up to ten professional skills and assign your <strong>{currentBudget}</strong> skill points. Remember, no skill can exceed 60% (base + allocated). Points Remaining: <strong id='custom-skill-points-remaining'>{remainingPoints}</strong>",
                "custom_prof_skills_selected_label_prefix": "Professional Skills Chosen:", // Reworded
                "custom_prof_label_assign_points": "Allocate Points:", // Reworded
                "custom_prof_label_skill_total": "Resulting Total:", // Reworded
                "custom_prof_btn_confirm_skills": "Finalize Professional Skills", // Reworded
                "alert_max_10_custom_skills": "You must select 10 professional skills.", // Adjusted based on common interpretation
                "alert_distribute_all_custom_points": "All {totalBudget} professional skill points must be allocated. You have {remainingPoints} points left.",
                "alert_custom_skill_max_60": "The skill \"{skillName}\" cannot be raised above 60% through professional point allocation.",
                "alert_specify_type_for_custom_skill": "Please define a specific type for the custom professional skill \"{skillName}\".",
                // Note: The duplicate "step2_info_stats" and stat descriptions were already in your list. I've kept them.
                // If they are truly redundant and only one set is used, you can remove the duplicates.
                // I've assumed the second set of stat_..._desc is the one displayed in step 2.
                "step2_info_stats": "An agent's six statistics reflect his or her physical and mental abilities. Values range from 3 to 18.", // This key is duplicated, ensure only one is used or make them unique if context differs.
                
                "stat_str_name": "Strength (STR)", "stat_str_desc": "Measures raw physical might and lifting capacity.", // Slightly different from above
                "stat_con_name": "Constitution (CON)", "stat_con_desc": "Reflects health, resilience to harm, and endurance.", // Slightly different
                "stat_dex_name": "Dexterity (DEX)", "stat_dex_desc": "Denotes agility, hand-eye coordination, and reflexes.", // Slightly different
                "stat_int_name": "Intelligence (INT)", "stat_int_desc": "Governs reasoning, memory, intuition, and analytical skills.", // Slightly different
                "stat_pow_name": "Power (POW)", "stat_pow_desc": "Represents willpower, mental strength, and potential for unusual abilities.", // Slightly different
                "stat_cha_name": "Charisma (CHA)", "stat_cha_desc": "Indicates personal magnetism, leadership qualities, and social influence.", // Slightly different
                "step2_select_array_label": "Step 2.1: Select an array of values to distribute among these statistics.", // Reworded
                "step2_assign_stats_label": "Step 2.2: Assign the selected values to your Statistics:", // Reworded
                "step2_stat_value_label": "Value",
                "step2_stat_x5_label": "x5 Rating", // Reworded
                "step2_info_distinguishing_feature": "If a statistic's value is 8 or lower, or 13 or higher, it is particularly noteworthy. Provide a brief adjective or phrase to describe this characteristic.", // Reworded, slightly different thresholds if that was intended. The original was <9 or >12.
                "distinguishing_feature_label": "Defining Trait:", // Already reworded
                "distinguishing_feature_placeholder": "e.g., Hulking, Frail, Perceptive, Obsessive", // New examples
                "alert_select_stat_array": "You must first select a stat array.",
                "alert_assign_all_stats": "Please assign a value from the array to each statistic.",
                "alert_unique_stat_values": "Each value from the chosen stat array can only be used once per statistic assignment.",
                "stat_array_option_label": "{values}", // Slightly reworded placeholder text

                "step3_info_derived_title": "Step 3: Determine Derived Attributes", // More active
                "step3_info_derived_intro": "These attributes are directly calculated based on your agent's primary statistic scores, providing further definition to their capabilities.",
                "attr_hp_name": "Hit Points (HP)",
                "attr_hp_desc": "Represents an agent's ability to endure physical trauma. Calculated as (STR + CON) ÷ 2, rounding up.",
                "attr_wp_name": "Willpower Points (WP)",
                "attr_wp_desc": "Indicates mental resilience and the capacity to push through adversity. Equal to the POW score.",
                "attr_san_name": "Sanity (SAN)",
                "attr_san_desc": "Measures an agent's mental stability and connection to consensual reality. Calculated as POW × 5.",
                "attr_bp_name": "Breaking Point (BP)",
                "attr_bp_desc": "The Sanity level at which significant trauma risks inflicting a new, lasting mental disorder. Calculated as SAN - POW.",
                "derived_attribute_label": "Attribute",
                "derived_value_label": "Value",
                "derived_description_label": "Description",

                "step4_title_bonds_motivations": "Step 4: Detail Bonds and Motivations", // More active
                "step4_info_bonds_mot_intro": "Beyond capabilities, an agent is defined by their personal connections (Bonds) and their inner drives (Motivations). These elements add crucial depth to your character.",

                "step4_1_bonds_title": "Step 4.1: Establish Bonds", // More active
                "step4_info_bonds1": "Bonds represent the vital human connections in your agent's life. These can be specific individuals (like a spouse, child, or mentor) or tightly-knit groups (such as a former military unit or a close-knit family).",
                "step4_info_bonds2": "The initial score for each Bond is determined by the agent's Charisma (CHA). As a Bond's score decreases, the relationship it represents deteriorates.",
                "step4_info_bonds3": "The nature of an agent's profession can affect the number of Bonds they can realistically maintain. Refer to your chosen profession for the specific count, or the number you set if creating a custom one.",
                "step4_info_bonds4": "For now, each Bond needs a brief description identifying the person or group and the nature of the connection, e.g., “My estranged wife, Sarah” or “Sgt. Miller, my old squad leader.”",
                "bond_examples_label": "Illustrative Bond Examples:", // Reworded
                "bond_examples_list": "Spouse/Ex-spouse; Son/Daughter; Close sibling; Lifelong best friend; Key professional contact; Therapist; Family unit (e.g., spouse and children); Close-knit work team; Shared trauma survivors group.", // Reworded and expanded
                "bond_label_number": "Bond {number}",
                "bond_description_placeholder": "e.g., My partner, Alex Chen", // New example
                "bond_score_label": "Starting Score (CHA):",
                "num_bonds_for_profession": "Your chosen profession allows for {count} Bonds.",

                "step4_2_motivations_title": "Step 4.2: Define Motivations", // More active
                "step4_info_motivations1": "Motivations are the core beliefs, personal drives, or even obsessions that compel your agent. What truly makes them persevere? Is it a desire for knowledge, loyalty to a cause, a cherished hobby, or something more complex?",
                "step4_info_motivations2": "You can define up to five initial motivations. These may change or be replaced as your agent confronts the horrors of their work and their personality develops.",
                "step4_info_motivations3": "When an agent's Sanity reaches their Breaking Point due to trauma, a Motivation is usually replaced by a new mental disorder, reflecting the toll of their experiences.",
                "motivation_label_number": "Motivation {number}",
                "motivation_placeholder": "e.g., Uncover the truth, no matter the cost" // New example
            },
            de: {
                "page_title": "Delta Green Agenten-Ersteller",
                "app_header": "Delta Green Agenten Erstellung",
                // "footer_text": "Published by arrangement with the Delta Green Partnership. The intellectual property known as Delta Green is a trademark and copyright owned by the Delta Green Partnership, who has licensed its use here. The contents of this document are © Vardan Sharma, excepting those elements that are components of the Delta Green intellectual property.",
                "btn_back_text": "Zurück",
                "btn_next_text": "Weiter",
                "btn_finish_text": "Zusammenfassung ansehen",
                "progress_bar_text": "Schritt {current} von {total}: {stepName}",
                "select_one_option": "-- Bitte wählen --",
                "specify_type_placeholder": "Typ angeben (z.B. Physik, Französisch, Schauspiel)",
                "choose_one_label": "Wähle eine Option",
                "choose_N_label": "Wähle {N} der folgenden Optionen",
                "remaining_boost_pool_label": "Verbleibende Boost-Punkte:",

                "intro_quote_dg": "Die Erschaffung deines Delta Green Agenten umfasst mehrere Kernphasen: die Wahl eines Berufs und der damit verbundenen Fertigkeiten, die Festlegung der sechs primären Attribute zur Berechnung weiterer Werte und schließlich die Definition deiner persönlichen Beziehungen und Motivationen.",
                "intro_welcome_text": "Willkommen beim Agentenakten-Ersteller für Delta Green. Klicke auf 'Weiter', um mit der Gestaltung deines Agenten zu beginnen.",
                "step_name_0": "Einleitung",
                "step_name_1": "Beruf & Fertigkeiten",
                "step_name_2": "Attribute",
                "step_name_3": "Abgeleitete Werte",
                "step_name_4": "Beziehungen & Motivationen",
                "step_name_5": "Zusammenfassung",
                "confirm_incomplete_skill_boosts_de": "Du hast nicht alle {maxBoosts} Skill-Boosts verteilt. Möchtest du trotzdem fortfahren?",

                "step1_info1": "Dein Beruf ist grundlegend. Er beeinflusst deine Fertigkeiten, die anfängliche Anzahl deiner zwischenmenschlichen Beziehungen, verfügbare Ressourcen sowie den Umfang deiner Befugnisse und Pflichten. Die unten aufgeführten Berufe stellen gängige Hintergründe für Delta Green Agenten dar.",
                "step1_info2": "Jeder Beruf bringt eine spezifische Liste von Fertigkeiten mit Anfangswerten mit, die die Standard-Basiswerte ersetzen. Zusätzlich zu diesen professionellen Fertigkeiten kannst du 8 Punkte (jeder +20%) auf beliebige Fertigkeiten deines Charakterbogens verteilen. Eine einzelne Fertigkeit kann mehrfach verbessert werden, aber keine Fertigkeit darf zu Beginn einen Wert von 80% übersteigen.",
                "step1_select_profession_label": "Schritt 1.1: Beruf wählen",
                "step1_2_profession_specific_label": "Schritt 1.2: Berufsspezifische Optionen",
                "bonds_label": "Beziehungen",
                "step1_increase_skills_label": "Schritt 1.3: Fertigkeitsverbesserungen verteilen (8 verfügbar, je +20%)",
                "increases_chosen_label": "Verbesserungen angewendet:",
                "alert_select_profession": "Bitte wähle einen Beruf, um fortzufahren.",
                "alert_max_choices_reached": "Du hast das Maximum von {N} Auswahlmöglichkeiten für diese Kategorie erreicht.",
                "alert_skill_increase_limit": "Alle 8 Fertigkeitsverbesserungen wurden eingesetzt.",
                "alert_skill_max_value_reached": "Der Wert dieser Fertigkeit darf bei Charaktererschaffung 80% nicht übersteigen.",
                "alert_type_for_skill_needed": "Für die Fertigkeit \"{skillName}\" muss ein spezifischer Typ angegeben werden.",

                "profession_anthropologist_name": "Anthropologe, Archäologe oder Historiker",
                "profession_computer_scientist_name": "Informatiker oder Ingenieur",
                "profession_federal_agent_name": "Bundesagent",
                "profession_physician_name": "Arzt",
                "profession_scientist_name": "Wissenschaftler",
                "profession_special_operator_name": "Spezialeinsatzkraft",

                "add_specialization_button_text": "Spezialisierung für {skillName} hinzufügen",
"remove_button_title": "Diese Spezialisierung entfernen",

                "skill_accounting_name": "Buchhaltung", "skill_accounting_desc": "Verständnis von Finanzunterlagen, Geschäftspraktiken und Aufdeckung fiskalischer Unregelmäßigkeiten.",
                "skill_alertness_name": "Wachsamkeit", "skill_alertness_desc": "Wahrnehmung subtiler Details, potenzieller Bedrohungen oder das Bemerken von Ungewöhnlichem.",
                "skill_anthropology_name": "Anthropologie", "skill_anthropology_desc": "Die akademische Untersuchung menschlicher Gesellschaften, Kulturen und deren Entwicklung.",
                "skill_archeology_name": "Archäologie", "skill_archeology_desc": "Erforschung der Menschheitsgeschichte durch Ausgrabung und Analyse von Artefakten.",
                "skill_art_name": "Kunst", "skill_art_desc": "Fertigkeit in der Ausübung einer Kunstform (z.B. Malerei, Musik, Theater).",
                "skill_artillery_name": "Artillerie", "skill_artillery_desc": "Bedienung schwerer Projektilwaffen wie Mörser oder Raketenwerfer.",
                "skill_athletics_name": "Athletik", "skill_athletics_desc": "Körperliche Leistungsfähigkeit in Bereichen wie Laufen, Springen oder Klettern.",
                "skill_bureaucracy_name": "Bürokratie", "skill_bureaucracy_desc": "Navigation durch komplexe Organisationen und Beeinflussung offizieller Kanäle.",
                "skill_computer_science_name": "Informatik", "skill_computer_science_desc": "Tiefgehendes Wissen über Computer, Systeme und Datenanalyse.",
                "skill_craft_name": "Handwerk", "skill_craft_desc": "Geschick in einem spezifischen Handwerk (z.B. Mechanik, Elektronik, Schlossknacken).",
                "skill_criminology_name": "Kriminologie", "skill_criminology_desc": "Wissen über kriminelles Verhalten, Ermittlungsmethoden und konspirative Strukturen.",
                "skill_demolitions_name": "Sprengwesen", "skill_demolitions_desc": "Sicherer und effektiver Einsatz von Sprengstoffen.",
                "skill_disguise_name": "Verkleiden", "skill_disguise_desc": "Veränderung von Aussehen und Verhalten zur Tarnung oder Imitation.",
                "skill_dodge_name": "Ausweichen", "skill_dodge_desc": "Instinktives Entkommen vor physischen Angriffen oder Gefahren.",
                "skill_drive_name": "Fahren", "skill_drive_desc": "Sichere Steuerung von Kraftfahrzeugen, besonders unter Druck.",
                "skill_firearms_name": "Schusswaffen", "skill_firearms_desc": "Präziser und sicherer Umgang mit Handfeuerwaffen im Kampf.",
                "skill_first_aid_name": "Erste Hilfe", "skill_first_aid_desc": "Sofortige medizinische Versorgung zur Stabilisierung von Verletzungen.",
                "skill_foreign_language_name": "Fremdsprache", "skill_foreign_language_desc": "Beherrschung einer anderen Sprache (Sprache angeben).",
                "skill_forensics_name": "Forensik", "skill_forensics_desc": "Sammlung und Analyse von physischen Beweismitteln.",
                "skill_heavy_machinery_name": "Schwere Maschinen", "skill_heavy_machinery_desc": "Bedienung großer oder komplexer Maschinen (z.B. Baumaschinen).",
                "skill_heavy_weapons_name": "Schwere Waffen", "skill_heavy_weapons_desc": "Umgang mit tragbaren schweren Waffen wie Maschinengewehren.",
                "skill_history_name": "Geschichte", "skill_history_desc": "Wissen über vergangene Ereignisse und Gesellschaften (Spezialisierung möglich).",
                "skill_humint_name": "HUMINT", "skill_humint_desc": "Zwischenmenschlichen Interaktionen lesen und bewerten.",
                "skill_law_name": "Rechtswesen", "skill_law_desc": "Verständnis und Anwendung von Gesetzen und juristischen Prozessen.",
                "skill_medicine_name": "Medizin", "skill_medicine_desc": "Fortgeschrittene Diagnose und Behandlung von Krankheiten und Verletzungen.",
                "skill_melee_weapons_name": "Nahkampfwaffen", "skill_melee_weapons_desc": "Effektiver Einsatz von Waffen im Nahkampf (Messer, Schlagstöcke etc.).",
                "skill_military_science_name": "Militärwissenschaft", "skill_military_science_desc": "Kenntnisse über militärische Taktiken und Strukturen (Spezialisierung angeben).",
                "skill_navigate_name": "Navigation", "skill_navigate_desc": "Positionsbestimmung und Routenplanung mit Karten oder anderen Hilfsmitteln.",
                "skill_occult_name": "Okkultismus", "skill_occult_desc": "Wissen über esoterische Lehren, paranormale Phänomene und Geheimbünde.",
                "skill_persuade_name": "Überzeugen", "skill_persuade_desc": "Beeinflussung anderer durch Argumentation, Charme oder Verhandlung.",
                "skill_pharmacy_name": "Pharmazie", "skill_pharmacy_desc": "Kenntnisse über Medikamente, deren Wirkungen und Herstellung.",
                "skill_pilot_name": "Pilot", "skill_pilot_desc": "Steuerung von Luft-, Wasser- oder Raumfahrzeugen (Typ angeben).",
                "skill_psychotherapy_name": "Psychotherapie", "skill_psychotherapy_desc": "Diagnose und Behandlung von psychischen Erkrankungen.",
                "skill_ride_name": "Reiten", "skill_ride_desc": "Umgang mit und Reiten von Tieren, typischerweise Pferden.",
                "skill_science_name": "Wissenschaft", "skill_science_desc": "Expertise in einem spezifischen wissenschaftlichen Bereich (z.B. Biologie, Chemie).",
                "skill_search_name": "Suchen", "skill_search_desc": "Systematisches Auffinden versteckter Objekte, Informationen oder Personen.",
                "skill_sigint_name": "SIGINT", "skill_sigint_desc": "Fernmeldeaufklärung: Abfangen und Analysieren elektronischer Kommunikation.",
                "skill_stealth_name": "Heimlichkeit", "skill_stealth_desc": "Unauffälliges Bewegen und Handeln, um nicht entdeckt zu werden.",
                "skill_surgery_name": "Chirurgie", "skill_surgery_desc": "Durchführung invasiver medizinischer Eingriffe.",
                "skill_survival_name": "Überleben", "skill_survival_desc": "Sicherung des eigenen Überlebens in feindlichen Umgebungen.",
                "skill_swim_name": "Schwimmen", "skill_swim_desc": "Fortbewegung im Wasser, besonders unter schwierigen Bedingungen.",
                "skill_unarmed_combat_name": "Unbewaffneter Kampf", "skill_unarmed_combat_desc": "Effektive Selbstverteidigung und Kampf ohne Waffen.",
                "skill_unnatural_name": "Das Unnatürliche", "skill_unnatural_desc": "Verständnis der fundamentalen, verstandeszerreißenden Geheimnisse der Realität.",

                "step2_info_stats": "Die sechs Kernattribute deines Agenten definieren seine angeborenen physischen und mentalen Kapazitäten. Diese Werte liegen typischerweise zwischen 3 und 18.",
                "stat_str_name": "Stärke (ST)", "stat_str_desc": "Misst reine physische Kraft und Körperstärke.",
                "stat_con_name": "Konstitution (KO)", "stat_con_desc": "Zeigt deine Gesundheit, Widerstandsfähigkeit und Ausdauer an.",
                "stat_dex_name": "Geschicklichkeit (GE)", "stat_dex_desc": "Spiegelt deine Agilität, Koordination und Reaktionsgeschwindigkeit wider.",
                "stat_int_name": "Intelligenz (IN)", "stat_int_desc": "Repräsentiert deine Denkfähigkeit, dein Gedächtnis und deine Problemlösungskompetenz.",
                "stat_pow_name": "Willenskraft (WK)", "stat_pow_desc": "Bedeutet Willensstärke, mentale Widerstandskraft und psychisches Potenzial.",
                "stat_cha_name": "Charisma (CH)", "stat_cha_desc": "Misst deine Persönlichkeitsstärke, Überzeugungskraft und soziale Ausstrahlung.",
                "step2_select_array_label": "Schritt 2.1: Attributwerte-Gruppe wählen",
                "step2_assign_stats_label": "Schritt 2.2: Gewählte Werte deinen Attributen zuweisen:",
                "step2_info_percentile": "Notiere für jedes Attribut dessen Prozentwert (Attributwert × 5). Ist ein Attribut auffallend niedrig (unter 9) oder hoch (über 12), gilt es als dein hervorstechendes Merkmal. Beschreibe dieses kurz.",
                "distinguishing_feature_label": "Prägendes Merkmal:",
                "distinguishing_feature_placeholder": "z.B. Drahtig, Unbeholfen, Scharfsinnig, Zerstreut",
                "alert_assign_all_stats": "Stelle sicher, dass du jedem Attribut einen Wert zugewiesen hast.",
                "alert_unique_stat_values": "Jeder Wert aus der gewählten Gruppe darf nur einmal einem Attribut zugewiesen werden.",
                "step2_select_method_label": "Schritt 2.1: Methode zur Attributgenerierung wählen",
                "stat_method_array": "Vordefinierte Wertegruppe nutzen",
                "stat_method_roll": "Attribute auswürfeln (4W6, niedrigster Wurf gestrichen)",
                "step2_select_array_sublabel": "Wertegruppe auswählen:", // Neuer Key, falls du den Sub-Header verwendest
                "btn_roll_stats_text": "Neue Attribute auswürfeln",
                "rolled_values_label": "Deine ausgewürfelten Werte:",
                "click_to_roll_stats_label": "Klicke auf den Button, um deine Attribute auszuwürfeln.",
                "step2_select_method_or_roll_label": "Bitte wähle eine Generierungsmethode und dann eine Wertegruppe, oder würfle deine Attribute aus, um fortzufahren.",
                "pointbuy_points_summary_label": "Punkte zugewiesen: {spent} / {total} (Punkte zu verteilen: {remaining})",
                "step2_select_method_label": "Schritt 2.1: Methode zur Attributgenerierung wählen",
                "stat_method_array": "Vordefinierte Wertegruppe nutzen",
                "stat_method_roll": "Attribute auswürfeln (4W6, niedrigster Wurf gestrichen)",
                "stat_method_pointbuy": "Punktesystem nutzen (72 Punkte)",
                "stat_method_manual": "Manuelle Eingabe",
                "step2_select_array_sublabel": "Wertegruppe auswählen:",
                "btn_roll_stats_text": "Neue Attribute auswürfeln",
                "rolled_values_label": "Deine ausgewürfelten Werte:",
                "click_to_roll_stats_label": "Klicke auf den Button, um deine Attribute auszuwürfeln.",
                "step2_select_method_prompt": "Bitte wähle eine Methode zur Attributgenerierung, um fortzufahren.", // Neuer Key
                "pointbuy_info_text": "Verteile {totalPoints} Punkte auf die sechs Attribute. Jedes Attribut muss einen Wert zwischen 3 und 18 haben.",
                "pointbuy_points_summary_label": "Punkte zugewiesen: {spent} / {total} (Punkte zu verteilen: {remaining})",
                "step2_assign_stats_label_or_features": "Schritt 2.2: Werte Zuweisen / Merkmale Definieren", // Allgemeiner, wird dynamisch angepasst
                "step2_define_features_label": "Schritt 2.2: Prägende Merkmale definieren",
                "manual_entry_info_text": "Gib Werte für jedes Attribut direkt ein. Jeder Attributwert muss zwischen 3 und 18 liegen.",
                "alert_select_stat_method": "Bitte wähle eine Methode zur Attributgenerierung.",
                "pointbuy_error_total_points": "Du musst exakt {total} Punkte zuweisen. Aktuell sind es {spent}.",
                "pointbuy_error_stat_range": "Jedes Attribut muss beim Punktesystem einen Wert zwischen 3 und 18 haben.",
                "manual_entry_error_stat_range": "Bei manueller Eingabe muss jedes Attribut einen Wert zwischen 3 und 18 haben.",

                "step3_info_derived": "Abgeleitete Werte sind sekundäre Eigenschaften, die aus deinen Primärattributen berechnet werden.",
                "attr_hp_name": "Trefferpunkte (TP)", "attr_hp_desc": "Geben deine Fähigkeit an, physischen Schaden zu widerstehen. Berechnet als (ST + KO) / 2, aufgerundet.",
                "attr_wp_name": "Willenskraftpunkte (WP)", "attr_wp_desc": "Repräsentieren deine mentale Energie und Entschlossenheit. Dieser Wert entspricht deinem WK-Attribut.",
                "attr_san_name": "Stabilität (STA)", "attr_san_desc": "Misst deinen Bezug zur konventionellen Realität. Berechnet als WK × 5.",
                "attr_bp_name": "Belastungsgrenze (BG)", "attr_bp_desc": "Der Stabilitäts-Schwellenwert, bei dem weiteres Trauma eine neue psychische Störung bei dir auslösen kann. Berechnet als STA - WK.",
                "derived_attributes_title": "Schritt 3: Abgeleitete Werte",

                "step4_info_bonds_mot": "Während Beruf, Fertigkeiten und Attribute deine Fähigkeiten umreißen, verleihen dir deine Beziehungen und Motivationen als Individuum Tiefe.",
                "step4_1_bonds_title": "Schritt 4.1: Beziehungen definieren",
                "step4_info_bonds1": "Eine Beziehung stellt eine entscheidende menschliche Verbindung in deinem Leben dar. Jede Beziehung beginnt mit einem Wert, der deinem Charisma (CH) entspricht.",
                "step4_info_bonds2": "Anspruchsvolle Berufe schränken oft die Anzahl der Beziehungen ein, die du pflegen kannst. Zu Beginn benötigen deine Beziehungen nur einen Namen und die Art der Beziehung.",
                "bond_examples_label": "Beispiele für Beziehungen:",
                "bond_examples_list": "Partner/Ex-Partner; Kind; Enger Freund; Vertrauter Kollege; Mitglieder deines Unterstützungsnetzwerks; Eine Mentorenfigur.",
                "bond_name_label": "Beziehungsbeschreibung",
                "bond_score_label": "Anfangswert",
                "step4_2_motivations_title": "Schritt 4.2: Motivationen festlegen (bis zu 5)",
                "step4_info_motivations1": "Motivationen sind deine persönlichen Überzeugungen, Antriebe oder Kernprinzipien, die dich leiten. Diese können sich entwickeln, während deine Erfahrungen dich im Spiel formen.",
                "step4_info_motivations2": "Sollte deine Stabilität auf deine Belastungsgrenze fallen, wird typischerweise eine deiner Motivationen durch eine neu erworbene psychische Störung ersetzt.",
                "motivation_label": "Motivation",
                "alert_define_bonds": "Bitte gib für jede deiner Beziehungen eine kurze Beschreibung an.",

                //------------ Summary / Zusammenfassung (Schritt 5) --------------
                "summary_title": "Zusammenfassung deiner Agentenakte", // War schon da, ggf. prüfen
                "profession_label": "Beruf", // War schon da
                "statistics_label": "Attribute", // War schon da
                "derived_attributes_label": "Abgeleitete Werte", // War schon da
                "skills_label": "Fertigkeiten", // War schon da
                "bonds_summary_label": "Beziehungen", // War schon "Beziehungen"
                "motivations_summary_label": "Motivationen", // War schon da
                "not_selected": "Noch nicht gewählt", // War schon da
                "not_defined": "Noch nicht definiert", // War schon da
                "btn_print_summary": "Akte drucken", // War schon da
                "btn_download_pdf": "Als PDF herunterladen", // NEU (für den PDF-Button)

                "summary_section_personal_details": "Persönliche Daten", // War schon da
                "summary_section_profession": "Beruf", // War schon da
                "summary_section_statistics": "Attribute", // War schon da (hieß vorher Statistics)
                "summary_section_derived_attr": "Abgeleitete Werte", // War schon da
                "summary_section_skills": "Fertigkeiten", // War schon da
                "summary_section_bonds": "Beziehungen", // War schon da (hieß vorher Bonds)
                "summary_section_motivations": "Motivationen", // War schon da

                // Platzhalter-Texte und Labels für die Zusammenfassung
                "summary_placeholder_name": "Name: _______________", // War schon da
                "summary_label_name": "Name:", // NEU (für die Struktur mit starkem Label)
                "summary_placeholder_age": "Alter: __________", // War schon da
                "summary_label_age_dob": "Alter/Geb.Dat.:", // NEU (Kombiniert)
                "summary_placeholder_sex": "Geschlecht: __________", // War schon da
                "summary_label_sex": "Geschlecht:", // NEU
                "summary_placeholder_employer": "Arbeitgeber: ________________________", // War schon da
                "summary_label_employer": "Arbeitgeber:", // NEU
                "summary_placeholder_nationality": "Nationalität: _____________________", // War schon da
                "summary_label_nationality": "Nationalität:", // NEU
                "summary_label_profession": "Beruf:", // NEU (war vorher Teil von summary_section_profession)
                "summary_label_education": "Ausbildung/Berufserfahrung:", // NEU
                "summary_label_statistical_data": "Statistische Daten", // NEU
                "summary_label_psychological_data": "Psychologische Daten", // NEU
                "summary_col_statistic": "Attribut", // NEU (für Tabellenkopf)
                "summary_col_score": "Wert", // NEU (für Tabellenkopf)
                "summary_col_x5": "x5", // NEU (für Tabellenkopf)
                "summary_col_features": "Prägende Merkmale", // NEU (für Tabellenkopf)
                "summary_col_derived_attribute": "Abgeleiteter Wert", // NEU (für Tabellenkopf)
                "summary_col_maximum_value": "Maximum", // NEU (für Tabellenkopf)
                "summary_col_current_value": "Aktuell", // NEU (für Tabellenkopf)
                "summary_label_physical_desc": "Äußere Beschreibung", // NEU
                "no_skills_available": "Keine Fertigkeiten verfügbar.", // NEU
                "summary_title": "Zusammenfassung deiner Agentenakte",
                "profession_label": "Beruf",
                "statistics_label": "Attribute",
                "derived_attributes_label": "Abgeleitete Werte",
                "skills_label": "Fertigkeiten",
                "bonds_summary_label": "Beziehungen",
                "motivations_summary_label": "Motivationen",
                "not_selected": "Noch nicht gewählt",
                "not_defined": "Noch nicht definiert",
                "btn_print_summary": "Akte drucken",
                "btn_download_txt": "Als TXT herunterladen",

                "summary_section_personal_details": "Persönliche Daten",
                "summary_section_profession": "Beruf",
                "summary_section_statistics": "Attribute",
                "summary_section_derived_attr": "Abgeleitete Werte",
                "summary_section_skills": "Fertigkeiten",
                "summary_section_bonds": "Beziehungen",
                "summary_section_motivations": "Motivationen",

                "summary_placeholder_name": "Name: _______________",
                "summary_placeholder_age": "Alter: __________",
                "summary_placeholder_sex": "Geschlecht: __________",
                "summary_placeholder_employer": "Arbeitgeber: ________________________",
                "summary_placeholder_nationality": "Nationalität: _____________________",

                "profession_custom_build_name": "Eigenen Beruf erstellen",
                "label_custom_profession_name": "Benenne deinen Beruf:",
                "custom_prof_title_bond_setup": "Eigener Beruf: Teil 1 - Beziehungen & Fertigkeitspunkte definieren",
                "custom_prof_info_rules_title": "Richtlinien zur Erstellung deines eigenen Berufs:",
                "custom_prof_info_pick_skills": "Wähle zehn Kernfertigkeiten, die diesen neuen Beruf definieren.",
                "custom_prof_info_divide_points": "Du hast <strong>{totalPoints}</strong> Punkte (Basis 400, durch Beziehungen modifiziert) zur Verteilung auf diese zehn Berufsfertigkeiten.",
                "custom_prof_info_add_to_start": "Wähle jetzt deine Berufsfertigkeiten und weise ihnen Punkte zu. Die zugewiesenen Punkte werden zum Standard-Anfangswert (Basiswert) jeder Fertigkeit addiert.",
                "custom_prof_info_rule_of_thumb": "Als allgemeine Richtlinie sollten deine Berufsfertigkeiten nach Hinzufügung dieser Punkte zwischen 30% und 50% liegen.",
                "custom_prof_info_max_skill": "Keine als beruflich gewählte Fertigkeit darf durch diese anfängliche Punktevergabe 60% übersteigen (Basis + zugewiesene Punkte).",
                "custom_prof_info_default_bonds": "Ein eigener Beruf beginnt standardmäßig mit 3 Beziehungen.",
                "custom_prof_info_customize_bonds": "Passe deine Beziehungen an: Erhalte 50 Berufsfertigkeitspunkte für jede entfernte Beziehung (Minimum 1). Verliere 50 Punkte für jede hinzugefügte Beziehung (Maximum 4).",
                "custom_prof_label_current_bonds": "Deine aktuellen Beziehungen:",
                "custom_prof_label_skill_point_budget": "Deine gesamten Berufsfertigkeitspunkte:",
                "custom_prof_btn_confirm_bonds": "Beziehungen bestätigen & Weiter zur Fertigkeitszuweisung",
                "custom_prof_title_skill_allocation": "Eigener Beruf: Teil 2 - Fertigkeitspunkte zuweisen",
                "custom_prof_info_skill_allocation": "Wähle bis zu zehn Berufsfertigkeiten und verteile deine <strong>{currentBudget}</strong> Fertigkeitspunkte. Denke daran, keine Fertigkeit darf 60% übersteigen (Basis + zugewiesen). Verbleibende Punkte: <strong id='custom-skill-points-remaining'>{remainingPoints}</strong>",
                "custom_prof_skills_selected_label_prefix": "Deine gewählten Berufsfertigkeiten:",
                "custom_prof_label_assign_points": "Punkte zuweisen:",
                "custom_prof_label_skill_total": "Resultierender Gesamtwert:",
                "custom_prof_btn_confirm_skills": "Berufsfertigkeiten bestätigen",
                "alert_max_10_custom_skills": "Du musst 10 Berufsfertigkeiten wählen.",
                "alert_distribute_all_custom_points": "Alle {totalBudget} Berufsfertigkeitspunkte müssen zugewiesen werden. Du hast noch {remainingPoints} Punkte übrig.",
                "alert_custom_skill_max_60": "Die Fertigkeit \"{skillName}\" kann durch Zuweisung von Berufsfertigkeitspunkten nicht über 60% erhöht werden.",
                "alert_specify_type_for_custom_skill": "Bitte definiere einen spezifischen Typ für deine eigene Berufsfertigkeit \"{skillName}\".",

                "step2_select_array_label": "Schritt 2.1: Eine Gruppe von Werten wählen, um sie auf deine Attribute zu verteilen.",
                "step2_assign_stats_label": "Schritt 2.2: Die gewählten Werte deinen Attributen zuweisen:",
                "step2_stat_value_label": "Wert",
                "step2_stat_x5_label": "x5 Wert",
                "step2_info_distinguishing_feature": "Wenn der Wert eines deiner Attribute 8 oder niedriger bzw. 13 oder höher ist, ist es besonders bemerkenswert. Gib ein kurzes Adjektiv oder eine Phrase zur Beschreibung dieser Eigenschaft an.",
                "alert_select_stat_array": "Du musst zuerst eine Attributwerte-Gruppe auswählen.",
                "alert_assign_all_stats": "Bitte weise jedem deiner Attribute einen Wert aus der Gruppe zu.",
                "alert_unique_stat_values": "Jeder Wert aus der gewählten Attributwerte-Gruppe darf nur einmal für die Attribute verwendet werden.",
                "stat_array_option_label": "{values}",

                "step3_info_derived_title": "Schritt 3: Abgeleitete Werte bestimmen",
                "step3_info_derived_intro": "Diese Werte werden direkt auf Basis deiner Primärattribute berechnet und definieren deine Fähigkeiten weiter.",
                "attr_hp_desc": "Stellt deine Fähigkeit dar, körperliches Trauma zu ertragen. Berechnet als (ST + KO) ÷ 2, aufgerundet.",
                "attr_wp_desc": "Zeigt deine mentale Widerstandsfähigkeit und die Fähigkeit, Widrigkeiten zu überwinden. Entspricht deinem WK-Wert.",
                "attr_san_desc": "Misst deine mentale Stabilität und deine Verbindung zur allgemeinen Realität. Berechnet als WK × 5.",
                "attr_bp_desc": "Das Stabilitätsniveau, bei dem erhebliches Trauma eine neue, bleibende psychische Störung bei dir verursachen kann. Berechnet als STA - WK.",
                "derived_attribute_label": "Abgeleiteter Wert",
                "derived_value_label": "Wert",
                "derived_description_label": "Beschreibung",

                "step4_title_bonds_motivations": "Schritt 4: Beziehungen und Motivationen detaillieren",
                "step4_info_bonds_mot_intro": "Über die reinen Fähigkeiten hinaus wirst du durch deine persönlichen VerBeziehungen (Beziehungen) und deine inneren Antriebe (Motivationen) definiert. Diese Elemente verleihen deinem Charakter entscheidende Tiefe.",

                "step4_1_bonds_title": "Schritt 4.1: Beziehungen festlegen",
                "step4_info_bonds1": "Beziehungen repräsentieren die wichtigsten menschlichen Beziehungen in deinem Leben. Dies können bestimmte Personen (wie Ehepartner, Kind oder Mentor) oder eng verbundene Gruppen sein (wie eine ehemalige Militäreinheit oder deine Familie).",
                "step4_info_bonds2": "Der Anfangswert jeder Beziehung wird durch dein Charisma (CH) bestimmt. Sinkt der Wert einer Beziehung, verschlechtert sich die Beziehung, die sie darstellt.",
                "step4_info_bonds3": "Die Art deines Berufs kann die Anzahl der Beziehungen beeinflussen, die du realistischerweise aufrechterhalten kannst. Die genaue Anzahl entnimmst du deinem gewählten Beruf oder der von dir festgelegten Zahl, falls du einen eigenen Beruf erstellst.",
                "step4_info_bonds4": "Vorerst benötigt jede Beziehung eine kurze Beschreibung, die die Person oder Gruppe und die Art eurer Verbindung identifiziert, z.B. „Meine entfremdete Frau, Sarah“ oder „Sgt. Miller, mein alter Truppführer.“",
                "bond_examples_label": "Veranschaulichende Beispiele für Beziehungen:",
                "bond_examples_list": "Ehepartner/Ex-Partner; Sohn/Tochter; Enges Geschwisterkind; Bester Freund/Beste Freundin seit Langem; Wichtiger beruflicher Kontakt; Therapeut; Familieneinheit (z.B. Partner und Kinder); Eng verbundenes Arbeitsteam; Gruppe von Überlebenden eines gemeinsamen Traumas.",
                "bond_label_number": "Beziehung {number}",
                "bond_description_placeholder": "z.B. Mein Partner, Alex Chen",
                "bond_score_label": "Anfangswert (CH):",
                "num_bonds_for_profession": "Dein gewählter Beruf ermöglicht {count} Beziehungen.",

                "step4_2_motivations_title": "Schritt 4.2: Motivationen definieren",
                "step4_info_motivations1": "Motivationen sind deine Kernüberzeugungen, persönlichen Antriebe oder sogar Obsessionen, die dich bewegen. Was treibt dich wirklich an? Ist es Wissensdurst, Loyalität zu einer Sache, ein geschätztes Hobby oder etwas Komplexeres?",
                "step4_info_motivations2": "Du kannst bis zu fünf anfängliche Motivationen definieren. Diese können sich ändern oder ersetzt werden, wenn du mit den Schrecken deiner Arbeit konfrontiert wirst und sich deine Persönlichkeit entwickelt.",
                "step4_info_motivations3": "Wenn deine Stabilität aufgrund eines Traumas deine Belastungsgrenze erreicht, wird eine deiner Motivationen üblicherweise durch eine neue psychische Störung ersetzt, was den Tribut deiner Erfahrungen widerspiegelt.",
                "motivation_label_number": "Motivation {number}",
                "motivation_placeholder": "z.B. Die Wahrheit aufdecken, egal was es kostet"
            }
        };

        // --- LOGIK: i18n (Internationalization) ---
        const translations = {};
        let currentLanguage = 'en';

        function setupTranslations() {
            if (i18nData && i18nData.en) translations.en = i18nData.en;
            if (i18nData && i18nData.de) translations.de = i18nData.de;
        }

        function t(key, replacements = {}) {
            if (typeof key !== 'string' || key === "") return "";
            let translationString;
            if (translations[currentLanguage] && translations[currentLanguage][key] !== undefined) {
                translationString = translations[currentLanguage][key];
            } else if (translations['en'] && translations['en'][key] !== undefined) {
                translationString = translations['en'][key];
            } else {
                return `[[${key}]]`;
            }
            if (typeof translationString !== 'string') {
                return `[[${key}_TYPE_ERR]]`;
            }
            for (const placeholder in replacements) {
                if (replacements.hasOwnProperty(placeholder)) {
                    translationString = translationString.replace(new RegExp(`{${placeholder}}`, 'g'), replacements[placeholder]);
                }
            }
            return translationString;
        }
        
        function applyTranslationsToElement(el, key, directReplacements = {}) {
                let replacements = { ...directReplacements }; // Starte mit direkt übergebenen Ersetzungen

                // Versuche, zusätzliche Ersetzungen aus dem data-Attribut zu lesen
                const attrReplacementsString = el.getAttribute('data-i18n-replacements');
                if (attrReplacementsString) {
                    try {
                        // Erwartet ein JSON-Objekt als String, z.B. '{"name": "Agent", "level": "5"}'
                        const parsedAttrReplacements = JSON.parse(attrReplacementsString);
                        // Füge die geparsten Attribute hinzu oder überschreibe sie, falls sie nicht schon direkt übergeben wurden
                        for (const rKey in parsedAttrReplacements) {
                            if (parsedAttrReplacements.hasOwnProperty(rKey) && !replacements.hasOwnProperty(rKey)) {
                                replacements[rKey] = parsedAttrReplacements[rKey];
                            }
                        }
                    } catch (e) {
                        console.warn(`Error parsing data-i18n-replacements for key "${key}": ${attrReplacementsString}`, e);
                    }
                }
                
                const translatedText = t(key, replacements);

                if (el.tagName === 'INPUT' && el.type === 'text' && el.hasAttribute('placeholder')) {
                    el.placeholder = translatedText;
                } else if (el.tagName === 'INPUT' && (el.type === 'button' || el.type === 'submit')) {
                    el.value = translatedText;
                } else if (el.tagName === 'BUTTON' || el.tagName === 'OPTION' || el.tagName === 'SPAN') { // SPAN hinzugefügt
                    el.textContent = translatedText; // Für SPANs ist textContent oft besser als innerHTML, wenn kein HTML im String ist
                } else {
                    el.innerHTML = translatedText; 
                }
            }

            function translateAllElements(container = document) {
                const charData = window.app ? window.app.getCurrentCharacterData() : null;

                container.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (key) { 
                        let directReplacements = {}; // Direkte Ersetzungen basierend auf charData
                        if (charData) {
                            if (key === "custom_prof_info_divide_points") {
                                directReplacements.totalPoints = charData.customProfessionSkillPointBudget;
                            } else if (key === "custom_prof_info_skill_allocation") {
                                const budget = charData.customProfessionSkillPointBudget;
                                let pointsSpent = 0;
                                if (charData.customProfessionSelectedSkills && typeof charData.customProfessionSelectedSkills === 'object') {
                                   Object.values(charData.customProfessionSelectedSkills).forEach(skill => pointsSpent += (skill.points || 0) );
                                }
                                const remainingPoints = budget - pointsSpent;
                                directReplacements.currentBudget = budget;
                                directReplacements.remainingPoints = remainingPoints;
                            } else if (key === "custom_prof_skills_selected_count") {
                                directReplacements.count = charData.customProfessionSelectedSkills ? Object.keys(charData.customProfessionSelectedSkills).length : 0;
                            }
                            // Für stat_array_option_label werden die replacements direkt aus dem data-i18n-replacements Attribut gelesen
                        }
                        applyTranslationsToElement(el, key, directReplacements);
                    }
                });
            }

        function setLanguage(lang) {
            if (!translations[lang] && lang !== 'en') {
                lang = 'en';
            }
            currentLanguage = lang;
            document.documentElement.lang = lang;
            localStorage.setItem('preferredLanguage', lang);
            
            translateAllElements(); 

            if (window.app && typeof window.app.renderCurrentStep === 'function') {
                window.app.renderCurrentStep(); 
            }
            const langDeButton = document.getElementById('lang-de');
            const langEnButton = document.getElementById('lang-en');
            if (langDeButton) langDeButton.classList.toggle('active', lang === 'de');
            if (langEnButton) langEnButton.classList.toggle('active', lang === 'en');
        }

        function initI18n() {
            setupTranslations();
            let langToSet = 'en'; // Standard-Fallback ist Englisch

            // 1. Prüfe, ob eine Sprache explizit vom Nutzer im localStorage gespeichert wurde
            const storedLang = localStorage.getItem('preferredLanguage');
            if (storedLang && translations[storedLang]) {
                langToSet = storedLang;
            } else {
                // 2. Wenn nichts im localStorage, versuche die Browsersprache zu verwenden
                const browserLangFull = navigator.language || navigator.userLanguage; // navigator.language ist Standard
                if (browserLangFull) {
                    const browserLangBase = browserLangFull.split('-')[0].toLowerCase(); // z.B. "de" aus "de-DE"

                    if (browserLangBase === 'de' && translations.de) {
                        // Hier könntest du noch spezifischer auf Regionen prüfen, falls nötig,
                        // z.B. if (browserLangFull.toLowerCase().startsWith('de-de') || browserLangFull.toLowerCase().startsWith('de-at') ...)
                        // Für den Moment reicht es, wenn die Basis "de" ist und wir eine "de"-Übersetzung haben.
                        langToSet = 'de';
                    }
                    // Für alle anderen Browsersprachen bleibt langToSet 'en' (unser Fallback)
                }
            }

            currentLanguage = langToSet;
            // Die erste UI-Aktualisierung und das Setzen von document.documentElement.lang
            // erfolgt durch app.initialize() -> setLanguage(currentLanguage).
        }


        // --- LOGIK: Hauptanwendung (app) ---
        window.app = (function() {
            const MAX_SKILL_INCREASES = 8;
            const SKILL_INCREASE_AMOUNT = 20;
            const MAX_SKILL_VALUE = 80; // Max Wert bei Charaktererstellung
            const STAT_ARRAYS = [
                [13, 13, 12, 12, 11, 11],
                [15, 14, 12, 11, 10, 10],
                [17, 14, 13, 10, 10, 8]
            ];
            const STAT_KEYS = ["STR", "CON", "DEX", "INT", "POW", "CHA"];

            let currentStep = 0;
            let character = {};

            let stepContainer, progressBarContainer, btnNext, btnBack;

            // Hilfsfunktion zum Generieren einer eindeutigen ID
            function generateInstanceId(baseKey, typeName = null) {
                const typePart = typeName ? typeName.toLowerCase().replace(/\s+/g, '_') : 'generic'; // 'generic' statt 'general' für Klarheit
                // Mache die ID etwas kürzer und potenziell stabiler bei schnellen Aufrufen
                const randomPart = Math.random().toString(36).substring(2, 7);
                const timePart = (Date.now() % 100000).toString(36); // Nur die letzten Millisekunden
                return `${baseKey}_${typePart}_${timePart}${randomPart}`;
            }


            function resetCharacter() {
                character = {
                    professionKey: null,
                    customProfessionName: "",
                    isCustomProfession: false,
                    customProfessionBonds: 3,
                    customProfessionSkillPointBudget: 400,
                    customProfessionSelectedSkills: [], // Wird ein Array von {key, typeName, points, tempInstanceId} Objekten
                    customProfessionSetupStage: 'bonds',
                    skillBoostsUsed: 0, // Sicherstellen, dass es hier auf 0 gesetzt wird

                    orSkillChoices: {},
                    profChoiceSkillSelections: {},

                    skills: [], // Array von Skill-Instanz-Objekten

                    statGenerationMethod: 'array', // Standardmethode, oder null und Nutzer muss wählen
                    statArrayChoice: null,      // Für Methode 'array'
                    rolledStatValues: [],       // Für Methode 'rolled'
                    statAssignments: {},
                    stats: { STR: 0, CON: 0, DEX: 0, INT: 0, POW: 0, CHA: 0 },
                    statArrayChoice: null,
                    statAssignments: {},
                    distinguishingFeatures: {},
                    derivedAttributes: { HP: 0, WP: 0, SAN: 0, BP: 0 },
                    bonds: [],
                    motivations: ["", "", "", "", ""]
                };
                initializeCharacterSkills();
            }

            function initializeCharacterSkills() {
                character.skills = []; // Stelle sicher, dass es leer ist für einen sauberen Neuaufbau

                for (const skillKey in ALL_SKILLS) {
                    if (ALL_SKILLS.hasOwnProperty(skillKey)) {
                        const skillDef = ALL_SKILLS[skillKey];
                        const newInstance = {
                            instanceId: generateInstanceId(skillKey, null),
                            key: skillKey,
                            typeName: skillDef.type ? "" : null,
                            value: skillDef.base,
                            baseValueFromProfession: 0,
                            increases: 0, // WICHTIG: Hier auf 0 setzen!
                            isProfessional: false,
                            isChoiceSkill: false,
                            slotId: null // explizit null setzen
                        };
                        character.skills.push(newInstance);
                    }
                }
                // Setze auch den globalen Zähler für verwendete Boosts zurück
                character.skillBoostsUsed = 0;
                // character.remainingBoostPool = MAX_SKILL_INCREASES * SKILL_INCREASE_AMOUNT; // Nicht mehr so genutzt
                console.log("Character skills initialized and skillBoostsUsed reset to 0.");
            }
            
            function updateSkill(skillKey, newValue, isProfessional = false, isChoiceSkill = false, typeName = undefined) {
                if (!character.skills[skillKey]) return;
                const skill = character.skills[skillKey];
                skill.value = Math.max(0, Math.min(99, newValue));
                if (isProfessional) skill.isProfessional = true;
                if (isChoiceSkill) skill.isChoiceSkill = true;
                if (typeName !== undefined) skill.typeName = typeName;
            }

            function renderIntro() {
                if (currentStep === 0) resetCharacter();
                return `
                    <div class="step" id="step-intro">
                        <div class="info-box"><p data-i18n="intro_quote_dg"></p></div>
                        <p data-i18n="intro_welcome_text"></p>
                    </div>`;
            }

            // STEP 1: PROFESSION & SKILLS (Haupt-Renderfunktion für Schritt 1)
            function renderStep1_ProfessionSkills() {
                // console.log("RenderStep1 - Start. isCustom:", character.isCustomProfession, "Stage:", character.customProfessionSetupStage, "ProfKey:", character.professionKey);
                if (character.isCustomProfession) {
                    if (character.customProfessionSetupStage === 'bonds') {
                        return renderCustomProfession_BondSetup();
                    } else if (character.customProfessionSetupStage === 'skills') {
                        return renderCustomProfession_SkillAllocation();
                    } else { // customProfessionSetupStage === 'done'
                        let html = `<div class="step" id="step1-final-skill-increases-custom">
                            <div class="info-box">
                                <p data-i18n="step1_info2"></p>
                            </div>
                            <h3 data-i18n="step1_increase_skills_label"></h3>
                            <p style="text-align: right;"><span data-i18n="increases_chosen_label"></span> <span id="increases-chosen-count">0</span> / ${MAX_SKILL_INCREASES}</p>
                            <div id="all-skills-list-container"></div>
                        </div>`;
                        return html;
                    }
                } else { // Standard-Beruf Logik (oder keine Auswahl)
                    character.isCustomProfession = false;
                    character.customProfessionSetupStage = 'bonds'; // Reset custom stage

                    let html = `<div class="step" id="step1-profession-standard">
                        <div class="info-box">
                            <p data-i18n="step1_info1"></p>
                            <p data-i18n="step1_info2"></p>
                        </div>
                        <h2><label for="profession-select" data-i18n="step1_select_profession_label"></label></h2>
                        <select id="profession-select">
                            <option value="" data-i18n="select_one_option">${t('select_one_option')}</option>`;
                    for (const profKey in PROFESSIONS) {
                        if (PROFESSIONS[profKey] && PROFESSIONS[profKey].nameKey) {
                            html += `<option value="${profKey}" ${character.professionKey === profKey ? 'selected' : ''}>${t(PROFESSIONS[profKey].nameKey)}</option>`;
                        }
                    }
                    html += `</select>
                        <div id="profession-details-container">
                            <!-- Wird von renderProfessionSpecificChoices gefüllt -->
                        </div>
                        <div id="skill-increase-section" style="display: ${character.professionKey && !PROFESSIONS[character.professionKey]?.isCustom ? 'block' : 'none'}; margin-top: 20px;">
                            <h3 data-i18n="step1_increase_skills_label"></h3>
                            <p style="text-align: right;"><span data-i18n="increases_chosen_label"></span> <span id="increases-chosen-count">0</span> / ${MAX_SKILL_INCREASES}</p>
                            <div id="all-skills-list-container">
                                <!-- Wird von renderAllSkillsList gefüllt -->
                            </div>
                        </div>
                    </div>`;
                    return html;
                }
            }

            // NEU: Render-Funktion für Custom Profession - Bond Setup
            // --- Custom Profession Funktionen (müssen noch angepasst werden, um mit Instanzen zu arbeiten) ---
            // --- Custom Profession Funktionen (müssen noch angepasst werden, um mit Instanzen zu arbeiten) ---
            function renderCustomProfession_BondSetup() { /* ... bleibt erstmal ähnlich ... */
                 const initialTotalPoints = 400;
                character.customProfessionSkillPointBudget = initialTotalPoints - ((character.customProfessionBonds - 3) * 50);

                let html = `<div class="step" id="step1-custom-bonds">
                    <h2 data-i18n="custom_prof_title_bond_setup"></h2>
                    <div class="info-box">
                        <h3 data-i18n="custom_prof_info_rules_title"></h3>
                        <p data-i18n="custom_prof_info_default_bonds"></p>
                        <p data-i18n="custom_prof_info_customize_bonds"></p>
                        <p data-i18n="custom_prof_info_pick_skills"></p>
                        <p data-i18n="custom_prof_info_divide_points" data-i18n-replacements='{"totalPoints": "${character.customProfessionSkillPointBudget}"}'></p>
                        <p data-i18n="custom_prof_info_add_to_start"></p>
                        <p data-i18n="custom_prof_info_rule_of_thumb"></p>
                        <p data-i18n="custom_prof_info_max_skill"></p>
                    </div>
                    <div id="custom-profession-name-input-container" style="margin-top: 15px;">
                        <label for="custom-profession-name" data-i18n="label_custom_profession_name"></label>
                        <input type="text" id="custom-profession-name" value="${character.customProfessionName || ''}" placeholder="e.g., Occult Detective">
                    </div>
                    <div>
                        <label data-i18n="custom_prof_label_current_bonds"></label>
                        <button id="btn-decrease-bonds" class="action-button-small" ${character.customProfessionBonds <= 1 ? 'disabled' : ''}>-</button>
                        <span id="custom-bonds-display" style="margin: 0 10px; font-weight: bold;">${character.customProfessionBonds}</span>
                        <button id="btn-increase-bonds" class="action-button-small" ${character.customProfessionBonds >= 4 ? 'disabled' : ''}>+</button>
                    </div>
                    <div style="margin-top: 10px;">
                        <label data-i18n="custom_prof_label_skill_point_budget"></label>
                        <span id="custom-skill-budget-display" style="font-weight: bold;">${character.customProfessionSkillPointBudget}</span>
                    </div>
                    <div class="custom-prof-actions-container" style="margin-top: 20px;">
                         <button id="btn-confirm-bonds" class="action-button" data-i18n="custom_prof_btn_confirm_bonds"></button>
                    </div>
                </div>`;
                return html;
            }

            // NEU: Render-Funktion für Custom Profession - Skill Allocation
             function renderCustomProfession_SkillAllocation() {
                const budget = character.customProfessionSkillPointBudget;
                let pointsSpent = 0;
                character.customProfessionSelectedSkills.forEach(inst => pointsSpent += (inst.points || 0));
                const remainingPoints = budget - pointsSpent;
                const selectedInstancesCount = character.customProfessionSelectedSkills.length;

                let html = `<div class="step" id="step1-custom-skills">
                    <h2 data-i18n="custom_prof_title_skill_allocation"></h2>
                    <div class="info-box">
                        <p id="custom-prof-skill-allocation-info" data-i18n="custom_prof_info_skill_allocation">
                            ${t('custom_prof_info_skill_allocation', {currentBudget: budget, remainingPoints: remainingPoints})}
                        </p>
                         <p>${t('custom_prof_info_max_skill')}</p> <!-- Max 60% Regel -->
                    </div>
                    <p><span data-i18n="custom_prof_skills_selected_label_prefix"></span>
                       <span id="custom-skills-selected-actual-count">${selectedInstancesCount}</span> / 10
                    </p>
                    <div id="custom-profession-skill-list">`;

                // Sortiere Basis-Skills für die Auswahl-Checkboxen
                const sortedBaseSkillKeys = Object.keys(ALL_SKILLS).sort((a, b) =>
                    t(ALL_SKILLS[a].nameKey).localeCompare(t(ALL_SKILLS[b].nameKey), currentLanguage)
                );

                sortedBaseSkillKeys.forEach(baseKey => {
                    if (baseKey === "unnatural") return; // Unnatural nicht hier wählbar

                    const skillDef = ALL_SKILLS[baseKey];
                    const instancesOfThisBaseKey = character.customProfessionSelectedSkills.filter(inst => inst.key === baseKey);
                    const isBaseSkillSelectedAtLeastOnce = instancesOfThisBaseKey.length > 0;

                    html += `<div class="skill-list-item custom-skill-item-base" data-base-skill-key="${baseKey}">
                                <div class="base-skill-line"> <!-- CSS wird dies als flex formatieren -->
                                    <div> <!-- Wrapper für linke Seite: Checkbox, Name, Info -->
                                        <label class="inline-label" style="margin-right: 5px;">
                                            <input type="checkbox" class="custom-prof-skill-select-main"
                                                   data-skill-key="${baseKey}"
                                                   data-is-typed="${skillDef.type ? 'true' : 'false'}"
                                                   ${isBaseSkillSelectedAtLeastOnce ? 'checked' : ''}
                                                   ${selectedInstancesCount >= 10 && !isBaseSkillSelectedAtLeastOnce ? 'disabled' : ''}>
                                            ${t(skillDef.nameKey)}
                                        </label>
                                        <span class="skill-info-icon" title="${t(skillDef.descKey)}">i
                                            <span class="tooltip">${t(skillDef.descKey)}</span>
                                        </span>
                                    </div>`;
                    if (skillDef.type && isBaseSkillSelectedAtLeastOnce && selectedInstancesCount < 10) {
                        html += `<button class="btn-add-another-specialization action-button-small" 
                                         data-skill-key="${baseKey}"
                                         title="${t('add_specialization_button_text', {skillName: t(skillDef.nameKey)})}"
                                         style="font-size:0.8em; padding: 2px 5px;">+</button>`; // Text wurde zu + verkürzt für Platz
                    } else {
                        html += `<div></div>`; // Leeres Div für Flexbox-Ausrichtung (justify-content: space-between)
                    }
                    html += `   </div> <!-- Ende .base-skill-line -->
                                <div class="skill-instances-container" data-skill-key-instances="${baseKey}">`;

                    instancesOfThisBaseKey.forEach(instance => {
                        const currentSkillTotal = skillDef.base + (instance.points || 0);
                        html += `<div class="skill-instance-controls" data-instance-temp-id="${instance.tempInstanceId}">
                                    ${skillDef.type ? 
                                        `<input type="text" class="custom-instance-type-input" 
                                                data-instance-temp-id="${instance.tempInstanceId}" 
                                                value="${instance.typeName || ''}" 
                                                placeholder="${t('specify_type_placeholder')}">`
                                      : 
                                        // Platzhalter für nicht-typisierte Skills, um Layout-Konsistenz zu wahren.
                                        // Die Breite sollte ungefähr der des Typ-Eingabefelds entsprechen.
                                        // CSS für .custom-instance-type-input setzt min-width: 100px;
                                        `<span class="custom-instance-type-input-placeholder" style="display: inline-block; min-width: 100px; max-width:180px; flex-grow:1; flex-shrink:1; margin-right:8px;"> </span>`
                                    }
                                    <span>${t('custom_prof_label_assign_points')}</span>
                                    <button class="custom-skill-point-btn" data-action="decrease" data-amount="10" data-instance-temp-id="${instance.tempInstanceId}">-10</button>
                                    <button class="custom-skill-point-btn" data-action="decrease" data-amount="5" data-instance-temp-id="${instance.tempInstanceId}">-5</button>
                                    <span class="custom-skill-assigned-points">${instance.points || 0}</span>
                                    <button class="custom-skill-point-btn" data-action="increase" data-amount="5" data-instance-temp-id="${instance.tempInstanceId}">+5</button>
                                    <button class="custom-skill-point-btn" data-action="increase" data-amount="10" data-instance-temp-id="${instance.tempInstanceId}">+10</button>
                                    <strong class="custom-skill-total-value">${t('custom_prof_label_skill_total')} ${currentSkillTotal}% (max 60%)</strong>
                                    ${instancesOfThisBaseKey.length > 1 ? // Entfernen-Button NUR anzeigen, wenn MEHR ALS EINE Instanz DIESES Basis-Skills existiert
                                        `<button class="remove-custom-skill-instance-btn" 
                                                 data-instance-temp-id="${instance.tempInstanceId}" 
                                                 title="${t('remove_button_title')}"
                                                 style="color:red; border:none; background:none; cursor:pointer; font-weight:bold; font-size:1.2em; padding:0 5px;">×</button>`
                                        : ''
                                    }
                                 </div>`;
                    });
                    html += `       </div> <!-- Ende .skill-instances-container -->
                             </div>`; // Ende .custom-skill-item-base
                });
                html += `   </div> <!-- Ende #custom-profession-skill-list -->
                            <div class="custom-prof-actions-container">
                                <button id="btn-confirm-custom-skills" class="action-button" data-i18n="custom_prof_btn_confirm_skills"></button>
                            </div>
                        </div>`;
                return html;
            }

            // attachStep1Listeners (Anpassung für 'done' Stage)
            // attachStep1Listeners (Anpassung für Custom Stages und Dropdown-Handling)
            function attachStep1Listeners() {
                const mainSelect = document.getElementById('profession-select');

                if (mainSelect) { // Gilt für Standard-Layout und wenn Custom Prof *nicht* aktiv ist
                    mainSelect.removeEventListener('change', handleMainProfessionSelectChange);
                    mainSelect.addEventListener('change', handleMainProfessionSelectChange);
                    if (character.professionKey !== mainSelect.value) { // Sync dropdown if needed
                         mainSelect.value = character.professionKey || "";
                    }
                }

                if (character.isCustomProfession) {
                    if (character.customProfessionSetupStage === 'bonds') {
                        attachCustomBondSetupListeners();
                    } else if (character.customProfessionSetupStage === 'skills') {
                        attachCustomSkillAllocationListeners();
                    } else { // 'done'
                        renderAllSkillsList(); // Zeigt die Liste für +20% Boosts
                    }
                } else if (character.professionKey && PROFESSIONS[character.professionKey] && !PROFESSIONS[character.professionKey].isCustom) {
                    // Standardberuf ist ausgewählt
                    renderProfessionSpecificChoices(PROFESSIONS[character.professionKey]);
                    renderAllSkillsList(); // Zeigt die Liste für +20% Boosts
                } else {
                    // Kein Beruf gewählt oder "Custom" aber noch nicht 'done'
                    // Leere die spezifischen Details und die Skill-Boost-Liste
                    const profDetailsContainer = document.getElementById('profession-details-container');
                    if (profDetailsContainer) profDetailsContainer.innerHTML = '';
                    const skillIncreaseSection = document.getElementById('skill-increase-section');
                    if (skillIncreaseSection) skillIncreaseSection.style.display = 'none';
                    const allSkillsListContainer = document.getElementById('all-skills-list-container');
                    if(allSkillsListContainer) allSkillsListContainer.innerHTML = ''; // Leeren, wenn kein Beruf
                }
            }
            // Hilfsfunktion, um eine Skill-Instanz im character.skills Array zu finden oder zu erstellen
            // Gibt die gefundene/erstellte Instanz zurück
            function findOrCreateSkillInstance(skillKey, typeName = null, isProfessional = false, profSkillValueTarget = 0, professionalSlotId = null) {
                const skillDef = ALL_SKILLS[skillKey];
                if (!skillDef) {
                    console.error(`CORE ERROR: Skill-Definition für Key ${skillKey} nicht in ALL_SKILLS gefunden!`);
                    return null;
                }

                let instance = null;
                const normalizedTypeName = (skillDef.type && typeName && typeName.trim() !== "") ? typeName.trim() : (skillDef.type ? "" : null);

                // console.log(`--- findOrCreateSkillInstance ---`);
                // console.log(`Params: key=${skillKey}, type=${typeName}, isProf=${isProfessional}, targetVal=${profSkillValueTarget}, profSlotId=${professionalSlotId}, normType='${normalizedTypeName}'`);

                let foundExistingSpecific = false;

                // SUCHE:
                if (professionalSlotId) {
                    instance = character.skills.find(s => s.key === skillKey && s.slotId === professionalSlotId);
                    // if (instance) console.log(`FOCSI: Found instance by professionalSlotId '${professionalSlotId}'`);
                }

                if (!instance && skillDef.type && normalizedTypeName !== "") { // spezifischer Typ, kein Slot oder Slot nicht gefunden
                    instance = character.skills.find(s => s.key === skillKey && s.typeName === normalizedTypeName && !s.slotId); // Nur nicht-Slot-gebundene
                    if (instance) {
                        // console.log(`FOCSI: Found instance by specific typeName '${normalizedTypeName}' (and not slot-bound)`);
                        foundExistingSpecific = true; // Merken, dass wir eine exakte Typ-Übereinstimmung hatten
                    }
                }

                if (!instance) { // Immer noch keine -> suche generische (type="") oder nicht-typisierte (type=null) ohne Slot
                    instance = character.skills.find(s => s.key === skillKey && s.typeName === normalizedTypeName && !s.slotId);
                    // if (instance) console.log(`FOCSI: Found generic/non-typed instance (key=${skillKey}, type='${normalizedTypeName}', no slotId)`);
                }

                // VERARBEITUNG:
                let createdNewInstance = false;
                if (instance) {
                    const wantsSpecificProfessionalSlot = !!professionalSlotId;
                    // Gilt für Choice Skills, die einen spezifischen Typ bekommen sollen
                    const wantsSpecificProfessionalNonSlotType = isProfessional && skillDef.type && normalizedTypeName !== "" && !professionalSlotId;

                    // Ansatz B Trigger:
                    // 1. Wir wollen einen spezifischen Slot füllen, haben aber eine Instanz ohne diesen Slot gefunden.
                    // 2. Wir wollen einen spezifischen Typ (nicht-Slot) professionalisieren, haben aber die generische (type=="", kein Slot) gefunden.
                    if ( (wantsSpecificProfessionalSlot && instance.slotId !== professionalSlotId) ||
                         (wantsSpecificProfessionalNonSlotType && instance.typeName === "" && !instance.slotId && !foundExistingSpecific) ) {
                        // console.log(`FOCSI - Ansatz B / Slot Trigger: Force new. WantsSlot=${wantsSpecificProfessionalSlot}, WantsNonSlotType=${wantsSpecificProfessionalNonSlotType}, FoundInstSlot=${instance.slotId}, FoundInstType='${instance.typeName}'`);
                        instance = null;
                    } else {
                        // console.log(`FOCSI - Update existing: Key=${skillKey}, NormType=${normalizedTypeName}, InstSlot=${instance.slotId}, InstType='${instance.typeName}', isProf=${isProfessional}`);
                        if (isProfessional) {
                            instance.isProfessional = true;
                            // Nur typeName setzen, wenn es ein Default vom Beruf ist und die Instanz generisch war
                            // oder wenn wir einen Slot haben und der übergebene typeName dafür gedacht ist (sollte "" sein initial)
                            if (skillDef.type && normalizedTypeName !== "" && instance.typeName === "" && !professionalSlotId && !instance.slotId) {
                                instance.typeName = normalizedTypeName;
                            }
                            const valueFromProfessionOnly = Math.max(0, profSkillValueTarget - skillDef.base);
                            instance.baseValueFromProfession = Math.max(instance.baseValueFromProfession || 0, valueFromProfessionOnly);
                        }
                        // Wert wird unten final berechnet und gekappt
                    }
                }

                if (!instance) { // Keine passende Instanz gefunden ODER Neuerstellung wurde erzwungen
                    // console.log(`FOCSI - Creating NEW instance for key=${skillKey}, typeName='${normalizedTypeName}', slotId='${professionalSlotId || null}'`);
                    const newInstanceId = generateInstanceId(skillKey, professionalSlotId || normalizedTypeName);
                    const valueFromProfessionOnlyOnCreate = isProfessional ? Math.max(0, profSkillValueTarget - skillDef.base) : 0;

                    instance = {
                        instanceId: newInstanceId,
                        key: skillKey,
                        typeName: normalizedTypeName,
                        value: skillDef.base + valueFromProfessionOnlyOnCreate,
                        baseValueFromProfession: valueFromProfessionOnlyOnCreate,
                        increases: 0,
                        isProfessional: isProfessional,
                        isChoiceSkill: false,
                        slotId: professionalSlotId || null
                    };
                    character.skills.push(instance);
                    createdNewInstance = true;
                }

                // Finale Wertberechnung und Capping für die (gefundene oder neue) Instanz:
                if (instance) {
                    if (createdNewInstance && professionalSlotId && typeName === "" && instance.typeName !== "") {
                        // Fall: Ein neuer Slot wurde erstellt, der `typeNameToApply` war `""` (Benutzereingabe erwartet),
                        // aber `normalizedTypeName` war auch `""`. Stelle sicher, dass `instance.typeName` `""` ist.
                        instance.typeName = "";
                    }

                    // Wert basierend auf allen Komponenten berechnen
                    instance.value = skillDef.base +
                                     (instance.baseValueFromProfession || 0) +
                                     ((instance.increases || 0) * SKILL_INCREASE_AMOUNT);

                    // MAX_SKILL_VALUE (z.B. 80) Capping durch Anpassung der Increases
                    if (instance.value > MAX_SKILL_VALUE) {
                        // console.warn(`FOCSI: Calculated value ${instance.value} for ${instance.key} (${instance.typeName || ''}, Slot: ${instance.slotId || 'N/A'}) exceeds MAX_SKILL_VALUE ${MAX_SKILL_VALUE}. Adjusting increases.`);
                        let pointsFromBaseAndProf = skillDef.base + (instance.baseValueFromProfession || 0);
                        let maxPointsFromIncreases = MAX_SKILL_VALUE - pointsFromBaseAndProf;

                        if (maxPointsFromIncreases < 0) maxPointsFromIncreases = 0;

                        let maxAllowedIncreases = Math.floor(maxPointsFromIncreases / SKILL_INCREASE_AMOUNT);
                        if (maxAllowedIncreases < 0) maxAllowedIncreases = 0;

                        if ((instance.increases || 0) > maxAllowedIncreases) {
                            // console.log(`   Reducing increases from ${(instance.increases || 0)} to ${maxAllowedIncreases}`);
                            // Hier könnte man die "verlorenen" Increases dem globalen Pool gutschreiben
                            // character.availableSkillBoosts += ((instance.increases || 0) - maxAllowedIncreases); // Beispiel
                            instance.increases = maxAllowedIncreases;
                        }
                        // Wert final neu berechnen mit den angepassten Increases
                        instance.value = skillDef.base + (instance.baseValueFromProfession || 0) + (instance.increases * SKILL_INCREASE_AMOUNT);
                    }

                    // Generelle Unter- und Obergrenze (99 ist das absolute Maximum im Spiel)
                    instance.value = Math.min(instance.value, 99);
                    instance.value = Math.max(instance.value, 0);
                }
                // console.log(`FOCSI Final instance:`, instance ? JSON.parse(JSON.stringify(instance)): "null");
                return instance;
            }


            // Wird von handleMainProfessionSelectChange aufgerufen, wenn ein Standardberuf gewählt wird
            // Neuer Handler für das Haupt-Profession-Dropdown (um zwischen Standard und Custom zu wechseln)
            function handleMainProfessionSelectChange(event) {
                const newProfessionKey = event.target.value;
                const oldProfessionKey = character.professionKey;

                if (newProfessionKey === oldProfessionKey && newProfessionKey !== "") return; // Keine echte Änderung

                character.professionKey = newProfessionKey;

                if (newProfessionKey === "custom_profession") {
                    const wasNotCustomOrWasDone = oldProfessionKey !== "custom_profession" || character.customProfessionSetupStage === 'done' || !oldProfessionKey;
                    character.isCustomProfession = true;
                    if (wasNotCustomOrWasDone) {
                        character.customProfessionSetupStage = 'bonds';
                        // Reset custom profession data
                        character.customProfessionBonds = 3;
                        character.customProfessionSkillPointBudget = 400; // Wird in renderCustom... neu berechnet
                        character.customProfessionSelectedSkills = [];
                        character.customProfessionName = "";
                        // Wichtig: Skills nicht komplett resetten, wenn man nur zwischen Custom Stages wechselt.
                        // Ein kompletter Skill-Reset (initializeCharacterSkills) passiert nur,
                        // wenn man von einem Standardberuf zu Custom wechselt oder "Select One" wählt.
                        if(oldProfessionKey && oldProfessionKey !== "custom_profession") {
                            initializeCharacterSkills(); // Reset skills to base if switching from a standard profession
                        }
                    }
                } else if (newProfessionKey) { // Ein Standardberuf wurde gewählt
                    const wasCustom = character.isCustomProfession;
                    character.isCustomProfession = false;
                    character.customProfessionSetupStage = 'bonds'; // Reset custom stage

                    // Nur Skills und Auswahlen zurücksetzen, wenn sich der Beruf tatsächlich geändert hat
                    // oder man von Custom kam.
                    if (oldProfessionKey !== newProfessionKey || wasCustom) {
                        initializeCharacterSkills(); // Setzt alle Skill-Instanzen zurück auf Basis!
                        character.orSkillChoices = {};
                        character.profChoiceSkillSelections = {};
                    }
                    applyStandardProfessionLogic(newProfessionKey);
                } else { // "-- Select One --" wurde gewählt
                    character.isCustomProfession = false;
                    character.professionKey = null;
                    character.customProfessionSetupStage = 'bonds';
                    initializeCharacterSkills(); // Setzt Skills auf Basiswerte zurück
                    character.orSkillChoices = {};
                    character.profChoiceSkillSelections = {};
                }
                renderCurrentStep();
            }
            // Hilfsfunktion für Standardberufslogik, ausgelagert aus handleMainProfessionSelectChange
            function applyStandardProfessionLogic(profKeyToApply) {
                const profData = PROFESSIONS[profKeyToApply];
                if (!profData || profData.isCustom) return;

                // initializeCharacterSkills() wurde bereits in handleMainProfessionSelectChange aufgerufen,
                // wodurch alle Skills auf Basiswerte zurückgesetzt wurden (inkl. typeName = "" für typisierte).

                profData.baseSkills.forEach(skillInfo => {
                    let keyToApply = skillInfo.key;
                    let targetValueToApply = skillInfo.value;
                    let typeNameToApplyOnCreate = null; // Wichtig für FOCSI
                    let professionalSlotId = null;

                    const skillDef = ALL_SKILLS[keyToApply];

                    if (skillInfo.orSkills && skillInfo.orSkills.length > 0) {
                        // Für "orSkills" wird der Typ initial leer sein, wenn der gewählte Skill typisiert ist.
                        // Der Nutzer muss ihn dann ggf. in 1.3 spezifizieren, wenn er den Skill boostet.
                        // Hier setzen wir die erste Option als Standard.
                        const chosenOrData = skillInfo.orSkills[0];
                        character.orSkillChoices[skillInfo.id] = chosenOrData.key; // Initialwahl speichern
                        keyToApply = chosenOrData.key;
                        targetValueToApply = chosenOrData.value;
                        typeNameToApplyOnCreate = ALL_SKILLS[keyToApply]?.type ? "" : null;
                    } else if (skillDef.type) {
                        if (skillInfo.typeNameDefault) {
                            typeNameToApplyOnCreate = skillInfo.typeNameDefault;
                        } else if (skillInfo.id) { // Ein "leerer" Slot wie sci1, sci2
                            professionalSlotId = skillInfo.id;
                            typeNameToApplyOnCreate = ""; // Typ wird vom User in 1.2 UI eingegeben
                        } else { // Typisierter Skill ohne Default und ohne Slot-ID (seltener Fall für Basis-Berufsskill)
                            typeNameToApplyOnCreate = "";
                        }
                    } else { // Nicht-typisierter Skill
                        typeNameToApplyOnCreate = null;
                    }

                    // findOrCreateSkillInstance kümmert sich um die Erstellung/Aktualisierung
                    // Die `true` für isProfessional und der `targetValueToApply` setzen den Berufswert.
                    findOrCreateSkillInstance(keyToApply, typeNameToApplyOnCreate, true, targetValueToApply, professionalSlotId);
                });
                console.log("applyStandardProfessionLogic finished for:", profKeyToApply);
            }
            function attachCustomBondSetupListeners() { /* ... bleibt erstmal ähnlich ... */
                const btnDecreaseBonds = document.getElementById('btn-decrease-bonds');
                const btnIncreaseBonds = document.getElementById('btn-increase-bonds');
                const btnConfirmBonds = document.getElementById('btn-confirm-bonds');
                const customProfNameInput = document.getElementById('custom-profession-name');

                if (btnDecreaseBonds) {
                    btnDecreaseBonds.onclick = () => {
                        if (character.customProfessionBonds > 1) {
                            character.customProfessionBonds--;
                            renderCurrentStep();
                        }
                    };
                }
                if (btnIncreaseBonds) {
                    btnIncreaseBonds.onclick = () => {
                        if (character.customProfessionBonds < 4) {
                            character.customProfessionBonds++;
                            renderCurrentStep();
                        }
                    };
                }
                if (btnConfirmBonds) {
                    btnConfirmBonds.onclick = () => {
                        if (!character.customProfessionName || character.customProfessionName.trim() === "") {
                            alert("Please enter a name for your custom profession."); // Oder i18n
                            return;
                        }
                        character.customProfessionSetupStage = 'skills';
                        character.customProfessionSelectedSkills = []; // Reset für Skill-Auswahl-Phase
                        renderCurrentStep();
                    };
                }
                if (customProfNameInput) {
                    customProfNameInput.addEventListener('input', (event) => {
                        character.customProfessionName = event.target.value;
                    });
                }
            }
            // Neuer Handler für das Haupt-Profession-Dropdown (um zwischen Standard und Custom zu wechseln)
             function handleMainProfessionSelectChange(event) {
                const newProfessionKey = event.target.value;
                const oldProfessionKey = character.professionKey;
                // Nicht character.professionKey hier schon setzen, erst nach den Resets,
                // falls der alte Wert für irgendeine Logik noch gebraucht wird.
                // Besser: character.professionKey = newProfessionKey; am Ende der if/else if Kette.

                console.log("MainProfSelectChange: OldKey:", oldProfessionKey, "NewKey:", newProfessionKey, "Current CustomStage:", character.customProfessionSetupStage);
                const customNameInputContainer = document.getElementById('custom-profession-name-input-container');
                if (customNameInputContainer) {
                    customNameInputContainer.style.display = (newProfessionKey === 'custom_profession') ? 'block' : 'none';
                }
                if (newProfessionKey !== 'custom_profession') {
                    character.customProfessionName = "";
                }

                if (newProfessionKey === "custom_profession") {
                    // Logik für Custom Profession (scheint erstmal okay zu sein)
                    const wasNotCustomOrWasDone = oldProfessionKey !== "custom_profession" || !character.customProfessionSetupStage || character.customProfessionSetupStage === 'done' || !oldProfessionKey;
                    character.isCustomProfession = true;
                    if (wasNotCustomOrWasDone) {
                        console.log("MainProfSelectChange: Switching to Custom or resetting Custom. Setting stage to 'bonds'.");
                        if (oldProfessionKey && oldProfessionKey !== "custom_profession") { // Nur wenn von Standard zu Custom gewechselt wird
                            initializeCharacterSkills(); // Resettet auch orSkillChoices etc.
                            character.orSkillChoices = {}; // Explizit
                            character.profChoiceSkillSelections = {};
                        }
                        character.customProfessionSetupStage = 'bonds';
                        character.customProfessionBonds = 3;
                        character.customProfessionSkillPointBudget = 400;
                        character.customProfessionSelectedSkills = []; // War vorher ein Objekt {}
                        character.customProfessionName = "";
                    } else {
                        console.log("MainProfSelectChange: Already in Custom Profession, stage remains:", character.customProfessionSetupStage);
                    }
                    character.professionKey = newProfessionKey; // Setze den Key

                } else if (newProfessionKey) { // Ein Standardberuf wurde gewählt
                    console.log("Standard profession selected:", newProfessionKey);
                    const wasCustom = character.isCustomProfession;
                    character.isCustomProfession = false;
                    character.customProfessionSetupStage = 'bonds';

                    if (oldProfessionKey !== newProfessionKey || wasCustom) {
                        console.log("Resetting skills and choices for new standard profession or switch from custom.");
                        initializeCharacterSkills(); // Dies setzt skills zurück und leert orSkillChoices etc. intern
                        character.orSkillChoices = {}; // Explizit hier (obwohl initCharSkills es auch macht)
                        character.profChoiceSkillSelections = {};
                    }
                    character.professionKey = newProfessionKey; // Setze den Key
                    applyStandardProfessionLogic(newProfessionKey); // <<=== HIER AUFRUFEN!

                } else { // "-- Select One --" wurde gewählt
                    console.log("No profession selected ('-- Select One --')");
                    character.isCustomProfession = false;
                    character.customProfessionSetupStage = 'bonds';
                    initializeCharacterSkills(); // Resettet alles
                    character.orSkillChoices = {};
                    character.profChoiceSkillSelections = {};
                    character.professionKey = null; // Key auf null setzen
                }
                renderCurrentStep();
            }
            function renderProfessionSpecificChoices(profData) {
                const container = document.getElementById('profession-details-container');
                if (!container) {
                    console.error("renderProfessionSpecificChoices: Container #profession-details-container NOT FOUND");
                    return;
                }
                // console.log("renderProfessionSpecificChoices: CALLED for profData:", profData.nameKey);

                let detailsHtml = `<h3 data-i18n="step1_2_profession_specific_label">${t('step1_2_profession_specific_label')}</h3>`;
                detailsHtml += `<p><strong data-i18n="bonds_label">${t('bonds_label')}:</strong> ${profData.bonds}</p>`;

                // Ermittle Keys, die bereits durch "orSkill"-Auswahl belegt sind (für spätere Nutzung in Choice Skills)
                const chosenOrSkillKeys = new Set();
                profData.baseSkills.forEach(skillInfo => {
                    if (skillInfo.orSkills && skillInfo.orSkills.length > 0) {
                        const currentChoice = character.orSkillChoices[skillInfo.id] || skillInfo.orSkills[0].key;
                        chosenOrSkillKeys.add(currentChoice);
                    }
                });

                // 1. Basis-Skills des Berufs rendern
                profData.baseSkills.forEach(skillInfo => {
                    if (skillInfo.orSkills && skillInfo.orSkills.length > 0) {
                        // --- Fall: "OR" Skill Gruppe ---
                        // console.log("Rendering orSkills for group:", skillInfo.id);
                        const currentChoiceKey = character.orSkillChoices[skillInfo.id] || skillInfo.orSkills[0].key;
                        detailsHtml += `<div class="profession-choice-group or-skill-group">
                                            <p>${t('choose_one_label')}:</p>`;
                        skillInfo.orSkills.forEach((orOption) => {
                            const orSkillDef = ALL_SKILLS[orOption.key];
                            if (!orSkillDef) {
                                console.error(`Render OrSkill: Skill-Definition für ${orOption.key} fehlt!`);
                                detailsHtml += `<span style="color:red;">Error: Skill '${orOption.key}' def missing</span>`;
                                return; // continue forEach
                            }
                            const skillName = t(orSkillDef.nameKey);
                            detailsHtml += `<label class="inline-label">
                                                <input type="radio" name="orSkill_${skillInfo.id}" 
                                                       value="${orOption.key}" data-group-id="${skillInfo.id}" 
                                                       data-target-value="${orOption.value}" 
                                                       ${currentChoiceKey === orOption.key ? 'checked' : ''}> 
                                                ${skillName} (${orOption.value}%)
                                            </label> `;
                        });
                        detailsHtml += `</div>`;
                    } else if (skillInfo.key) {
                        // --- Fall: Regulärer Basis-Skill (hat einen 'key') ---
                        const baseSkillDef = ALL_SKILLS[skillInfo.key];
                        if (!baseSkillDef) {
                            console.error(`renderProfessionSpecificChoices: Skill-Definition für Key ${skillInfo.key} fehlt.`);
                            detailsHtml += `<p style="color:red;">Error: Skill definition missing for ${skillInfo.key}</p>`;
                            return; // Nächster skillInfo in profData.baseSkills.forEach
                        }

                        if (baseSkillDef.type) { // Typisierter Basis-Skill (kann Slot oder Skill mit Default sein)
                            const skillName = t(baseSkillDef.nameKey);
                            const targetValue = skillInfo.value;
                            let currentInstance = null;
                            let uiElementIdSuffixForInput = "";

                            // Finde die zugehörige Instanz im character.skills Array
                            if (skillInfo.id && !skillInfo.typeNameDefault) {
                                // Dies ist ein "leerer" Slot, der durch seine ID identifiziert wird (z.B. "sci1")
                                currentInstance = character.skills.find(s => s.key === skillInfo.key && s.slotId === skillInfo.id && s.isProfessional);
                                uiElementIdSuffixForInput = skillInfo.id;
                            } else {
                                // Typisierter Skill mit typeNameDefault ODER generischer typisierter Prof-Skill ohne Slot-ID
                                const expectedTypeName = skillInfo.typeNameDefault || "";
                                currentInstance = character.skills.find(s =>
                                    s.key === skillInfo.key &&
                                    s.isProfessional &&
                                    !s.slotId &&
                                    s.typeName === expectedTypeName
                                );
                                if (!currentInstance && expectedTypeName !== "" && expectedTypeName !== null) { // Fallback, falls Typ in Instanz noch leer
                                    currentInstance = character.skills.find(s => s.key === skillInfo.key && s.isProfessional && !s.slotId && s.typeName === "");
                                    if (currentInstance) currentInstance.typeName = expectedTypeName; // Versuche zu korrigieren
                                }
                                uiElementIdSuffixForInput = currentInstance ? currentInstance.instanceId : generateInstanceId(skillInfo.key, "prof_typed_ui");
                            }

                            if (!currentInstance) {
                                console.warn(`renderProfessionSpecificChoices: Instanz für professionellen Skill ${skillInfo.key} (ID: ${skillInfo.id}, Default: ${skillInfo.typeNameDefault}) nicht gefunden. Erstelle temporäre UI-Struktur.`);
                                // Erzeuge eine Dummy-Struktur, damit die UI nicht komplett bricht, aber markiere es.
                                // `handleBaseSkillTypeInputChange` wird dann wahrscheinlich nicht die richtige Instanz finden.
                                // Dies deutet auf ein Problem in `applyStandardProfessionLogic` hin.
                                currentInstance = {
                                    instanceId: uiElementIdSuffixForInput, // Verwende die generierte ID
                                    typeName: skillInfo.typeNameDefault || "",
                                    key: skillInfo.key
                                };
                                detailsHtml += `<p style="color:orange;">Hinweis: UI für Skill '${skillName}' (${skillInfo.key}) nicht korrekt geladen (Instanz fehlt).</p>`;
                            }

                            detailsHtml += `<div class="profession-choice-group typed-base-skill-group">
                                                <label for="typed_base_${uiElementIdSuffixForInput}">${skillName} (${targetValue}%): </label>
                                                <input type="text" id="typed_base_${uiElementIdSuffixForInput}"
                                                       class="skill-type-input base-skill-type-input"
                                                       data-instance-id="${currentInstance.instanceId}" 
                                                       value="${currentInstance.typeName || ""}"
                                                       placeholder="${t('specify_type_placeholder')}">
                                             </div>`;
                        }
                        // Nicht-typisierte Basis-Skills (z.B. Firearms 50%) erfordern hier keine eigene UI-Interaktion,
                        // da ihr Wert und Typ feststehen und direkt angewendet werden.
                    } else {
                        // Dieser Fall sollte nicht eintreten, wenn PROFESSIONS korrekt strukturiert ist
                        // (d.h., jedes Element in baseSkills hat entweder .orSkills oder .key)
                        console.warn("renderProfessionSpecificChoices: Ungültiges skillInfo-Objekt in baseSkills von Prof:", profData.nameKey, skillInfo);
                    }
                }); // Ende profData.baseSkills.forEach

                // 2. Choice Skills (Checkboxen)
                if (profData.choiceSkills) {
                    detailsHtml += `<div class="profession-choice-group choice-skill-group" style="margin-top:15px;">
                                        <p>${t('choose_N_label', { N: profData.choiceSkills.count })}:</p><ul>`;
                    profData.choiceSkills.options.forEach(choiceOpt => {
                        // Prüfe, ob dieser Choice Skill durch eine "orSkill"-Auswahl blockiert ist
                        if (chosenOrSkillKeys.has(choiceOpt.key)) {
                            // Wenn blockiert, rendere diese Option nicht in der Choice-Liste
                            // Alternativ: Deaktiviert anzeigen, aber das macht die Liste unübersichtlich
                            return; // Nächste choiceOpt
                        }

                        const skillDefChoice = ALL_SKILLS[choiceOpt.key];
                         if (!skillDefChoice) {
                            console.error(`Render ChoiceSkill: Skill-Definition für ${choiceOpt.key} fehlt!`);
                            detailsHtml += `<li><span style="color:red;">Error: Skill '${choiceOpt.key}' def missing</span></li>`;
                            return; // continue forEach
                        }
                        const skillName = t(skillDefChoice.nameKey);
                        const isSelectedAsChoice = !!character.profChoiceSkillSelections[choiceOpt.key];
                        let typeNameValueForChoice = "";

                        if (isSelectedAsChoice && skillDefChoice.type) {
                            const choiceInstance = character.skills.find(s => s.key === choiceOpt.key && s.isChoiceSkill === true);
                            typeNameValueForChoice = choiceInstance?.typeName || "";
                        }

                        detailsHtml += `<li>
                                            <label class="inline-label">
                                                <input type="checkbox" class="prof-choice-skill-cb" 
                                                       data-skill-key="${choiceOpt.key}" 
                                                       data-target-value="${choiceOpt.value}"
                                                       data-is-typed="${skillDefChoice.type ? 'true' : 'false'}"
                                                       ${isSelectedAsChoice ? 'checked' : ''}> 
                                                ${skillName} (${choiceOpt.value}%)
                                            </label>`;
                        if (skillDefChoice.type) {
                            detailsHtml += 
                                `<input type="text" class="skill-type-input choice-skill-type-input" ` +
                                `data-skill-key-for-choice="${choiceOpt.key}" ` +
                                `placeholder="${t('specify_type_placeholder')}" ` +
                                `value="${typeNameValueForChoice}" ` +
                                `style="display:${isSelectedAsChoice ? 'inline-block':'none'}; margin-left: 10px;">`;
                        }
                        detailsHtml += `</li>`;
                    });
                    detailsHtml += `</ul></div>`;
                }

                container.innerHTML = detailsHtml;
                translateAllElements(container); // Übersetzungen für die neu generierten Elemente
                // Beachte: attachProfessionChoiceListenersInternal erwartet jetzt `chosenOrSkillKeys` nicht mehr als direkten Parameter,
                // da die Filterung schon beim Rendern passiert. Die Listener-Funktion muss ggf. auf `character.orSkillChoices` zugreifen,
                // wenn sie die aktuelle "orSkill"-Blockierung für ihre interne Logik braucht (z.B. beim Deaktivieren von Checkboxen).
                // Für den Moment übergeben wir es weiterhin, da es in der letzten Version so war.
                attachProfessionChoiceListenersInternal(profData, chosenOrSkillKeys);
            }
             function attachProfessionChoiceListenersInternal(profData) {
                console.log("attachProfessionChoiceListenersInternal START. character.orSkillChoices:", JSON.parse(JSON.stringify(character.orSkillChoices)));
                // Listener für "orSkill" Radio-Buttons
                document.querySelectorAll('input[type="radio"][name^="orSkill_"]').forEach(radio => {
                    radio.removeEventListener('change', handleOrSkillChange); // Alte entfernen
                    radio.addEventListener('change', handleOrSkillChange);
                });

                // Listener für Typ-Eingabefelder von direkten typisierten Basis-Skills (die kein typeNameDefault hatten)
                document.querySelectorAll('.base-skill-type-input').forEach(input => {
                    input.removeEventListener('input', handleBaseSkillTypeInputChange); // Alte entfernen
                    input.addEventListener('input', handleBaseSkillTypeInputChange);
                });

                document.querySelectorAll('.choice-skill-type-input').forEach(input => {
                    input.removeEventListener('input', handleChoiceSkillTypeInputChange); // Der Input-Handler
                    input.removeEventListener('blur', handleChoiceSkillTypeInputBlur);  // Der NEUE Blur-Handler
                    input.addEventListener('input', handleChoiceSkillTypeInputChange);
                    input.addEventListener('blur', handleChoiceSkillTypeInputBlur);
                });

                // Listener für Checkbox Choice Skills
                document.querySelectorAll('.prof-choice-skill-cb').forEach(checkbox => {
                    checkbox.removeEventListener('change', handleChoiceSkillCbChange); // Alte entfernen
                    checkbox.addEventListener('change', handleChoiceSkillCbChange);
                    // Initialer Zustand (Deaktivierung, Typ-Input Sichtbarkeit)
                    const maxChoices = profData.choiceSkills.count;
                    const checkedCount = document.querySelectorAll('.prof-choice-skill-cb:checked').length;
                    if (!checkbox.checked) {
                        checkbox.disabled = checkedCount >= maxChoices;
                        checkbox.closest('label').classList.toggle('disabled-choice', checkbox.disabled);
                    }
                    if (checkbox.checked && checkbox.dataset.isTyped === 'true') {
                        const typeInput = checkbox.closest('li').querySelector('.choice-skill-type-input');
                        if (typeInput) typeInput.style.display = 'inline-block';
                    }
                });

                // Listener für Typ-Eingabefelder von Choice Skills
                document.querySelectorAll('.choice-skill-type-input').forEach(input => {
                    input.removeEventListener('input', handleChoiceSkillTypeInputChange); // Alte entfernen
                    input.addEventListener('input', handleChoiceSkillTypeInputChange);
                });
            }
            function handleChoiceSkillTypeInputChange(event) {
                const typeInput = event.target;
                const skillKeyForChoice = typeInput.dataset.skillKeyForChoice;
                // const newPartialTypeName = typeInput.value; // Wert während der Eingabe

                // console.log(`ChoiceSkillTypeInputChange (1.2): Key=${skillKeyForChoice}, Current Value='${newPartialTypeName}'`);

                // Momentan keine Datenmanipulation hier. Die Hauptlogik ist im Blur-Handler.
                // updateNavigationButtons(); // Könnte hier aufgerufen werden, wenn Eingabe die Validität beeinflusst
            }
            // --- Event Handler für Profession Specific Choices ---
            function handleOrSkillChange(e) {
                const selectedKey = e.target.value;
                const groupId = e.target.dataset.groupId;
                const targetValue = parseInt(e.target.dataset.targetValue);

                console.log("--- handleOrSkillChange ---");
                console.log("Event Target:", e.target);
                console.log("Selected Key:", selectedKey, "Target Value:", targetValue, "Group ID:", groupId);

                const previousChoiceKey = character.orSkillChoices[groupId];
console.log("handleOrSkillChange START. groupId:", groupId, "character.orSkillChoices for this group:", character.orSkillChoices[groupId], "Full orSkillChoices:", JSON.parse(JSON.stringify(character.orSkillChoices)));
                console.log("Previous Choice Key for group", groupId, ":", previousChoiceKey);

                if (previousChoiceKey && previousChoiceKey !== selectedKey) {
                    // Wichtig: Finde die Instanz, die AKTUELL als professionell für diesen 'previousChoiceKey' gilt.
                    // Ihr typeName ist für nicht-typisierte Skills 'null'.
                    const oldInstance = character.skills.find(s =>
                        s.key === previousChoiceKey &&
                        s.isProfessional === true && // Es MUSS die professionelle Instanz sein
                        (ALL_SKILLS[previousChoiceKey]?.type ? s.typeName === "" : s.typeName === null) && // Generischer Typ oder null
                        !s.isChoiceSkill // Nicht Teil einer anderen Choice-Gruppe
                    );

                    if (oldInstance) {
                        console.log("Found oldInstance to de-prof:", JSON.parse(JSON.stringify(oldInstance)));
                        oldInstance.isProfessional = false;
                        oldInstance.baseValueFromProfession = 0;
                        oldInstance.value = ALL_SKILLS[oldInstance.key].base + ((oldInstance.increases || 0) * SKILL_INCREASE_AMOUNT);
                        console.log("OldInstance after de-prof:", JSON.parse(JSON.stringify(oldInstance)));
                    } else {
                        console.warn(`Could not find old professional OR-instance to de-professionalize for key: ${previousChoiceKey}`);
                    }
                }

                character.orSkillChoices[groupId] = selectedKey;
                const typeOfNewChoice = ALL_SKILLS[selectedKey]?.type ? "" : null;
                const newOrUpdatedInstance = findOrCreateSkillInstance(selectedKey, typeOfNewChoice, true, targetValue);
                
                console.log("New/Updated Prof OR-Instance:", newOrUpdatedInstance ? JSON.parse(JSON.stringify(newOrUpdatedInstance)) : "null");
                // console.log("All skills after or-change:", JSON.parse(JSON.stringify(character.skills)));

                renderAllSkillsList();
                updateNavigationButtons();
            }
            function handleBaseSkillTypeInputChange(e) {
                const instanceIdFromInput = e.target.dataset.instanceId;
                const newTypeName = e.target.value.trim();
                const skillInstance = character.skills.find(s => s.instanceId === instanceIdFromInput);

                console.log(`--- handleBaseSkillTypeInputChange (Step 1.2 Base Prof Skill) ---`);
                console.log(`Input data-instance-id: ${instanceIdFromInput}, New Type: '${newTypeName}'`);

                if (skillInstance && ALL_SKILLS[skillInstance.key].type) {
                    console.log(`   Found instance: ${skillInstance.instanceId} (Key: ${skillInstance.key}, Old Type: '${skillInstance.typeName}')`);
                    if (skillInstance.typeName !== newTypeName) {
                        skillInstance.typeName = newTypeName;
                        console.log(`   Updated instance typeName to '${newTypeName}'.`);
                        // Wichtig: Die Haupt-Skill-Liste (für Schritt 1.3) muss aktualisiert werden,
                        // da sich der Anzeigename (Skill + Typ) geändert haben könnte.
                        renderAllSkillsList();
                    }
                    updateNavigationButtons(); // Validierung könnte vom Typ abhängen
                } else {
                    console.warn("   Instance not found or skill not typed for instanceId from input:", instanceIdFromInput);
                }
            }
            function handleChoiceSkillCbChange(e) {
                const checkbox = e.target;
                const skillKey = checkbox.dataset.skillKey;
                const targetValue = parseInt(checkbox.dataset.targetValue);
                const isTypedSkillFromDefinition = ALL_SKILLS[skillKey]?.type;
                const listItem = checkbox.closest('li');
                const typeInput = listItem ? listItem.querySelector('.choice-skill-type-input') : null;

                const profData = PROFESSIONS[character.professionKey];
                if (!profData || !profData.choiceSkills) {
                    // ... (Fehlerbehandlung)
                    return;
                }
                const maxChoices = profData.choiceSkills.count;

                console.log(`--- handleChoiceSkillCbChange (Checkbox in Step 1.2) ---`);
                console.log(`SkillKey: ${skillKey}, Checkbox DOM state: ${checkbox.checked}`);

                if (checkbox.checked) {
                    // ... (Logik für AUSWÄHLEN - bleibt wie in der Version, die für dich zuletzt funktioniert hat)
                    const numCheckedAfterThisClick = document.querySelectorAll('.prof-choice-skill-cb:checked').length;
                    if (numCheckedAfterThisClick > maxChoices) {
                        checkbox.checked = false;
                        alert(t('alert_max_choices_reached', { N: maxChoices }));
                        console.log(`   Max choices (${maxChoices}) reached. Selection of ${skillKey} reverted.`);
                    } else {
                        character.profChoiceSkillSelections[skillKey] = true;
                        if (typeInput) {
                             typeInput.style.display = 'inline-block';
                             typeInput.value = "";
                        }
                        if (!isTypedSkillFromDefinition) {
                            console.log(`   Non-typed Choice Skill ${skillKey} selected. Calling FOCSI.`);
                            const instance = findOrCreateSkillInstance(skillKey, null, true, targetValue);
                            if (instance) {
                                instance.isChoiceSkill = true;
                                // console.log("   Created/Updated NON-TYPED choice instance:", JSON.parse(JSON.stringify(instance)));
                            }
                        } else {
                            console.log(`   Typed Choice Skill ${skillKey} selected. UI prepared. Type will be finalized on input blur.`);
                        }
                    }

                } else { // SKILL WURDE GERADE ABGEWÄHLT (DOM-Zustand ist jetzt 'not checked')
                    character.profChoiceSkillSelections[skillKey] = false;
                    let originalTypeNameFromUI = "";
                    if (typeInput) {
                        originalTypeNameFromUI = typeInput.value.trim(); // Wert aus dem Input, BEVOR es geleert/versteckt wird
                        typeInput.style.display = 'none';
                        // typeInput.value = ""; // UI-Feld wird geleert, Wert ist schon in originalTypeNameFromUI
                    }
                    console.log(`   Choice Skill ${skillKey} (UI Type war: '${originalTypeNameFromUI}') deselected.`);

                    const typeNameToFind = isTypedSkillFromDefinition ? originalTypeNameFromUI : null;

                    const instanceIndexToDeactivate = character.skills.findIndex(s =>
                        s.key === skillKey &&
                        s.isChoiceSkill === true &&
                        s.typeName === typeNameToFind
                    );

                    if (instanceIndexToDeactivate !== -1) {
                        const instanceToHandle = character.skills[instanceIndexToDeactivate];
                        const increasesToReturn = instanceToHandle.increases || 0;

                        console.log(`   Handling deselection of Choice Skill instance: ${instanceToHandle.instanceId} (Key: ${instanceToHandle.key}, Type: '${instanceToHandle.typeName}', Current Increases: ${increasesToReturn})`);

                        const skillDef = ALL_SKILLS[skillKey];

                        // Bedingung für das Entfernen der Instanz:
                        // Es ist ein per Definition typisierter Skill UND die Instanz hatte einen spezifischen Typ.
                        if (skillDef.type && instanceToHandle.typeName && instanceToHandle.typeName.trim() !== "") {
                            console.log(`       Specific TYPED instance ${instanceToHandle.instanceId} will be REMOVED.`);
                            character.skills.splice(instanceIndexToDeactivate, 1); // Instanz entfernen

                            if (increasesToReturn > 0) {
                                console.log(`       ${increasesToReturn} boost(s) were on this removed instance. These are now effectively available again.`);
                                // Die Boosts sind "zurückgegeben", da die Instanz weg ist.
                                // Die Zählung `totalIncreasesGlobal` in `renderAllSkillsList` wird automatisch niedriger sein.
                                // Es ist keine explizite Aktion nötig, um sie einem "Pool" hinzuzufügen,
                                // da der Pool durch `MAX_SKILL_INCREASES - totalIncreasesGlobal` definiert ist.
                            }
                        } else {
                            // Nicht-typisierter Choice Skill ODER ein typisierter, der aus irgendeinem Grund
                            // keinen spezifischen Typ hatte (sollte bei korrekter Blur-Logik nicht oft vorkommen).
                            // In diesem Fall wird die Instanz nur deaktiviert, aber BEHÄLT ihre Boosts.
                            console.log(`       Instance ${instanceToHandle.instanceId} is non-typed or had no specific type. Deactivating, Boosts (${increasesToReturn}) remain.`);
                            instanceToHandle.isChoiceSkill = false;
                            instanceToHandle.isProfessional = false;
                            instanceToHandle.baseValueFromProfession = 0;
                            instanceToHandle.value = skillDef.base + (increasesToReturn * SKILL_INCREASE_AMOUNT);
                            instanceToHandle.value = Math.max(0, Math.min(99, instanceToHandle.value));
                        }
                    } else {
                        console.log(`   No specific active choice instance found to deactivate for key ${skillKey} and UI type '${originalTypeNameFromUI}'.`);
                        if (typeInput) typeInput.style.display = 'none';
                    }
                }

                // Deaktivierungslogik für ALLE Checkboxen
                const finalNumCheckedInDom = document.querySelectorAll('.prof-choice-skill-cb:checked').length;
                document.querySelectorAll('.prof-choice-skill-cb').forEach(cb => {
                    if (!cb.checked) {
                        cb.disabled = finalNumCheckedInDom >= maxChoices;
                        cb.closest('label').classList.toggle('disabled-choice', cb.disabled);
                    } else {
                        cb.disabled = false;
                        cb.closest('label').classList.remove('disabled-choice');
                    }
                });

                renderAllSkillsList();
                updateNavigationButtons();
            }

            function handleChoiceSkillTypeInputBlur(event) { // Handler für Typ-Input-Blur bei Choice Skills in 1.2
                const typeInput = event.target;
                const skillKey = typeInput.dataset.skillKeyForChoice;
                const listItem = typeInput.closest('li');
                if (!listItem) return;
                const checkbox = listItem.querySelector('.prof-choice-skill-cb');

                // Nur handeln, wenn die Checkbox aktiv ist und der Skill typisiert ist
                if (!checkbox || !checkbox.checked || !ALL_SKILLS[skillKey]?.type) {
                    // Wenn Checkbox nicht aktiv, aber Text im Feld war, könnte man ihn hier löschen
                    // if (typeInput.value.trim() !== "") typeInput.value = "";
                    updateNavigationButtons(); // Validierung könnte sich ändern
                    return;
                }

                const newFinalTypeName = typeInput.value.trim(); // Der endgültige Typname aus dem Input
                const choiceOptDef = PROFESSIONS[character.professionKey]?.choiceSkills.options.find(opt => opt.key === skillKey);
                if (!choiceOptDef) {
                    console.error("handleChoiceSkillTypeInputBlur: Choice option definition not found for key:", skillKey);
                    return;
                }
                const targetValue = choiceOptDef.value; // Zielwert für den Choice Skill

                console.log(`--- handleChoiceSkillTypeInputBlur (Step 1.2 Choice Type) ---`);
                console.log(`SkillKey: ${skillKey}, New Final TypeName: '${newFinalTypeName}', TargetValue: ${targetValue}`);

                // --- Kernlogik: Alte Choice-Instanz behandeln, neue erstellen/aktivieren ---

                let instanceToDeactivate = null;
                let instanceToActivateOrKeep = null;

                // 1. Gab es eine vorherige aktive Choice-Instanz für diesen skillKey?
                //    Diese könnte einen anderen Typ gehabt haben oder die generische ("") gewesen sein.
                const previousActiveChoiceInstances = character.skills.filter(s =>
                    s.key === skillKey && s.isChoiceSkill
                );

                if (previousActiveChoiceInstances.length > 1) {
                    console.warn(`   WARNUNG: Mehr als eine Instanz für ${skillKey} war als isChoiceSkill markiert. Korrigiere dies.`);
                    // Bereinige: Behalte nur die, die dem (alten) Typ-Input-Wert am ehesten entsprach,
                    // oder die erste gefundene, und deaktiviere die anderen. Dies ist ein Fallback.
                    // Idealerweise sollte dies nie passieren.
                     previousActiveChoiceInstances.forEach((inst, index) => {
                        if (index > 0) { // Deaktiviere alle außer der ersten (willkürliche Wahl zur Korrektur)
                            inst.isChoiceSkill = false;
                            inst.isProfessional = false;
                            inst.baseValueFromProfession = 0;
                            inst.value = ALL_SKILLS[skillKey].base + ((inst.increases || 0) * SKILL_INCREASE_AMOUNT);
                        }
                    });
                    instanceToDeactivate = previousActiveChoiceInstances.length > 0 ? previousActiveChoiceInstances[0] : null;
                } else if (previousActiveChoiceInstances.length === 1) {
                    instanceToDeactivate = previousActiveChoiceInstances[0];
                }


                // 2. Fallunterscheidung basierend auf dem neuen Typnamen
                if (newFinalTypeName === "") {
                    // Der Typ wurde explizit geleert.
                    console.log(`   Typ für Choice Skill ${skillKey} wurde geleert.`);
                    if (instanceToDeactivate) {
                        console.log(`   Deaktiviere bisherige Choice-Instanz: ${instanceToDeactivate.instanceId} (Type: '${instanceToDeactivate.typeName}', Increases: ${instanceToDeactivate.increases || 0})`);
                        instanceToDeactivate.isChoiceSkill = false;
                        instanceToDeactivate.isProfessional = false;
                        instanceToDeactivate.baseValueFromProfession = 0;
                        instanceToDeactivate.value = ALL_SKILLS[skillKey].base + ((instanceToDeactivate.increases || 0) * SKILL_INCREASE_AMOUNT);

                        // Wenn es eine spezifische Instanz ohne Boosts war, entfernen.
                        if (ALL_SKILLS[skillKey].type && instanceToDeactivate.typeName !== "" && (instanceToDeactivate.increases || 0) === 0) {
                            console.log(`       Entferne spezifische Instanz ${instanceToDeactivate.instanceId}, da Typ geleert und keine Boosts.`);
                            character.skills = character.skills.filter(s => s.instanceId !== instanceToDeactivate.instanceId);
                        }
                    }
                    // Keine neue Instanz wird als Choice aktiviert.
                } else {
                    // Ein spezifischer Typ wurde eingegeben (oder beibehalten).
                    console.log(`   Spezifischer Typ '${newFinalTypeName}' für Choice Skill ${skillKey} angegeben.`);

                    if (instanceToDeactivate && instanceToDeactivate.typeName !== newFinalTypeName) {
                        // Der Typ hat sich geändert. Die alte Instanz (instanceToDeactivate) verliert ihren Choice-Status.
                        console.log(`   Typ hat sich geändert. Deaktiviere alte Choice-Instanz: ${instanceToDeactivate.instanceId} (Old Type: '${instanceToDeactivate.typeName}')`);
                        instanceToDeactivate.isChoiceSkill = false;
                        instanceToDeactivate.isProfessional = false;
                        instanceToDeactivate.baseValueFromProfession = 0;
                        instanceToDeactivate.value = ALL_SKILLS[skillKey].base + ((instanceToDeactivate.increases || 0) * SKILL_INCREASE_AMOUNT);

                        // Wenn die *alte* eine spezifische Instanz ohne Boosts war, entfernen.
                        if (ALL_SKILLS[skillKey].type && instanceToDeactivate.typeName !== "" && (instanceToDeactivate.increases || 0) === 0) {
                            console.log(`       Entferne alte spezifische Instanz ${instanceToDeactivate.instanceId}, da Typ geändert und keine Boosts.`);
                            character.skills = character.skills.filter(s => s.instanceId !== instanceToDeactivate.instanceId);
                        }
                        instanceToDeactivate = null; // Alte ist jetzt behandelt und nicht mehr die "aktive" Choice.
                    } else if (instanceToDeactivate && instanceToDeactivate.typeName === newFinalTypeName) {
                        // Typ ist gleich geblieben, die bestehende Instanz bleibt die aktive Choice-Instanz.
                        console.log(`   Typ ist gleich geblieben. Bestehende Choice-Instanz ${instanceToDeactivate.instanceId} bleibt aktiv.`);
                        instanceToActivateOrKeep = instanceToDeactivate;
                        // Sicherstellen, dass Professionalität und Wert korrekt sind (sollte aber schon passen)
                        instanceToActivateOrKeep.isProfessional = true;
                        instanceToActivateOrKeep.baseValueFromProfession = Math.max(0, targetValue - ALL_SKILLS[skillKey].base);
                        instanceToActivateOrKeep.value = ALL_SKILLS[skillKey].base + instanceToActivateOrKeep.baseValueFromProfession + ((instanceToActivateOrKeep.increases || 0) * SKILL_INCREASE_AMOUNT);
                    }

                    // Jetzt die neue/aktuelle Instanz für newFinalTypeName finden oder erstellen und als Choice aktivieren.
                    // `findOrCreateSkillInstance` sollte hier eine spezifische Instanz für `newFinalTypeName` liefern.
                    // Wenn bereits eine Instanz mit diesem Typ existiert (vielleicht von einer früheren Auswahl oder als generischer Skill, der jetzt diesen Typ bekommt), wird diese verwendet.
                    if (!instanceToActivateOrKeep) { // Nur wenn nicht schon durch "Typ ist gleich geblieben" gesetzt
                        console.log(`   Suche/Erstelle Instanz für neuen Choice-Typ '${newFinalTypeName}'.`);
                        instanceToActivateOrKeep = findOrCreateSkillInstance(skillKey, newFinalTypeName, true, targetValue);
                    }

                    if (instanceToActivateOrKeep) {
                        instanceToActivateOrKeep.isChoiceSkill = true; // Setze/bestätige Choice-Status
                        // Professionalität und Wert wurden bereits in findOrCreateSkillInstance oder oben gesetzt.
                        console.log(`   Aktive Choice-Instanz (neu oder aktualisiert): ${instanceToActivateOrKeep.instanceId} (Type: '${instanceToActivateOrKeep.typeName}', Value: ${instanceToActivateOrKeep.value})`);
                    } else {
                        console.error(`   Konnte keine Instanz für Choice Skill ${skillKey} mit Typ '${newFinalTypeName}' finden oder erstellen.`);
                    }
                }

                renderAllSkillsList();
                updateNavigationButtons();
            }


            // Dein neuer handleChoiceSkillTypeInputBlur Handler (wie zuvor besprochen)
            function handleChoiceSkillTypeInputBlur(event) { // Handler für Typ-Input-Blur bei Choice Skills in 1.2
                const typeInput = event.target;
                const skillKey = typeInput.dataset.skillKeyForChoice;
                const listItem = typeInput.closest('li');
                if (!listItem) return;
                const checkbox = listItem.querySelector('.prof-choice-skill-cb');

                if (!checkbox || !checkbox.checked || !ALL_SKILLS[skillKey]?.type) {
                    updateNavigationButtons();
                    return;
                }

                const newFinalTypeName = typeInput.value.trim();
                const choiceOptDef = PROFESSIONS[character.professionKey]?.choiceSkills.options.find(opt => opt.key === skillKey);
                if (!choiceOptDef) return;
                const targetValueForProfession = choiceOptDef.value; // Dies ist der Wert, den der Skill durch die Berufswahl bekommt

                console.log(`--- handleChoiceSkillTypeInputBlur (Step 1.2 Choice Type) ---`);
                console.log(`INPUT: skillKey=${skillKey}, newFinalTypeName='${newFinalTypeName}', targetValueForProf=${targetValueForProfession}`);
                const skillsBefore = JSON.parse(JSON.stringify(character.skills.filter(s => s.key === skillKey)));
                console.log("character.skills VORHER (gefiltert für " + skillKey + "):", skillsBefore);

                // Finde die Instanz, die aktuell diesen Choice Skill repräsentiert.
                // Es sollte nur eine geben. Wenn mehrere, ist das ein Fehlerzustand.
                let activeChoiceInstance = null;
                const currentChoiceInstances = character.skills.filter(s => s.key === skillKey && s.isChoiceSkill);

                if (currentChoiceInstances.length > 1) {
                    console.warn(`WARNUNG: Mehr als eine Instanz für ${skillKey} war als isChoiceSkill markiert! Nehme die erste.`, currentChoiceInstances);
                    activeChoiceInstance = currentChoiceInstances[0]; // Willkürliche Wahl zur Korrektur
                    // Bereinige die anderen
                    for (let i = 1; i < currentChoiceInstances.length; i++) {
                        currentChoiceInstances[i].isChoiceSkill = false;
                        currentChoiceInstances[i].isProfessional = false;
                        currentChoiceInstances[i].baseValueFromProfession = 0;
                        // Wert zurücksetzen
                    }
                } else if (currentChoiceInstances.length === 1) {
                    activeChoiceInstance = currentChoiceInstances[0];
                }

                // Was passiert, wenn es keine `activeChoiceInstance` gab, aber die Checkbox gecheckt ist
                // und jetzt ein Typ eingegeben wird? Das FOCSI unten wird eine erstellen.

                if (newFinalTypeName === "") {
                    // Typ wurde explizit geleert.
                    console.log(`   Typ für Choice Skill ${skillKey} wurde geleert.`);
                    if (activeChoiceInstance) {
                        console.log(`   Deaktiviere bisherige Choice-Instanz: ${activeChoiceInstance.instanceId} (Type: '${activeChoiceInstance.typeName}', Increases: ${activeChoiceInstance.increases || 0})`);
                        activeChoiceInstance.isChoiceSkill = false;
                        activeChoiceInstance.isProfessional = false;
                        activeChoiceInstance.baseValueFromProfession = 0;
                        activeChoiceInstance.value = ALL_SKILLS[skillKey].base + ((activeChoiceInstance.increases || 0) * SKILL_INCREASE_AMOUNT);
                        // Die Instanz (mit ihrem alten Typ und Boosts) bleibt bestehen, ist aber nicht mehr Choice.
                        // Sie wird nicht entfernt, auch wenn sie spezifisch war, da sie Boosts haben könnte oder der User den Typ später wieder füllt.
                    }
                } else {
                    // Ein spezifischer Typ wurde eingegeben/beibehalten.
                    if (activeChoiceInstance) {
                        // Es gab bereits eine aktive Choice-Instanz.
                        if (activeChoiceInstance.typeName !== newFinalTypeName) {
                            // Der Typ hat sich geändert! Wir modifizieren die bestehende aktive Choice-Instanz.
                            console.log(`   Typ der aktiven Choice-Instanz ${activeChoiceInstance.instanceId} wird von '${activeChoiceInstance.typeName}' zu '${newFinalTypeName}' geändert. Boosts (${activeChoiceInstance.increases || 0}) bleiben.`);
                            activeChoiceInstance.typeName = newFinalTypeName;
                            // Die Professional-Werte müssen ggf. angepasst werden, falls der baseValueFromProfession sich ändert (sollte bei Choice Skills nicht der Fall sein, aber sicherheitshalber)
                            activeChoiceInstance.isProfessional = true;
                            activeChoiceInstance.baseValueFromProfession = Math.max(0, targetValueForProfession - ALL_SKILLS[skillKey].base);
                            activeChoiceInstance.value = ALL_SKILLS[skillKey].base + activeChoiceInstance.baseValueFromProfession + ((activeChoiceInstance.increases || 0) * SKILL_INCREASE_AMOUNT);
                            console.log(`   Aktualisierte Instanz:`, JSON.parse(JSON.stringify(activeChoiceInstance)));
                        } else {
                            // Typ ist gleich geblieben. Nichts zu tun mit der Instanz selbst, sie war schon korrekt.
                            console.log(`   Typ ist gleich geblieben. Bestehende Choice-Instanz ${activeChoiceInstance.instanceId} bleibt aktiv.`);
                        }
                    } else {
                        // Es gab KEINE vorherige aktive Choice-Instanz für diesen skillKey (oder sie wurde gerade durch Typ-Leerung deaktiviert).
                        // Erstelle/finde jetzt eine Instanz für den newFinalTypeName und mache sie zum Choice Skill.
                        console.log(`   Keine vorherige aktive Choice-Instanz. Suche/Erstelle Instanz für neuen Choice-Typ '${newFinalTypeName}'.`);
                        const instanceForNewChoice = findOrCreateSkillInstance(skillKey, newFinalTypeName, true, targetValueForProfession);
                        if (instanceForNewChoice) {
                            instanceForNewChoice.isChoiceSkill = true;
                            // Professionalität und Wert wurden in FOCSI gesetzt.
                            console.log(`   Neue aktive Choice-Instanz: ${instanceForNewChoice.instanceId} (Type: '${instanceForNewChoice.typeName}', Value: ${instanceForNewChoice.value}, Increases: ${instanceForNewChoice.increases || 0})`);
                        } else {
                            console.error(`   Konnte keine Instanz für Choice Skill ${skillKey} mit Typ '${newFinalTypeName}' finden oder erstellen.`);
                        }
                    }
                }

                // Sicherheitsnetz: Stelle sicher, dass für diesen skillKey nur EINE Instanz isChoiceSkill ist.
                // Bevorzuge die Instanz mit dem `newFinalTypeName`, falls vorhanden und nicht leer.
                // Sonst keine.
                let finalChoiceMade = false;
                character.skills.forEach(instance => {
                    if (instance.key === skillKey) {
                        if (newFinalTypeName !== "" && instance.typeName === newFinalTypeName && !finalChoiceMade) {
                            if (!instance.isChoiceSkill) { // Nur wenn sie es nicht schon war
                                console.log(`   KORREKTUR (Sicherheitsnetz): Setze ${instance.instanceId} (Typ '${instance.typeName}') zu isChoiceSkill=true`);
                                instance.isChoiceSkill = true;
                                instance.isProfessional = true; // Sicherstellen
                                instance.baseValueFromProfession = Math.max(0, targetValueForProfession - ALL_SKILLS[skillKey].base);
                                instance.value = ALL_SKILLS[skillKey].base + instance.baseValueFromProfession + ((instance.increases || 0) * SKILL_INCREASE_AMOUNT);
                            }
                            finalChoiceMade = true;
                        } else {
                            if (instance.isChoiceSkill) { // Wenn eine andere Instanz noch Choice ist
                                console.log(`   KORREKTUR (Sicherheitsnetz): Deaktiviere redundante Choice-Instanz ${instance.instanceId} (Typ '${instance.typeName}')`);
                                instance.isChoiceSkill = false;
                                instance.isProfessional = false;
                                instance.baseValueFromProfession = 0;
                                instance.value = ALL_SKILLS[skillKey].base + ((instance.increases || 0) * SKILL_INCREASE_AMOUNT);
                            }
                        }
                    }
                });


                const skillsAfter = JSON.parse(JSON.stringify(character.skills.filter(s => s.key === skillKey)));
                console.log("character.skills NACHHER (gefiltert für " + skillKey + "):", skillsAfter);

                if (JSON.stringify(skillsBefore) === JSON.stringify(skillsAfter) && typeInput.value.trim() === skillsBefore.find(s=>s.isChoiceSkill)?.typeName) {
                    console.log("Keine relevanten Datenänderungen, renderAllSkillsList ggf. nicht nötig.");
                } else {
                    renderAllSkillsList();
                }
                updateNavigationButtons();
            }
            function renderAllSkillsList() {
                const listContainer = document.getElementById('all-skills-list-container');
                if (!listContainer) {
                    console.warn("#all-skills-list-container nicht im DOM gefunden in renderAllSkillsList!");
                    return;
                }
                listContainer.innerHTML = ''; // Leeren für Neuaufbau

                character.skillBoostsUsed = character.skillBoostsUsed || 0;
                // character.remainingBoostPool wird NICHT MEHR BENÖTIGT

                const increasesChosenEl = document.getElementById('increases-chosen-count');
                if (increasesChosenEl) { // Zeige mit einer Nachkommastelle, falls .5
                    increasesChosenEl.textContent = character.skillBoostsUsed.toFixed(character.skillBoostsUsed % 1 !== 0 ? 1 : 0);
                }
                
                // Entferne die Anzeige für den alten remainingBoostPool, falls noch vorhanden
                // Da wir es nicht mehr brauchen, können wir den Code dafür einfach entfernen.
                // const oldPoolDisplay = document.getElementById('skill-boost-pool-container');
                // if (oldPoolDisplay) oldPoolDisplay.style.display = 'none';


                // Filterung und Sortierung der anzuzeigenden Skills
                const instancesToDisplayInStep13 = character.skills.filter(skillInstance => {
                    const skillDef = ALL_SKILLS[skillInstance.key];
                    if (!skillDef) return false;
                    if (skillInstance.key === "unnatural") {
                        return skillInstance.isProfessional || (skillInstance.increases || 0) > 0 || skillInstance.value > skillDef.base;
                    }
                    // Slot-Skills, deren Typ in 1.2 nicht gesetzt wurde, hier NICHT anzeigen
                    if (skillInstance.slotId && skillInstance.isProfessional && (skillInstance.typeName === "" || skillInstance.typeName === null)) {
                        return false;
                    }
                    return true;
                }).sort((a, b) => {
                    const skillDefA = ALL_SKILLS[a.key];
                    const skillDefB = ALL_SKILLS[b.key];
                    // Bevorzuge Prof/Choice Skills bei gleichem Key für konsistente Auswahl
                    if (a.key === b.key) {
                        const aIsSpecial = a.isProfessional || a.isChoiceSkill;
                        const bIsSpecial = b.isProfessional || b.isChoiceSkill;
                        if (aIsSpecial && !bIsSpecial) return -1;
                        if (!aIsSpecial && bIsSpecial) return 1;
                        if ((a.increases || 0) > (b.increases || 0)) return -1; // Dann die mit mehr Increases
                        if ((a.increases || 0) < (b.increases || 0)) return 1;
                    }
                    // Alphabetische Sortierung als Fallback oder für unterschiedliche Keys
                    const nameA = t(skillDefA.nameKey) + (skillDefA.type && a.typeName && a.typeName.trim() !== "" ? ` (${a.typeName.trim()})` : (skillDefA.type ? ' (...)' : ''));
                    const nameB = t(skillDefB.nameKey) + (skillDefB.type && b.typeName && b.typeName.trim() !== "" ? ` (${b.typeName.trim()})` : (skillDefB.type ? ' (...)' : ''));
                    return nameA.localeCompare(nameB, currentLanguage);
                });

                if (instancesToDisplayInStep13.length === 0 && character.professionKey) {
                    listContainer.innerHTML = `<p><em>${t('step1_3_no_skills_available_or_types_needed')}</em></p>`;
                } else if (instancesToDisplayInStep13.length === 0 && !character.professionKey) {
                    listContainer.innerHTML = `<p><em>${t('alert_select_profession')}</em></p>`;
                }

                const editableTypedSkillShownForKey = new Set(); // Verhindert doppelte leere, editierbare Felder pro Key

                instancesToDisplayInStep13.forEach(skillInstanceToRender => {
                    const skillDef = ALL_SKILLS[skillInstanceToRender.key];
                    // Wenn für diesen Basis-Key schon eine editierbare, leere Zeile gezeigt wurde,
                    // und diese Instanz auch so eine wäre, überspringe sie.
                    // Dies betrifft primär den Fall, wo eine Prof-Instanz (Typ geleert) und eine generische Instanz
                    // desselben Keys beide typ-leer und editierbar wären. Die Sortierung oben sollte die Prof-Instanz bevorzugen.
                    if ((skillInstanceToRender.typeName === "" || skillInstanceToRender.typeName === null) &&
                        !skillInstanceToRender.isProfessional && !skillInstanceToRender.isChoiceSkill && (skillInstanceToRender.increases || 0) === 0 &&
                        skillDef.type && skillInstanceToRender.key !== "unnatural" &&
                        editableTypedSkillShownForKey.has(skillInstanceToRender.key)) {
                        // console.log(`renderAllSkillsList: Überspringe redundante generische leere editierbare Zeile für ${skillInstanceToRender.key}`);
                        return; // continue forEach
                    }

                    const item = document.createElement('div');
                    item.classList.add('skill-list-item');
                    item.setAttribute('data-instance-id', skillInstanceToRender.instanceId);

                    let skillNameDisplaySpan = `<span class="skill-name">${t(skillDef.nameKey)}</span>`;
                    let typeDisplayOrInputHtml = "";
                    let isTypeEditableInStep13 = false;

                    if (skillDef.type && skillInstanceToRender.key !== "unnatural") {
                        // Typ ist in 1.3 editierbar, wenn:
                        // 1. Generische Instanz (nicht Prof/Choice, keine Increases, Basiswert)
                        // ODER
                        // 2. Prof/Choice-Instanz, deren Typ aktuell leer ist (und kein Slot-Skill, dessen Typ in 1.2 festzulegen war)
                        if (!skillInstanceToRender.isProfessional && !skillInstanceToRender.isChoiceSkill &&
                            (skillInstanceToRender.increases || 0) === 0 && skillInstanceToRender.value === skillDef.base) {
                            isTypeEditableInStep13 = true;
                        } else if ((skillInstanceToRender.isProfessional || skillInstanceToRender.isChoiceSkill) &&
                                   (skillInstanceToRender.typeName === "" || skillInstanceToRender.typeName === null) &&
                                   !skillInstanceToRender.slotId) { // Slot-Typen werden nur in 1.2 editiert
                            isTypeEditableInStep13 = true;
                        }
                    }

                    if (isTypeEditableInStep13) {
                        typeDisplayOrInputHtml = ` <input type="text" class="skill-type-input-inline" data-instance-id="${skillInstanceToRender.instanceId}" value="${skillInstanceToRender.typeName || ""}" placeholder="${t('specify_type_placeholder')}" style="width: 150px; margin-left: 8px; font-size: 0.9em; padding: 3px 5px; border: 1px solid #ccc; border-radius: 2px;">`;
                        if (skillInstanceToRender.typeName === "" || skillInstanceToRender.typeName === null) {
                            editableTypedSkillShownForKey.add(skillInstanceToRender.key); // Merken, dass wir eine leere editierbare gezeigt haben
                        }
                    } else if (skillDef.type) {
                        if (skillInstanceToRender.typeName && skillInstanceToRender.typeName.trim() !== "") {
                            typeDisplayOrInputHtml = ` <span class="skill-type-display">(${skillInstanceToRender.typeName.trim()})</span>`;
                        } else { // Typisiert, aber Typ ist leer und nicht editierbar (z.B. Unnatural, oder Slot der in 1.2 leer blieb)
                            typeDisplayOrInputHtml = ` <span class="skill-type-display" style="color: #888;">(${t('specify_type_placeholder')})</span>`;
                        }
                    }

                    const professionalMarkerSpan = skillInstanceToRender.isProfessional ? `<em class="prof-marker" style="font-size:0.8em; color:#28a745; margin-left: 5px;">(Prof.)</em>` : '';
                    const infoIconSpan = `<span class="skill-info-icon" title="${t(skillDef.descKey)}">i<span class="tooltip">${t(skillDef.descKey)}</span></span>`;
                    const currentSkillValue = skillInstanceToRender.value || 0;
                    const currentFullIncreasesCount = skillInstanceToRender.increases || 0;

                    // --- Plus-Button Logik ---
                    let plusButtonText = "+0%";
                    let pointsToAddOnClick = 0;
                    let costForThisBoost = 0; // WICHTIG: Wird hier korrekt bestimmt
                    let plusButtonDisabled = true;
                    const typeIsOkForBoost = !skillDef.type || (skillInstanceToRender.typeName && skillInstanceToRender.typeName.trim() !== "");

                    if (skillInstanceToRender.key !== "unnatural" && typeIsOkForBoost && currentSkillValue < MAX_SKILL_VALUE) {
                        const remainingBoostSlots = parseFloat((MAX_SKILL_INCREASES - character.skillBoostsUsed).toFixed(1)); // Mit toFixed für Präzision

                        // Option 1: Ein voller +20% Boost ist möglich
                        if (remainingBoostSlots >= 1.0 && (currentSkillValue + SKILL_INCREASE_AMOUNT) <= MAX_SKILL_VALUE) {
                            pointsToAddOnClick = SKILL_INCREASE_AMOUNT;
                            plusButtonText = `+${SKILL_INCREASE_AMOUNT}%`;
                            costForThisBoost = 1.0;
                            plusButtonDisabled = false;
                        }
                        // Option 2: Kein voller Boost mehr möglich/nötig, aber mind. ein halber Slot übrig
                        else if (remainingBoostSlots >= 0.5) {
                            // Wie viele Punkte passen maximal in den Skill (bis 80%) ODER sind maximal 10 (halber Boost)?
                            let maxPossiblePointsForThisClick = Math.min(MAX_SKILL_VALUE - currentSkillValue, SKILL_INCREASE_AMOUNT / 2);
                            
                            if (maxPossiblePointsForThisClick > 0) {
                                pointsToAddOnClick = maxPossiblePointsForThisClick;
                                plusButtonText = `+${pointsToAddOnClick}%`;
                                costForThisBoost = 0.5; // Ein Teil-Boost oder das Auffüllen kostet immer 0.5 Slots
                                plusButtonDisabled = false;
                            } else {
                                // Passt nichts mehr rein, auch kein Teil-Boost
                                plusButtonDisabled = true;
                            }
                        }
                        // Wenn weniger als 0.5 Slots übrig sind, bleibt der Button deaktiviert (Standard)
                    }

                    // --- Minus-Button Logik mit halben Boosts ---
                    let minusButtonText = "-0%";
                    let pointsToDecreaseOnClick = 0;
                    let boostValueToReturn = 0; // Wieviel von den 8.0 Boosts zurückgegeben wird (1.0 oder 0.5)
                    let minusButtonDisabled = true;
                    const naturalSkillValue = skillDef.base + (skillInstanceToRender.baseValueFromProfession || 0);

                    if (currentSkillValue > naturalSkillValue && character.skillBoostsUsed > 0) {
                        // Kann ein voller +20% Boost (1.0 Slot) zurückgenommen werden?
                        // Bedingung: Skill hat mind. einen vollen Increase UND es gibt mind. 1.0 Boost-Slot zum Zurückgeben
                        if (currentFullIncreasesCount > 0 && (currentSkillValue - SKILL_INCREASE_AMOUNT) >= naturalSkillValue && character.skillBoostsUsed >= 1.0) {
                            pointsToDecreaseOnClick = SKILL_INCREASE_AMOUNT;
                            minusButtonText = `-${SKILL_INCREASE_AMOUNT}%`;
                            boostValueToReturn = 1.0;
                            minusButtonDisabled = false;
                        }
                        // Kann ein Teil-Boost (0.5 Slot) zurückgenommen werden?
                        // Bedingung: Skill ist um mind. X Punkte über natural UND es gibt mind. 0.5 Boost-Slot zum Zurückgeben
                        else if (character.skillBoostsUsed >= 0.5) {
                            // Versuche, 10 Punkte oder den Rest bis zum naturalValue zu entfernen
                            let potentialDecrease = Math.min(currentSkillValue - naturalSkillValue, SKILL_INCREASE_AMOUNT / 2);
                            if (potentialDecrease > 0) {
                                pointsToDecreaseOnClick = potentialDecrease;
                                minusButtonText = `-${pointsToDecreaseOnClick}%`;
                                boostValueToReturn = 0.5;
                                minusButtonDisabled = false;
                            }
                        }
                    }
                    if (pointsToDecreaseOnClick <= 0) minusButtonDisabled = true; // Sicherstellen


                    let increaseCountText = "";
                    if (currentFullIncreasesCount > 0) {
                        increaseCountText = `(${currentFullIncreasesCount}x +${SKILL_INCREASE_AMOUNT}%)`;
                    }
                    // Wenn du den Wertzuwachs durch Teil-Boosts auch anzeigen willst, wird es komplexer:
                    const valueFromFullIncreasesOnly = naturalSkillValue + (currentFullIncreasesCount * SKILL_INCREASE_AMOUNT);
                    if (currentSkillValue > valueFromFullIncreasesOnly) {
                        increaseCountText += (increaseCountText ? " " : "") + `+${currentSkillValue - valueFromFullIncreasesOnly}%`;
                    }


                    item.innerHTML = `
                        <div class="skill-name-container">
                            ${skillNameDisplaySpan}
                            ${typeDisplayOrInputHtml}
                            ${professionalMarkerSpan}
                            ${infoIconSpan}
                        </div>
                        <div class="skill-value-controls">
                            <span class="skill-value">${currentSkillValue}%</span>
                            <span class="skill-increase-count">${increaseCountText}</span>
                            <button class="skill-decrease-button" 
                                    data-instance-id="${skillInstanceToRender.instanceId}" 
                                    data-points-to-decrease="${pointsToDecreaseOnClick}"
                                    data-boost-value-to-return="${boostValueToReturn}" 
                                    ${minusButtonDisabled ? 'disabled' : ''}>${minusButtonText}</button>
                            <button class="skill-increase-button" 
                                    data-instance-id="${skillInstanceToRender.instanceId}" 
                                    data-points-to-add="${pointsToAddOnClick}" 
                                    data-cost-for-boost="${costForThisBoost}" 
                                    ${plusButtonDisabled ? 'disabled' : ''}>${plusButtonText}</button>
                        </div>
                    `;
                    listContainer.appendChild(item);
                });

                // Event Listener neu binden
                document.querySelectorAll('.skill-increase-button').forEach(button => {
                    button.removeEventListener('click', handleSkillIncreaseClick);
                    button.addEventListener('click', handleSkillIncreaseClick);
                });
                document.querySelectorAll('.skill-decrease-button').forEach(button => {
                    button.removeEventListener('click', handleSkillDecreaseClick);
                    button.addEventListener('click', handleSkillDecreaseClick);
                });
                document.querySelectorAll('.skill-type-input-inline').forEach(input => {
                    input.removeEventListener('input', handleInlineTypeInputChange);
                    input.removeEventListener('blur', handleInlineTypeInputBlurIfDefined);
                    input.addEventListener('input', handleInlineTypeInputChange);
                    input.addEventListener('blur', handleInlineTypeInputBlurIfDefined);
                });

                translateAllElements(listContainer);
            }

            // Vollständige handleSkillIncreaseClick mit Restpunkte-Logik
            function handleSkillIncreaseClick(event) {
                const instanceId = event.target.dataset.instanceId;
                const pointsToAdd = parseInt(event.target.dataset.pointsToAdd);
                const costForThisBoost = parseFloat(event.target.dataset.costForBoost); // Kann 1.0 oder 0.5 sein
                const skillInstance = character.skills.find(s => s.instanceId === instanceId);

                if (!skillInstance || pointsToAdd <= 0 || costForThisBoost <= 0) {
                    // console.warn("IncreaseClick: Ungültige Instanz, Punkte oder Kosten.");
                    renderAllSkillsList(); return;
                }

                const skillDef = ALL_SKILLS[skillInstance.key];
                if (skillDef.type && (!skillInstance.typeName || skillInstance.typeName.trim() === "")) {
                    alert(t('alert_type_for_skill_needed', { skillName: t(skillDef.nameKey) }));
                    return;
                }
                if (skillInstance.key === "unnatural") return;
                if (skillInstance.value >= MAX_SKILL_VALUE) { renderAllSkillsList(); return; }

                if ((character.skillBoostsUsed + costForThisBoost) > MAX_SKILL_INCREASES + 0.01) { // +0.01 für Fließkomma-Toleranz
                    alert(t('alert_skill_increase_limit'));
                    renderAllSkillsList(); return;
                }

                // `pointsToAdd` ist bereits der gekappte Wert aus renderAllSkillsList
                const actualPointsApplied = Math.min(pointsToAdd, MAX_SKILL_VALUE - skillInstance.value);
                if (actualPointsApplied <= 0) { renderAllSkillsList(); return; }

                skillInstance.value += actualPointsApplied;
                character.skillBoostsUsed += costForThisBoost;
                character.skillBoostsUsed = parseFloat(character.skillBoostsUsed.toFixed(1)); // Gegen Fließkomma-Ungenauigkeiten

                // `skillInstance.increases` zählt nur volle +20% Aktionen, die 1.0 Slot gekostet haben
                if (actualPointsApplied === SKILL_INCREASE_AMOUNT && costForThisBoost === 1.0) {
                    skillInstance.increases = (skillInstance.increases || 0) + 1;
                }
                
                skillInstance.value = Math.min(skillInstance.value, MAX_SKILL_VALUE);

                const increasesChosenEl = document.getElementById('increases-chosen-count');
                if (increasesChosenEl) increasesChosenEl.textContent = character.skillBoostsUsed.toFixed(character.skillBoostsUsed % 1 !== 0 ? 1 : 0);

                renderAllSkillsList();
                updateNavigationButtons();
            }

            // Neuer Handler für die Inline-Typ-Eingabefelder
            function handleInlineTypeInputChange(event) {
                const instanceId = event.target.dataset.instanceId;
                const newTypeName = event.target.value;
                const skillInstance = character.skills.find(s => s.instanceId === instanceId);

                console.log(`InlineTypeChange: ID=${instanceId}, NewType='${newTypeName}'`);

                if (skillInstance && ALL_SKILLS[skillInstance.key].type) {
                    skillInstance.typeName = newTypeName;
                    console.log(`   Updated skillInstance.typeName to '${skillInstance.typeName}'`);

                    const skillListItem = document.querySelector(`.skill-list-item[data-instance-id="${instanceId}"]`);
                    if (skillListItem) {
                        const plusButton = skillListItem.querySelector('.skill-increase-button');
                        if (plusButton) {
                            let totalIncreases = 0;
                            character.skills.forEach(s => totalIncreases += (s.increases || 0));
                            const skillDef = ALL_SKILLS[skillInstance.key];

                            const typeStillMissingForButton = skillDef.type && (!skillInstance.typeName || skillInstance.typeName.trim() === "");
                            let currentPlusDisabled = totalIncreases >= MAX_SKILL_INCREASES ||
                                                   skillInstance.value >= MAX_SKILL_VALUE ||
                                                   typeStillMissingForButton;
                            if (skillInstance.key === "unnatural") currentPlusDisabled = true;

                            console.log(`   ButtonCheck: totalInc=${totalIncreases}, val=${skillInstance.value}, typeMissing=${typeStillMissingForButton}, finalDisabled=${currentPlusDisabled}`);
                            plusButton.disabled = currentPlusDisabled;
                        } else {
                            console.error("   Plus button not found for item " + instanceId);
                        }
                    } else {
                        console.error("   Skill list item not found for " + instanceId);
                    }
                }
            }
            // Die handleInlineTypeInputBlurIfDefined Funktion (deine vorherige Version,
            // die das Entfernen der generischen Instanz bei leerem Typ + keine Increases beinhaltet)
            function handleInlineTypeInputBlurIfDefined(event) {
                const instanceId = event.target.dataset.instanceId;
                const skillInstance = character.skills.find(s => s.instanceId === instanceId);

                if (!skillInstance) {
                    console.warn("handleInlineTypeInputBlurIfDefined: Instance not found for ID:", instanceId);
                    updateNavigationButtons();
                    return;
                }

                const skillDef = ALL_SKILLS[skillInstance.key];
                if (!skillDef.type) {
                    updateNavigationButtons();
                    return;
                }

                const newFinalTrimmedTypeName = event.target.value.trim();

                if (skillInstance.typeName !== newFinalTrimmedTypeName) {
                    skillInstance.typeName = newFinalTrimmedTypeName;
                }
                if (event.target.value !== newFinalTrimmedTypeName) {
                    event.target.value = newFinalTrimmedTypeName;
                }

                const isNowEffectivelyEmpty = skillInstance.typeName === "";
                const hadIncreasesPreviously = (skillInstance.increases || 0) > 0;
                const wasGenericInstance = !skillInstance.isProfessional && !skillInstance.isChoiceSkill;

                let reRenderNeeded = false;

                if (isNowEffectivelyEmpty) {
                    if (hadIncreasesPreviously) {
                        skillInstance.increases = 0;
                        skillInstance.value = skillDef.base + (skillInstance.baseValueFromProfession || 0);
                        skillInstance.value = Math.max(0, Math.min(99, skillInstance.value));
                        reRenderNeeded = true;
                    }

                    if (wasGenericInstance && (skillInstance.increases || 0) === 0) {
                        character.skills = character.skills.filter(s => s.instanceId !== instanceId);
                        reRenderNeeded = true;
                    }
                } else { // Typ wurde gesetzt/geändert
                    // Wenn sich der Typ geändert hat, ist ein Re-Render gut, um z.B. Sortierung und Button-Status zu aktualisieren.
                    if (event.target.value !== skillInstance.typeName /* ursprünglicher Wert vor trimmen */ || newFinalTrimmedTypeName !== skillInstance.typeName /* Datenmodell geändert */) {
                       reRenderNeeded = true;
                    }
                }

                if (reRenderNeeded) {
                    renderAllSkillsList();
                } else {
                    // Ggf. nur den betroffenen Button aktualisieren, wenn kein volles Re-Render nötig
                    const skillListItem = document.querySelector(`.skill-list-item[data-instance-id="${instanceId}"]`);
                    if (skillListItem) {
                        const plusButton = skillListItem.querySelector('.skill-increase-button');
                        if (plusButton) {
                            let totalIncreases = 0; character.skills.forEach(s => totalIncreases += (s.increases || 0));
                            const typeStillMissing = skillDef.type && (skillInstance.typeName === "" || skillInstance.typeName === null);
                            plusButton.disabled = totalIncreases >= MAX_SKILL_INCREASES || skillInstance.value >= MAX_SKILL_VALUE || typeStillMissing || skillInstance.key === "unnatural";
                        }
                    }
                }
                updateNavigationButtons();
            }

            // Angepasster Handler für +20%
            function handleSkillIncreaseClick(event) {
                const instanceId = event.target.dataset.instanceId;
                // Diese Werte kommen jetzt korrekt vom Button
                const pointsToAddFromButton = parseInt(event.target.dataset.pointsToAdd);
                const costForThisBoostFromButton = parseFloat(event.target.dataset.costForBoost);
                
                const skillInstance = character.skills.find(s => s.instanceId === instanceId);

                console.log("--- handleSkillIncreaseClick ---");
                console.log("Button Data: pointsToAdd=", pointsToAddFromButton, "costForThisBoost=", costForThisBoostFromButton);
                console.log("Current skillBoostsUsed BEFORE:", character.skillBoostsUsed);


                if (!skillInstance || pointsToAddFromButton <= 0 || costForThisBoostFromButton <= 0) {
                    console.warn("IncreaseClick: Ungültige Instanz, Punkte oder Kosten.", skillInstance, pointsToAddFromButton, costForThisBoostFromButton);
                    renderAllSkillsList(); return;
                }

                const skillDef = ALL_SKILLS[skillInstance.key];
                if (skillDef.type && (!skillInstance.typeName || skillInstance.typeName.trim() === "")) {
                    alert(t('alert_type_for_skill_needed', { skillName: t(skillDef.nameKey) }));
                    return;
                }
                if (skillInstance.key === "unnatural") { return; }
                if (skillInstance.value >= MAX_SKILL_VALUE) { renderAllSkillsList(); return; }

                // Prüfe, ob genügend "Boost-Slots" übrig sind
                if (parseFloat((character.skillBoostsUsed + costForThisBoostFromButton).toFixed(1)) > MAX_SKILL_INCREASES + 0.01) { // +0.01 Toleranz
                    alert(t('alert_skill_increase_limit'));
                    console.log(`Not enough boost slots. Current: ${character.skillBoostsUsed}, Cost: ${costForThisBoostFromButton}, Max: ${MAX_SKILL_INCREASES}`);
                    renderAllSkillsList(); return;
                }

                // `pointsToAddFromButton` sollte bereits der gekappte Wert sein, den der Button anzeigt.
                // Wir müssen hier nur noch sicherstellen, dass wir nicht über MAX_SKILL_VALUE gehen,
                // falls die Button-Logik das nicht perfekt gekappt hat.
                const actualPointsToApply = Math.min(pointsToAddFromButton, MAX_SKILL_VALUE - skillInstance.value);
                if (actualPointsToApply <= 0) {
                     console.log("No actual points to apply, skill might be full or button value was 0.");
                     renderAllSkillsList(); return;
                }

                skillInstance.value += actualPointsToApply;
                character.skillBoostsUsed += costForThisBoostFromButton;
                character.skillBoostsUsed = parseFloat(character.skillBoostsUsed.toFixed(1)); // Korrektur von Fließkomma-Ungenauigkeiten

                // `skillInstance.increases` zählt nur, wenn ein "voller" 1.0-Slot-Boost angewendet wurde.
                if (costForThisBoostFromButton === 1.0 && actualPointsToApply === SKILL_INCREASE_AMOUNT) {
                    skillInstance.increases = (skillInstance.increases || 0) + 1;
                }
                
                skillInstance.value = Math.min(skillInstance.value, MAX_SKILL_VALUE); // Finale Kappung

                console.log(`Applied ${actualPointsToApply} to ${skillInstance.key}. New value: ${skillInstance.value}. Cost: ${costForThisBoostFromButton}. Total Boosts Used: ${character.skillBoostsUsed}. Full Increases on skill: ${skillInstance.increases}`);

                const increasesChosenEl = document.getElementById('increases-chosen-count');
                if (increasesChosenEl) increasesChosenEl.textContent = character.skillBoostsUsed.toFixed(character.skillBoostsUsed % 1 !== 0 ? 1 : 0);

                renderAllSkillsList();
                updateNavigationButtons();
            }

            // Angepasster Handler für -20%
            function handleSkillDecreaseClick(event) {
                const instanceId = event.target.dataset.instanceId;
                const pointsToDecrease = parseInt(event.target.dataset.pointsToDecrease);
                const boostValueToReturn = parseFloat(event.target.dataset.boostValueToReturn); // Kann 1.0 oder 0.5
                const skillInstance = character.skills.find(s => s.instanceId === instanceId);

                if (!skillInstance || pointsToDecrease <= 0 || boostValueToReturn <= 0) {
                    // console.warn("DecreaseClick: Ungültige Instanz, Punkte oder Rückgabewert.");
                    renderAllSkillsList(); return;
                }

                const skillDef = ALL_SKILLS[skillInstance.key];
                const naturalSkillValue = skillDef.base + (skillInstance.baseValueFromProfession || 0);

                if (skillInstance.value <= naturalSkillValue) { renderAllSkillsList(); return; }
                // Erlaube Reduktion, auch wenn character.skillBoostsUsed 0 ist, aber setze es nicht unter 0.
                // Die Button-Logik sollte das aber schon verhindern.

                const actualPointsDecreased = Math.min(pointsToDecrease, skillInstance.value - naturalSkillValue);
                if (actualPointsDecreased <= 0) { renderAllSkillsList(); return; }

                skillInstance.value -= actualPointsDecreased;
                character.skillBoostsUsed -= boostValueToReturn;
                character.skillBoostsUsed = Math.max(0, parseFloat(character.skillBoostsUsed.toFixed(1))); // Nicht unter 0, Fließkomma korrigieren

                // `skillInstance.increases` (volle Boosts) anpassen
                if (actualPointsDecreased === SKILL_INCREASE_AMOUNT && boostValueToReturn === 1.0 && (skillInstance.increases || 0) > 0) {
                    skillInstance.increases--;
                }
                // Wenn ein Teil-Boost (der 0.5 gekostet hat) zurückgenommen wird, und dieser Teil-Boost war auf einem Skill,
                // der vorher z.B. 1.0 `increases` hatte, dann wird `increases` nicht reduziert. Das ist korrekt,
                // da `increases` nur die *vollen* +20er zählt. Die `increaseCountText`-Logik in `renderAllSkillsList`
                // versucht, den Unterschied zwischen `value` und `naturalValue + increases*20` als "Teil-Boost" darzustellen.
                
                const increasesChosenEl = document.getElementById('increases-chosen-count');
                if (increasesChosenEl) increasesChosenEl.textContent = character.skillBoostsUsed.toFixed(character.skillBoostsUsed % 1 !== 0 ? 1 : 0);

                renderAllSkillsList();
                updateNavigationButtons();
            }
            // NEU: Listener und Handler für Custom Profession - Skill Allocation
            function attachCustomSkillAllocationListeners() { /* TODO: Major rewrite needed */
                const skillListDiv = document.getElementById('custom-profession-skill-list');
                const confirmBtn = document.getElementById('btn-confirm-custom-skills');

                if (skillListDiv) {
                    // Event Delegation für die dynamisch erstellten Elemente
                    skillListDiv.addEventListener('change', (event) => {
                        if (event.target.classList.contains('custom-prof-skill-select-main')) {
                            handleCustomBaseSkillMainCheckboxChange(event.target); // Behandelt die Haupt-Checkboxen
                        } else if (event.target.classList.contains('custom-instance-type-input')) {
                            handleCustomInstanceTypeChange(event.target); // Behandelt Typ-Eingabe für eine Instanz
                        }
                    });

                    skillListDiv.addEventListener('click', (event) => {
                        if (event.target.classList.contains('btn-add-another-specialization')) {
                            handleAddAnotherSpecializationClick(event.target);
                        } else if (event.target.classList.contains('remove-custom-skill-instance-btn')) {
                            handleRemoveCustomSkillInstanceClick(event.target);
                        } else if (event.target.classList.contains('custom-skill-point-btn')) {
                            handleCustomInstancePointChangeFromButton(event.target);
                        }
                    });
                }

                if (confirmBtn) {
                    confirmBtn.removeEventListener('click', handleConfirmCustomSkills);
                    confirmBtn.addEventListener('click', handleConfirmCustomSkills);
                }
                updateCustomSkillAllocationUI(); // Initialer UI-Status
            }
            // --- Handler für Custom Profession Skill Allocation ---
            function handleCustomBaseSkillMainCheckboxChange(checkbox) {
                const baseKey = checkbox.dataset.skillKey;
                // const isTyped = checkbox.dataset.isTyped === 'true'; // Unused for now
                const isChecked = checkbox.checked;

                const existingInstances = character.customProfessionSelectedSkills.filter(inst => inst.key === baseKey);

                if (isChecked) { // Skill wurde ausgewählt
                    if (character.customProfessionSelectedSkills.length >= 10 && existingInstances.length === 0) {
                        checkbox.checked = false; // Verhindere Auswahl, wenn Max erreicht und dies ein *neuer* Basis-Skill wäre
                        alert(t('alert_max_10_custom_skills'));
                        return;
                    }
                    // Wenn angehakt und noch keine Instanz dieses Basis-Skills existiert, füge eine hinzu.
                    if (existingInstances.length === 0) {
                        character.customProfessionSelectedSkills.push({
                            key: baseKey,
                            typeName: "", // Typ initial leer
                            points: 0,
                            tempInstanceId: generateInstanceId(baseKey, "custom_0") // Eindeutige temporäre ID
                        });
                    }
                } else { // Skill wurde abgewählt (Haupt-Checkbox)
                    // Entferne ALLE Instanzen dieses Basis-Skills aus der Auswahl
                    character.customProfessionSelectedSkills = character.customProfessionSelectedSkills.filter(
                        inst => inst.key !== baseKey
                    );
                }
                renderCurrentStep(); // Um die UI komplett neu zu zeichnen (inkl. Instanzen-Container)
            }


            function handleCustomBaseSkillSelectChange(checkbox) {
                const baseKey = checkbox.dataset.skillKey;
                const isTyped = checkbox.dataset.isTyped === 'true';
                const isChecked = checkbox.checked;

                const existingInstancesOfThisBaseKey = character.customProfessionSelectedSkills.filter(inst => inst.key === baseKey);

                if (isChecked) {
                    if (character.customProfessionSelectedSkills.length >= 10) {
                        checkbox.checked = false; // Verhindern
                        alert(t('alert_max_10_custom_skills'));
                        return;
                    }
                    // Wenn angehakt und noch keine Instanz dieses Basis-Skills existiert, füge eine hinzu.
                    if (existingInstancesOfThisBaseKey.length === 0) {
                        character.customProfessionSelectedSkills.push({
                            key: baseKey,
                            typeName: "", 
                            points: 0,
                            tempInstanceId: generateInstanceId(baseKey, "custom_0") 
                        });
                    }
                } else {
                    // Wenn abgewählt, entferne ALLE Instanzen dieses Basis-Skills
                    character.customProfessionSelectedSkills = character.customProfessionSelectedSkills.filter(
                        inst => inst.key !== baseKey
                    );
                }
                renderCurrentStep(); // Um die Instanzenliste und die UI neu zu zeichnen
            }
            function handleAddAnotherSpecializationClick(button) {
                const baseKey = button.dataset.skillKey;
                if (character.customProfessionSelectedSkills.length >= 10) {
                    alert(t('alert_max_10_custom_skills'));
                    return;
                }
                // Füge eine neue, leere Instanz für diesen Basis-Skill hinzu
                const count = character.customProfessionSelectedSkills.filter(i => i.key === baseKey).length;
                character.customProfessionSelectedSkills.push({
                    key: baseKey,
                    typeName: "",
                    points: 0,
                    tempInstanceId: generateInstanceId(baseKey, `custom_${count}`)
                });
                renderCurrentStep(); // UI neu zeichnen
            }   
            function handleRemoveCustomSkillInstanceClick(button) {
                const tempIdToRemove = button.dataset.instanceTempId;
                character.customProfessionSelectedSkills = character.customProfessionSelectedSkills.filter(
                    inst => inst.tempInstanceId !== tempIdToRemove
                );
                renderCurrentStep(); // UI neu zeichnen
            }
            function handleCustomInstanceTypeChange(inputField) {
                const tempId = inputField.dataset.instanceTempId;
                const instance = character.customProfessionSelectedSkills.find(inst => inst.tempInstanceId === tempId);
                if (instance) {
                    instance.typeName = inputField.value.trim();
                }
                // Kein renderCurrentStep() hier, da es bei jedem Tastendruck feuern würde.
                // updateNavigationButtons() wird durch die Punktänderung oder beim Verlassen des Feldes wichtiger.
                // Für den Moment reicht es, wenn die Validierung beim Bestätigen greift.
                updateNavigationButtons(); // Um "Confirm" Button ggf. zu (de)aktivieren
            }

            function handleCustomInstancePointChangeFromButton(button) {
                const tempId = button.dataset.instanceTempId;
                const instance = character.customProfessionSelectedSkills.find(inst => inst.tempInstanceId === tempId);
                if (!instance) return;

                const action = button.dataset.action;
                const amount = parseInt(button.dataset.amount);
                const skillDef = ALL_SKILLS[instance.key];
                let currentPoints = instance.points || 0;
                let newPoints = currentPoints;

                let totalPointsSpentCurrently = 0;
                character.customProfessionSelectedSkills.forEach(s => totalPointsSpentCurrently += (s.points || 0));

                if (action === "increase") {
                    // Prüfen, ob Budget überschritten würde
                    if ((totalPointsSpentCurrently - currentPoints + (currentPoints + amount)) > character.customProfessionSkillPointBudget) {
                        // Hier könnte man eine subtilere Meldung geben oder den Button einfach deaktiviert lassen.
                        // Für den Moment: keine Erhöhung, wenn Budget nicht reicht.
                        return;
                    }
                    // Prüfen, ob Skill-Maximum (60%) überschritten würde
                    if ((skillDef.base + currentPoints + amount) > 60) {
                        if (skillDef.base + currentPoints < 60) { // Nur erhöhen, wenn noch nicht bei 60
                            newPoints = 60 - skillDef.base;
                        } else {
                            return; // Bereits bei 60 oder drüber (sollte nicht passieren)
                        }
                    } else {
                        newPoints = currentPoints + amount;
                    }
                } else if (action === "decrease") {
                    newPoints = Math.max(0, currentPoints - amount);
                }

                instance.points = newPoints;
                updateCustomSkillAllocationUI(); // Aktualisiert die UI-Teile für diese Instanz und das Gesamtbudget
            }



            function handleCustomSkillTypeInputChange(inputField) {
                const skillKey = inputField.dataset.skillKey;
                if (character.customProfessionSelectedSkills[skillKey]) {
                    character.customProfessionSelectedSkills[skillKey].typeName = inputField.value.trim();
                }
                updateNavigationButtons(); // Validierung für "Weiter"-Knopf (Confirm Custom Skills) prüfen
            }
            
            // handleCustomSkillPointChange (die verbesserte Version aus der vorherigen Antwort)
            function handleCustomSkillPointChange(button) {
                const skillKey = button.dataset.skillKey;
                const action = button.dataset.action; 
                const amount = parseInt(button.dataset.amount); 

                if (!character.customProfessionSelectedSkills[skillKey] && action === "increase") {
                    // Dies sollte nicht passieren, wenn Skill nicht ausgewählt ist, aber als Sicherheitsnetz
                    character.customProfessionSelectedSkills[skillKey] = { points: 0, typeName: "" };
                } else if (!character.customProfessionSelectedSkills[skillKey]) {
                    return;
                }


                let currentPoints = character.customProfessionSelectedSkills[skillKey].points;
                const baseValue = ALL_SKILLS[skillKey].base;
                let newPoints = currentPoints; 

                if (action === "increase") {
                    let totalSpent = 0;
                    Object.values(character.customProfessionSelectedSkills).forEach(s => totalSpent += (s.points || 0));
                    
                    if (totalSpent - currentPoints + (currentPoints + amount) > character.customProfessionSkillPointBudget) {
                        // console.log("Budget limit for increase");
                        updateCustomSkillAllocationUI(); // Nur UI neu zeichnen
                        return; 
                    }
                    
                    if ((baseValue + currentPoints + amount) > 60) {
                        if (baseValue + currentPoints < 60) { // Nur anpassen, wenn es noch nicht 60 ist
                            newPoints = 60 - baseValue; 
                        } else { // Ist schon bei 60 oder drüber (sollte nicht passieren)
                            updateCustomSkillAllocationUI();
                            return;
                        }
                    } else {
                        newPoints = currentPoints + amount;
                    }
                } else if (action === "decrease") {
                    if (currentPoints - amount < 0) {
                        newPoints = 0;
                    } else {
                        newPoints = currentPoints - amount;
                    }
                } else { return; }

                if (newPoints < 0) newPoints = 0; // Doppelte Sicherung
                if ((baseValue + newPoints) > 60) newPoints = 60 - baseValue; // Doppelte Sicherung


                if (newPoints !== currentPoints) {
                    character.customProfessionSelectedSkills[skillKey].points = newPoints;
                }
                
                updateCustomSkillAllocationUI(); 
            }
            function handleCustomInstancePointChange(instanceIndex, action, amount) {
                const instance = character.customProfessionSelectedSkills[instanceIndex];
                if (!instance) return;

                let currentPoints = instance.points;
                const baseValue = ALL_SKILLS[instance.key].base;
                let newPoints = currentPoints;

                if (action === "increase") {
                    let totalSpent = 0;
                    character.customProfessionSelectedSkills.forEach(s => totalSpent += (s.points || 0));
                    if ((totalSpent - currentPoints + (currentPoints + amount)) > character.customProfessionSkillPointBudget) {
                        return; 
                    }
                    if ((baseValue + currentPoints + amount) > 60) {
                        if (baseValue + currentPoints < 60) newPoints = 60 - baseValue;
                        else return;
                    } else {
                        newPoints = currentPoints + amount;
                    }
                } else if (action === "decrease") {
                    newPoints = currentPoints - amount < 0 ? 0 : currentPoints - amount;
                }

                if ((baseValue + newPoints) > 60) newPoints = 60 - baseValue; // Doppelte Sicherung
                if (newPoints < 0) newPoints = 0;

                if (newPoints !== currentPoints) {
                    instance.points = newPoints;
                }
                updateCustomSkillAllocationUI();
            }
            
            // updateCustomSkillAllocationUI muss jetzt die Liste der Instanzen aktualisieren
            // updateCustomSkillAllocationUI muss ggf. leicht angepasst werden,
            // um mit `data-instance-temp-id` und der neuen Struktur zu arbeiten.
            // Die Logik für das Aktualisieren der Texte und Button-Disabled-Status bleibt ähnlich.
            function updateCustomSkillAllocationUI() { // Aktualisiert Zähler und Button-Status
                const budget = character.customProfessionSkillPointBudget;
                let pointsSpent = 0;
                character.customProfessionSelectedSkills.forEach(inst => pointsSpent += (inst.points || 0));
                const remainingPoints = budget - pointsSpent;
                const numSelectedInstances = character.customProfessionSelectedSkills.length;

                const infoP = document.getElementById('custom-prof-skill-allocation-info');
                if (infoP) {
                    infoP.innerHTML = t("custom_prof_info_skill_allocation", { currentBudget: budget, remainingPoints: remainingPoints });
                }
                const countSpan = document.getElementById('custom-skills-selected-actual-count');
                if (countSpan) countSpan.textContent = numSelectedInstances;

                // Deaktiviere Haupt-Checkboxes, wenn 10 Skills gewählt sind und die Box nicht schon gecheckt ist
                document.querySelectorAll('.custom-prof-skill-select-main').forEach(cb => {
                    const isBaseRepresented = character.customProfessionSelectedSkills.some(inst => inst.key === cb.dataset.skillKey);
                    cb.disabled = numSelectedInstances >= 10 && !isBaseRepresented;
                    cb.closest('label').classList.toggle('disabled-choice', cb.disabled);

                    // Add-Specialization Button Logik
                    const baseItemDiv = cb.closest('.custom-skill-item-base');
                    const addSpecButton = baseItemDiv.querySelector('.btn-add-another-specialization');
                    if (addSpecButton) {
                         const skillDef = ALL_SKILLS[addSpecButton.dataset.skillKey];
                         addSpecButton.style.display = (skillDef.type && isBaseRepresented) ? 'inline-block' : 'none';
                         addSpecButton.disabled = numSelectedInstances >= 10; // Auch hier deaktivieren
                    }
                });


                // Aktualisiere die Controls für jede gerenderte Instanz
                document.querySelectorAll('.skill-instance-controls').forEach(itemDiv => {
                    const tempId = itemDiv.dataset.instanceTempId;
                    const instance = character.customProfessionSelectedSkills.find(inst => inst.tempInstanceId === tempId);
                    if (!instance) { // Sollte nicht passieren, wenn renderCurrentStep() die Liste baut
                        itemDiv.style.display = 'none'; // Verstecken, falls doch
                        return;
                    }

                    const skillDef = ALL_SKILLS[instance.key];
                    const currentPoints = instance.points || 0;
                    const currentTotal = skillDef.base + currentPoints;

                    const assignedPointsSpan = itemDiv.querySelector('.custom-skill-assigned-points');
                    if (assignedPointsSpan) assignedPointsSpan.textContent = currentPoints;

                    const totalValueSpan = itemDiv.querySelector('.custom-skill-total-value');
                    if (totalValueSpan) totalValueSpan.innerHTML = `${t('custom_prof_label_skill_total')} ${currentTotal}% (max 60%)`;

                    // +/- Buttons für Punkte
                    itemDiv.querySelectorAll('.custom-skill-point-btn').forEach(btn => {
                        const action = btn.dataset.action;
                        const amount = parseInt(btn.dataset.amount);
                        if (action === "decrease") {
                            btn.disabled = currentPoints < amount; // Deaktiviere, wenn nicht genug Punkte zum Abziehen da sind
                        } else if (action === "increase") {
                            btn.disabled = (skillDef.base + currentPoints + amount > 60) || (remainingPoints < amount && (currentPoints + amount > instance.points));
                        }
                    });
                });
                updateNavigationButtons(); // Wichtig für den "Confirm Custom Skills" Button
            }


            function handleConfirmCustomSkills() {
                if (!validateStep1(true)) { // Nutze validateStep1 für die Prüfung
                    return;
                }

                // 1. Setze die Haupt-Skill-Liste zurück (initializeCharacterSkills macht das)
                // ABER: Wir wollen die generischen Instanzen behalten.
                // Stattdessen: Gehe durch character.customProfessionSelectedSkills
                // und erstelle/aktualisiere die entsprechenden Instanzen in character.skills
                
                // Markiere alle aktuellen Skills als nicht-professionell, bevor Custom Skills angewendet werden.
                // (Dies ist wichtig, falls man von einem Standard-Beruf zu Custom wechselt und dann bestätigt)
                character.skills.forEach(s => {
                    s.isProfessional = false;
                    s.baseValueFromProfession = 0;
                    // Neuberechnung des Wertes, falls Increases vorhanden sind
                    s.value = ALL_SKILLS[s.key].base + ((s.increases || 0) * SKILL_INCREASE_AMOUNT);
                });


                character.customProfessionSelectedSkills.forEach(customInstance => {
                    const skillKey = customInstance.key;
                    const typeName = customInstance.typeName; // Kann leer sein, wenn nicht typisiert oder Nutzer nichts eingab
                    const pointsFromCustom = customInstance.points || 0;
                    const targetValue = ALL_SKILLS[skillKey].base + pointsFromCustom; // Zielwert inkl. Basis

                    // `findOrCreateSkillInstance` kümmert sich um die Erstellung/Aktualisierung.
                    // Wichtig: Da wir Ansatz B folgen, wird für typisierte Skills mit explizitem typeName eine neue Instanz erstellt,
                    // wenn noch keine exakt passende existiert. Die generische Instanz (mit typeName="") bleibt unberührt.
                    const mainSkillInstance = findOrCreateSkillInstance(skillKey, typeName, true, targetValue);
                    // `isProfessional` und `baseValueFromProfession` werden in `findOrCreateSkillInstance` gesetzt.
                    // Der Wert wird dort auch basierend auf targetValue und base berechnet.
                });

                character.customProfessionSetupStage = 'done';
                renderCurrentStep(); // Zeigt jetzt die +20% Skill-Boost-Liste an
            }


            // VALIDATE STEP 1 (ERWEITERT für alle Phasen)
            // --- Validate & Save Step 1 ---
            function validateStep1(showAlerts = true) {
                console.log("--- validateStep1 --- ProfKey:", character.professionKey, "isCustom:", character.isCustomProfession, "CustomStage:", character.customProfessionSetupStage);

                if (!character.professionKey) {
                    if (showAlerts) alert(t('alert_select_profession'));
                    console.log("validateStep1 FAIL: No professionKey");
                    return false;
                }

                if (character.isCustomProfession) {
                    if (character.customProfessionSetupStage === 'bonds') {
                        if (!character.customProfessionName || character.customProfessionName.trim() === "") {
                            if (showAlerts) alert("Please enter a name for your custom profession."); // i18n
                            return false; // Verhindert das Fortfahren über den "Confirm Bonds" Button, wenn kein Name
                        }
                        return true; // "Next" Button ist hier deaktiviert, Validierung für internen Button
                    } else if (character.customProfessionSetupStage === 'skills') {
                        if (character.customProfessionSelectedSkills.length !== 10) {
                            if (showAlerts) alert(t('alert_max_10_custom_skills'));
                            return false;
                        }
                        let pointsSpent = 0;
                        character.customProfessionSelectedSkills.forEach(inst => pointsSpent += (inst.points || 0));
                        if (pointsSpent !== character.customProfessionSkillPointBudget) {
                            if (showAlerts) alert(t('alert_distribute_all_custom_points', {
                                totalBudget: character.customProfessionSkillPointBudget,
                                remainingPoints: character.customProfessionSkillPointBudget - pointsSpent
                            }));
                            return false;
                        }
                        for (const customInstance of character.customProfessionSelectedSkills) {
                            const skillDef = ALL_SKILLS[customInstance.key];
                            if ((skillDef.base + (customInstance.points || 0)) > 60) {
                                if (showAlerts) alert(t('alert_custom_skill_max_60', { skillName: t(skillDef.nameKey) }));
                                return false;
                            }
                            if (skillDef.type && (!customInstance.typeName || customInstance.typeName.trim() === "")) {
                                if (showAlerts) alert(t('alert_specify_type_for_custom_skill', { skillName: t(skillDef.nameKey) }));
                                return false;
                            }
                        }
                        return true; // Validierung für "Confirm Custom Skills" Button
                    }
                    // Für 'done' Stage (also +20% Boosts) gibt es keine spezielle Custom-Validierung mehr,
                    // die den "Next" Button blockieren würde, außer den allgemeinen Skill-Boost-Regeln.
                } else { // Standardberuf
                    const profData = PROFESSIONS[character.professionKey];
                    if (!profData) return false;

                    // Prüfe Typen für Basis-Skills des Berufs, die typisiert sind und keinen Default haben
                    for (const skillInfo of profData.baseSkills) {
                        if (ALL_SKILLS[skillInfo.key]?.type && !skillInfo.typeNameDefault && !skillInfo.orSkills) {
                            // Finde die Instanz, die für diesen Slot erstellt wurde (sollte eine generische sein)
                            const instance = character.skills.find(s => s.key === skillInfo.key && s.isProfessional && (s.typeName === "" || s.typeName === null));
                            if (instance && (instance.typeName === "" || instance.typeName === null)) {
                                if (showAlerts) alert(t('alert_type_for_skill_needed', { skillName: t(ALL_SKILLS[skillInfo.key].nameKey) }));
                                return false;
                            }
                        }
                        // Für orSkills: Der Typ wird als "" angenommen, wenn typisiert und muss in der +20% Liste spezifiziert werden.
                    }
                    // Prüfe Typen für ausgewählte Choice Skills
                    if (profData.choiceSkills) {
                        for (const choiceKey in character.profChoiceSkillSelections) {
                            if (character.profChoiceSkillSelections[choiceKey] && ALL_SKILLS[choiceKey]?.type) {
                                const choiceInstance = character.skills.find(s => s.key === choiceKey && s.isChoiceSkill);
                                if (choiceInstance && (choiceInstance.typeName === "" || choiceInstance.typeName === null)) {
                                    if (showAlerts) alert(t('alert_type_for_skill_needed', { skillName: t(ALL_SKILLS[choiceKey].nameKey) }));
                                    return false;
                                }
                            }
                        }
                    }
                }
                // Allgemeine Validierung für die +20% Boost Phase (gilt für Standard und Custom 'done')
                if (!character.isCustomProfession || (character.isCustomProfession && character.customProfessionSetupStage === 'done')) {
                    // let totalIncreases = 0;
                    // character.skills.forEach(s => totalIncreases += (s.increases || 0)); // Diese Zählung ist jetzt nicht mehr die richtige für die 8 Boosts

                    // Verwende stattdessen character.skillBoostsUsed
                    if (character.skillBoostsUsed < MAX_SKILL_INCREASES && currentStep === 1) { // Nur wenn man auf Step 1 ist und Next drückt
                        if (showAlerts) { 
                            const message = t('confirm_incomplete_skill_boosts', { maxBoosts: MAX_SKILL_INCREASES });
                            const confirmContinue = confirm(message);
                            if (!confirmContinue) {
                                console.log("validateStep1 FAIL: User chose not to continue with incomplete boosts.");
                                return false;
                            }
                        }
                        // Wenn showAlerts false ist (interne Prüfung für Button-Status), dann ist es okay,
                        // aber für den "Next"-Klick wollen wir die Bestätigung.
                        // Für den Button-Status: Wenn weniger als 8, ist der Next-Button erstmal aktiv,
                        // erst beim Klick kommt die Bestätigung. Das ist gängige Praxis.
                    }

                    // Sicherstellen, dass alle geboosteten typisierten Skills einen Typ haben
                    for (const skillInst of character.skills) {
                        const skillDef = ALL_SKILLS[skillInst.key];
                        const needsTypeFilledIn = skillDef.type && (skillInst.typeName === "" || skillInst.typeName === null);
                        const isRelevantForTyping = skillInst.isProfessional || skillInst.isChoiceSkill || (skillInst.increases || 0) > 0;

                        if (needsTypeFilledIn && isRelevantForTyping) {
                            if (showAlerts) alert(t('alert_type_for_skill_needed', { skillName: t(skillDef.nameKey) }));
                            console.log(`validateStep1 FAIL: Type needed for relevant skill. Key: ${skillInst.key}, Name: '${skillInst.typeName}', Prof: ${skillInst.isProfessional}, Choice: ${skillInst.isChoiceSkill}, Inc: ${skillInst.increases}`);
                            return false;
                        }
                    }
                }
                console.log("validateStep1 PASS");
                return true;
            }

            function saveStep1() {
                // Die meisten Daten (Berufswahl, Skill-Instanzen, Custom-Prof-Daten)
                // sind bereits im `character`-Objekt durch die Event-Handler.
                // Für Custom Berufe: `handleConfirmCustomSkills` überträgt die ausgewählten Skills in die Haupt-Skill-Liste.
                // Hier ist nichts weiter zu tun.
            }

            // STEP 2: STATISTICS
            function renderStep2_Statistics() {
                const TOTAL_POINT_BUY_POINTS = 72;

                let html = `<div class="step" id="step2-statistics">
                    <h2 data-i18n="step_name_2"></h2>
                    <div class="info-box">
                        <p data-i18n="step2_info_stats"></p>
                        <ul>`;
                STAT_KEYS.forEach(key => {
                    html += `<li><strong>${t('stat_' + key.toLowerCase() + '_name')}</strong>: <span data-i18n="stat_${key.toLowerCase()}_desc"></span></li>`;
                });
                html += `</ul></div>

                    <h3 data-i18n="step2_select_method_label"></h3>
                    <div id="stat-method-selection" style="margin-bottom: 20px;">
                        <label class="inline-label">
                            <input type="radio" name="stat-method" value="array" ${character.statGenerationMethod === 'array' ? 'checked' : ''}>
                            <span data-i18n="stat_method_array"></span>
                        </label>
                        <label class="inline-label">
                            <input type="radio" name="stat-method" value="roll" ${character.statGenerationMethod === 'roll' ? 'checked' : ''}>
                            <span data-i18n="stat_method_roll"></span>
                        </label>
                        <label class="inline-label">
                            <input type="radio" name="stat-method" value="pointbuy" ${character.statGenerationMethod === 'pointbuy' ? 'checked' : ''}>
                            <span data-i18n="stat_method_pointbuy"></span>
                        </label>
                        <label class="inline-label">
                            <input type="radio" name="stat-method" value="manual" ${character.statGenerationMethod === 'manual' ? 'checked' : ''}>
                            <span data-i18n="stat_method_manual"></span>
                        </label>
                    </div>

                    <div id="stat-array-choice-container" style="display: ${character.statGenerationMethod === 'array' ? 'block' : 'none'};">
                        <h4 data-i18n="step2_select_array_sublabel"></h4>
                        <div id="stat-array-selection">`;
                STAT_ARRAYS.forEach((arr, index) => {
                    const isChecked = character.statArrayChoice === index && character.statGenerationMethod === 'array';
                    const replacementsJsonString = JSON.stringify({values: arr.join(', ')});
                    html += `<label class="inline-label">
                                <input type="radio" name="stat-array-option" value="${index}" ${isChecked ? 'checked' : ''}>
                                <span data-i18n="stat_array_option_label" data-i18n-replacements='${replacementsJsonString}'>
                                    ${t('stat_array_option_label', {values: arr.join(', ')})}
                                </span>
                             </label><br>`;
                });
                html += `   </div>
                    </div>

                    <div id="stat-roll-container" style="display: ${character.statGenerationMethod === 'roll' ? 'block' : 'none'};">
                        <button id="btn-roll-stats" class="action-button" data-i18n="btn_roll_stats_text"></button>
                        <div id="rolled-stats-display" style="margin-top: 10px; font-weight: bold; font-size: 1.1em;">`;
                if (character.statGenerationMethod === 'roll' && character.rolledStatValues.length === 6) {
                    html += `<span data-i18n="rolled_values_label"></span> ${character.rolledStatValues.join(', ')}`;
                } else if (character.statGenerationMethod === 'roll') {
                    html += `<span data-i18n="click_to_roll_stats_label"></span>`;
                }
                html += `   </div>
                    </div>

                    <div id="stat-pointbuy-container" style="display: ${character.statGenerationMethod === 'pointbuy' ? 'block' : 'none'};">
                        <div class="info-box">
                            <p data-i18n="pointbuy_info_text" data-i18n-replacements='{"totalPoints": "${TOTAL_POINT_BUY_POINTS}"}'></p>
                        </div>
                        <div id="pointbuy-summary" style="margin-bottom:15px; font-weight:bold; font-size: 1.1em; padding: 10px; background-color: #f9f9f9; border: 1px solid #eee; border-radius: 3px;">
                            <span data-i18n="pointbuy_points_summary_label" 
                                  data-i18n-replacements='{"spent":"${calculateTotalPointsSpentInPointBuy()}", "total":"${TOTAL_POINT_BUY_POINTS}", "remaining":"${TOTAL_POINT_BUY_POINTS - calculateTotalPointsSpentInPointBuy()}"}'>
                                ${t('pointbuy_points_summary_label', {spent: calculateTotalPointsSpentInPointBuy(), total: TOTAL_POINT_BUY_POINTS, remaining: TOTAL_POINT_BUY_POINTS - calculateTotalPointsSpentInPointBuy()})}
                            </span>
                        </div>
                        <div id="pointbuy-stat-inputs">`;
                STAT_KEYS.forEach(key => {
                    const currentValue = character.stats[key] || 3;
                    html += `<div class="pointbuy-stat-row" style="display:flex; align-items:center; margin-bottom:10px; padding-bottom:10px; border-bottom: 1px dotted #eee;">
                                <label for="pointbuy-${key}" style="width:180px; margin-bottom:0; font-weight:bold;">${t('stat_' + key.toLowerCase() + '_name')}:</label>
                                <input type="number" class="pointbuy-stat-input" id="pointbuy-${key}" data-stat-key="${key}" 
                                       value="${currentValue}" min="3" max="18" style="width:70px; margin: 0 5px 0 auto; text-align:center; padding: 6px; font-size:1em;">
                                <span class="stat-percentile" id="pointbuy-percentile-${key}" style="font-weight:bold; min-width:40px; text-align:right;">(${currentValue * 5}%)</span>
                             </div>`;
                });
                html += `       </div>
                    </div>

                    <div id="stat-manual-entry-container" style="display: ${character.statGenerationMethod === 'manual' ? 'block' : 'none'};">
                        <div class="info-box">
                            <p data-i18n="manual_entry_info_text"></p>
                        </div>
                        <div id="manual-entry-stat-inputs">`;
                STAT_KEYS.forEach(key => {
                    const currentValue = character.stats[key] || 10;
                    html += `<div class="manual-entry-stat-row" style="display:flex; align-items:center; margin-bottom:10px; padding-bottom:10px; border-bottom: 1px dotted #eee;">
                                <label for="manual-${key}" style="width:180px; margin-bottom:0; font-weight:bold;">${t('stat_' + key.toLowerCase() + '_name')}:</label>
                                <input type="number" class="manual-entry-stat-input" id="manual-${key}" data-stat-key="${key}" 
                                       value="${currentValue}" min="3" max="18" style="width:70px; margin: 0 5px 0 auto; text-align:center; padding: 6px; font-size:1em;">
                                <span class="stat-percentile" id="manual-percentile-${key}" style="font-weight:bold; min-width:40px; text-align:right;">(${currentValue * 5}%)</span>
                             </div>`;
                });
                html += `       </div>
                    </div>

                    <h3 id="step2-subheader-assign-features" 
                        data-i18n="${(character.statGenerationMethod === 'pointbuy' || character.statGenerationMethod === 'manual') ? 'step2_define_features_label' : 'step2_assign_stats_label'}" 
                        style="margin-top: 25px; border-top: 1px solid #ddd; padding-top: 20px;">
                    </h3>
                    <div class="info-box" style="margin-top: 10px;">
                        <p data-i18n="step2_info_distinguishing_feature"></p>
                    </div>
                    <div id="stat-assignment-or-features-container">
                    </div>
                </div>`;
                return html;
            }
            function manualEntryInputDelegationHandler(event) {
                if (event.target.classList.contains('manual-entry-stat-input')) {
                    handleManualEntryInputChange(event.target);
                }
            }
            function handleManualEntryInputChange(inputElement) {
                const statKey = inputElement.dataset.statKey;
                let newValue = parseInt(inputElement.value);

                if (isNaN(newValue)) newValue = 3; // Oder alten Wert behalten
                newValue = Math.max(3, Math.min(18, newValue));
                
                if (parseInt(inputElement.value) !== newValue) { // Korrigiere UI nur bei echter Änderung
                    inputElement.value = newValue;
                }

                character.stats[statKey] = newValue;
                updateManualEntryUI(); // Aktualisiert Prozente und Feature-Anzeige
                updateNavigationButtons();
            }

            function updateManualEntryUI() {
                console.log("--- updateManualEntryUI CALLED ---");
                // Aktualisiere die Prozentwerte
                STAT_KEYS.forEach(key => {
                    const statValue = character.stats[key] || 3;
                    const percentileDisplay = document.getElementById(`manual-percentile-${key}`);
                    if (percentileDisplay) {
                        percentileDisplay.textContent = `(${statValue * 5}%)`;
                    } else {
                        console.warn(`updateManualEntryUI - #manual-percentile-${key} span NOT FOUND!`);
                    }
                    // Eingabefeld-Wert synchronisieren (falls programmatisch geändert)
                    const inputField = document.getElementById(`manual-${key}`);
                    if (inputField && parseInt(inputField.value) !== statValue) {
                        inputField.value = statValue;
                    }
                });
                
                // UI für Distinguishing Features aktualisieren/rendern
                // Wir können hier updatePointBuyDistinguishingFeaturesUI wiederverwenden, da die Logik gleich ist
                // oder eine spezifischere/umbenannte Funktion erstellen.
                // Nennen wir sie allgemeiner:
                updateDistinguishingFeaturesUI(); // Statt updatePointBuyDistinguishingFeaturesUI
                updateNavigationButtons();
            }

            // Umbenannte/Generische Funktion für Feature UI
            function updateDistinguishingFeaturesUI() {
                const container = document.getElementById('stat-assignment-or-features-container');
                if (!container) return;
                
                // Nur Features anzeigen, wenn Methode PointBuy oder Manual ist
                if (character.statGenerationMethod !== 'pointbuy' && character.statGenerationMethod !== 'manual') {
                    container.innerHTML = ''; // Leeren, wenn nicht PointBuy/Manual
                    return;
                }
                container.innerHTML = ''; // Leeren für Neuaufbau der Features

                STAT_KEYS.forEach(key => {
                    const statValue = character.stats[key] || 0;
                    if (statValue !== 0 && (statValue < 9 || statValue > 12)) {
                        let featureHtml = `<div class="distinguishing-feature-input-container manual-feature-row">
                                            <label for="feature-${key}" class="distinguishing-feature-label" style="width:150px;">${t('stat_' + key.toLowerCase() + '_name')} - ${t('distinguishing_feature_label')}</label>
                                            <input type="text" id="feature-${key}" class="distinguishing-feature-input" data-stat-key="${key}" 
                                                   placeholder="${t('distinguishing_feature_placeholder')}" 
                                                   value="${character.distinguishingFeatures[key] || ''}" style="flex-grow:1;">
                                        </div>`;
                        container.innerHTML += featureHtml;
                    }
                });
                translateAllElements(container);
            }
            function calculateTotalPointsSpentInPointBuy() {
                let totalSpent = 0;
                STAT_KEYS.forEach(key => {
                    totalSpent += (character.stats[key] || 0); // Nimmt den Wert direkt aus character.stats
                });
                console.log("calculateTotalPointsSpentInPointBuy - Total Spent:", totalSpent, "Current Stats:", JSON.parse(JSON.stringify(character.stats)));
                return totalSpent;
            }
            function handlePointBuyInputChange(inputElement) {
                const statKey = inputElement.dataset.statKey;
                const oldValue = character.stats[statKey] || 3; // Der Wert *vor* der aktuellen Änderung
                let attemptedNewValue = parseInt(inputElement.value);
                const TOTAL_POINT_BUY_POINTS = 72;

                console.log(`--- handlePointBuyInputChange for ${statKey} --- Attempted: ${attemptedNewValue}, Old: ${oldValue}`);

                // 1. Grundlegende Validierung für den eingegebenen Wert (3-18)
                if (isNaN(attemptedNewValue)) {
                    inputElement.value = oldValue; // Zurücksetzen, wenn keine Zahl
                    // updatePointBuyUI(); // UI muss nicht aktualisiert werden, da keine gültige Änderung
                    return;
                }
                if (attemptedNewValue < 3) {
                    inputElement.value = 3;
                    attemptedNewValue = 3;
                } else if (attemptedNewValue > 18) {
                    inputElement.value = 18;
                    attemptedNewValue = 18;
                }

                // 2. Prüfe die Auswirkungen auf den Gesamtpunktepool
                let currentTotalWithoutThisStat = 0;
                STAT_KEYS.forEach(key => {
                    if (key !== statKey) {
                        currentTotalWithoutThisStat += (character.stats[key] || 3);
                    }
                });

                const pointsNeededForThisChange = attemptedNewValue - oldValue; // Wie viele Punkte diese Änderung *mehr* kostet (kann negativ sein)
                const currentPointsSpentOverall = calculateTotalPointsSpentInPointBuy() - oldValue; // Gesamtpunkte ohne den alten Wert dieses Stats
                
                // Wenn der neue Wert den Gesamtpool von 72 sprengen würde:
                if ((currentTotalWithoutThisStat + attemptedNewValue) > TOTAL_POINT_BUY_POINTS) {
                    // Berechne den maximal möglichen Wert für diesen Stat, ohne 72 zu überschreiten
                    let maxPossibleValueForThisStat = TOTAL_POINT_BUY_POINTS - currentTotalWithoutThisStat;
                    maxPossibleValueForThisStat = Math.min(maxPossibleValueForThisStat, 18); // Darf 18 nicht überschreiten
                    maxPossibleValueForThisStat = Math.max(maxPossibleValueForThisStat, 3);   // Darf 3 nicht unterschreiten

                    console.log(`PointBuy Change for ${statKey} to ${attemptedNewValue} would exceed total. Limiting to ${maxPossibleValueForThisStat}`);
                    attemptedNewValue = maxPossibleValueForThisStat;
                    inputElement.value = attemptedNewValue; // Korrigiere den Input im UI
                }

                // Setze den (ggf. korrigierten) neuen Wert
                character.stats[statKey] = attemptedNewValue;
                console.log(`   ${statKey} set to ${character.stats[statKey]}`);

                updatePointBuyUI(); // Aktualisiert Zähler, Prozente und Feature-Anzeige
                updateNavigationButtons(); // Validierung könnte sich geändert haben
            }

            function handlePointBuyAdjustClick(buttonElement) {
                const statKey = buttonElement.dataset.statKey;
                const amount = parseInt(buttonElement.dataset.amount);
                const inputElement = document.getElementById(`pointbuy-${statKey}`);
                
                let currentValue = character.stats[statKey] || 3;
                let newValue = currentValue + amount;

                newValue = Math.max(3, Math.min(18, newValue));

                character.stats[statKey] = newValue;
                if (inputElement) inputElement.value = newValue; // UI synchronisieren
                updatePointBuyUI();
                updateNavigationButtons();
            }

            function updatePointBuyUI() {
                console.log("--- updatePointBuyUI CALLED ---");
                const TOTAL_POINT_BUY_POINTS = 72;

                // 1. Berechne die aktuell ausgegebenen Punkte
                let pointsSpent = 0;
                STAT_KEYS.forEach(key => {
                    // Nimm den Wert aus character.stats; falls nicht vorhanden oder NaN, nutze 3 (Minimalwert)
                    const statVal = parseInt(character.stats[key]); // Sicherstellen, dass es eine Zahl ist
                    pointsSpent += (isNaN(statVal) ? 3 : statVal);
                });
                console.log("updatePointBuyUI - Calculated pointsSpent:", pointsSpent, "Based on character.stats:", JSON.parse(JSON.stringify(character.stats)));

                const pointsRemaining = TOTAL_POINT_BUY_POINTS - pointsSpent;
                console.log("updatePointBuyUI - Points Remaining:", pointsRemaining);

                // 2. Aktualisiere die Hauptanzeige für Punkte
                const pointbuySummaryDiv = document.getElementById('pointbuy-summary');
                if (pointbuySummaryDiv) {
                    console.log("updatePointBuyUI - Found #pointbuy-summary div.");
                    // Erstelle den Text für die Zusammenfassung dynamisch
                    const summaryText = t('pointbuy_points_summary_label', {
                        spent: pointsSpent,
                        total: TOTAL_POINT_BUY_POINTS,
                        remaining: pointsRemaining // pointsRemaining ist das, was noch *zu verteilen* ist
                    });
                    console.log("updatePointBuyUI - New summary text content:", summaryText);

                    // Setze den innerHTML des Spans innerhalb des Summary-Divs
                    // (unter der Annahme, dass das data-i18n-Attribut auf einem inneren Span liegt)
                    const innerSpan = pointbuySummaryDiv.querySelector('span[data-i18n="pointbuy_points_summary_label"]');
                    if (innerSpan) {
                        // Aktualisiere die Replacements für die nächste Übersetzung durch translateAllElements
                        innerSpan.setAttribute('data-i18n-replacements', JSON.stringify({
                            spent: pointsSpent,
                            total: TOTAL_POINT_BUY_POINTS,
                            remaining: pointsRemaining
                        }));
                        innerSpan.textContent = summaryText; // Setze den Text direkt
                        console.log("updatePointBuyUI - Updated inner span of #pointbuy-summary.");
                    } else {
                        // Fallback, falls das innere Span nicht da ist (sollte aber von renderStep2_Statistics erstellt werden)
                        pointbuySummaryDiv.innerHTML = `<span data-i18n="pointbuy_points_summary_label" data-i18n-replacements='${JSON.stringify({spent: pointsSpent, total: TOTAL_POINT_BUY_POINTS, remaining: pointsRemaining})}'>${summaryText}</span>`;
                        console.warn("updatePointBuyUI - Inner span in #pointbuy-summary not found, recreated.");
                    }
                    
                    // Farbliche Hervorhebung des gesamten Summary-Divs
                    if (pointsSpent === TOTAL_POINT_BUY_POINTS) {
                        pointbuySummaryDiv.style.color = 'green';
                        pointbuySummaryDiv.style.borderColor = 'green';
                        console.log("updatePointBuyUI - Summary color set to green (target met).");
                    } else if (pointsSpent > TOTAL_POINT_BUY_POINTS) {
                        pointbuySummaryDiv.style.color = 'red';
                        pointbuySummaryDiv.style.borderColor = 'red';
                        console.log("updatePointBuyUI - Summary color set to red (overspent).");
                    } else { // pointsSpent < TOTAL_POINT_BUY_POINTS
                        pointbuySummaryDiv.style.color = 'orange'; // Oder deine Standardfarbe
                        pointbuySummaryDiv.style.borderColor = 'orange'; // Oder deine Standardfarbe
                        console.log("updatePointBuyUI - Summary color set to orange (points remaining).");
                    }
                } else {
                    console.error("updatePointBuyUI - #pointbuy-summary div NOT FOUND!");
                }

                // 3. Aktualisiere die Prozentwerte und synchronisiere Input-Felder
                STAT_KEYS.forEach(key => {
                    const statValue = character.stats[key] || 3; // Nimm den aktuellen Wert, oder 3 als Fallback
                    console.log(`updatePointBuyUI - Processing stat ${key}: value = ${statValue}`);

                    // Prozentwert aktualisieren
                    const percentileDisplay = document.getElementById(`pointbuy-percentile-${key}`); // KORREKTE ID
                    if (percentileDisplay) {
                        percentileDisplay.textContent = `(${statValue * 5}%)`;
                    } else {
                        console.warn(`updatePointBuyUI - #pointbuy-percentile-${key} span NOT FOUND!`);
                    }

                    // Eingabefeld-Wert synchronisieren (falls Wert in character.stats sich geändert hat)
                    const inputField = document.getElementById(`pointbuy-${key}`);
                    if (inputField) {
                        if (parseInt(inputField.value) !== statValue) {
                            console.log(`updatePointBuyUI - Syncing input field pointbuy-${key} from ${inputField.value} to ${statValue}`);
                            inputField.value = statValue;
                        }
                    } else {
                         console.warn(`updatePointBuyUI - #pointbuy-${key} input field NOT FOUND!`);
                    }
                });
                
                // 4. UI für Distinguishing Features basierend auf den aktuellen Stats aktualisieren/rendern
                console.log("updatePointBuyUI - Calling updatePointBuyDistinguishingFeaturesUI().");
                updatePointBuyDistinguishingFeaturesUI();

                // 5. Navigationsbuttons-Status aktualisieren
                console.log("updatePointBuyUI - Calling updateNavigationButtons().");
                updateNavigationButtons();
                console.log("--- updatePointBuyUI FINISHED ---");
            }

            function updatePointBuyDistinguishingFeaturesUI() {
                const container = document.getElementById('stat-assignment-or-features-container');
                if (!container) return;
                container.innerHTML = ''; // Leeren

                STAT_KEYS.forEach(key => {
                    const statValue = character.stats[key] || 0;
                    if (statValue !== 0 && (statValue < 9 || statValue > 12)) {
                        let featureHtml = `<div class="distinguishing-feature-input-container pointbuy-feature-row">
                                            <label for="feature-${key}" class="distinguishing-feature-label" style="width:150px;">${t('stat_' + key.toLowerCase() + '_name')} - ${t('distinguishing_feature_label')}</label>
                                            <input type="text" id="feature-${key}" class="distinguishing-feature-input" data-stat-key="${key}" 
                                                   placeholder="${t('distinguishing_feature_placeholder')}" 
                                                   value="${character.distinguishingFeatures[key] || ''}" style="flex-grow:1;">
                                        </div>`;
                        container.innerHTML += featureHtml;
                    }
                });
                translateAllElements(container);
            }
            // Dann in attachStep2Listeners:
            function attachStep2Listeners() {
                const methodRadios = document.querySelectorAll('input[name="stat-method"]');
                methodRadios.forEach(radio => {
                    radio.removeEventListener('change', handleStatMethodChange);
                    radio.addEventListener('change', handleStatMethodChange);
                });

                const arrayOptionRadios = document.querySelectorAll('input[name="stat-array-option"]');
                arrayOptionRadios.forEach(radio => {
                    radio.removeEventListener('change', handleSpecificArraySelectionChange);
                    radio.addEventListener('change', handleSpecificArraySelectionChange);
                });

                const btnRoll = document.getElementById('btn-roll-stats');
                if (btnRoll) {
                    btnRoll.removeEventListener('click', handleRollStatsClick);
                    btnRoll.addEventListener('click', handleRollStatsClick);
                }

                const pointbuyContainer = document.getElementById('stat-pointbuy-container');
                if (pointbuyContainer) {
                    pointbuyContainer.removeEventListener('input', pointBuyInputDelegationHandler);
                    pointbuyContainer.addEventListener('input', pointBuyInputDelegationHandler);
                }

                const manualEntryContainer = document.getElementById('stat-manual-entry-container');
                if (manualEntryContainer) {
                    manualEntryContainer.removeEventListener('input', manualEntryInputDelegationHandler);
                    manualEntryContainer.addEventListener('input', manualEntryInputDelegationHandler);
                }
                
                const assignmentOrFeaturesContainer = document.getElementById('stat-assignment-or-features-container');
                if (assignmentOrFeaturesContainer) {
                    assignmentOrFeaturesContainer.removeEventListener('input', sharedFeatureInputDelegationHandler);
                    assignmentOrFeaturesContainer.addEventListener('input', sharedFeatureInputDelegationHandler);

                    assignmentOrFeaturesContainer.removeEventListener('change', sharedStatSelectDelegationHandler);
                    assignmentOrFeaturesContainer.addEventListener('change', sharedStatSelectDelegationHandler);
                }

                if (character.statGenerationMethod === 'array') {
                    if (character.statArrayChoice !== null) {
                        updateStatAssignmentUI();
                    } else {
                        if (assignmentOrFeaturesContainer) assignmentOrFeaturesContainer.innerHTML = `<p>${t('alert_select_stat_array')}</p>`;
                    }
                } else if (character.statGenerationMethod === 'roll') {
                    if (character.rolledStatValues.length === 6) {
                        updateStatAssignmentUI();
                    } else {
                        if (assignmentOrFeaturesContainer) assignmentOrFeaturesContainer.innerHTML = `<p>${t('click_to_roll_stats_label')}</p>`;
                    }
                } else if (character.statGenerationMethod === 'pointbuy') {
                    updatePointBuyUI();
                } else if (character.statGenerationMethod === 'manual') {
                    updateManualEntryUI();
                } else {
                    if (assignmentOrFeaturesContainer) assignmentOrFeaturesContainer.innerHTML = `<p>${t('step2_select_method_prompt')}</p>`;
                }
                updateNavigationButtons();
            }
            function pointBuyInputDelegationHandler(event) { // Neuer Name für den Delegations-Handler
                if (event.target.classList.contains('pointbuy-stat-input')) {
                    handlePointBuyInputChange(event.target); // Ruft deinen bestehenden Logik-Handler auf
                }
            }

            function sharedFeatureInputDelegationHandler(event) { // Neuer Name
                 if (event.target.classList.contains('distinguishing-feature-input')) {
                    const statKey = event.target.dataset.statKey;
                    character.distinguishingFeatures[statKey] = event.target.value;
                }
            }

            function sharedStatSelectDelegationHandler(event) { // Neuer Name
                if (event.target.classList.contains('stat-value-select')) {
                    handleStatValueAssignmentChange(event.target);
                }
            }

            function handleStatMethodChange(event) {
                const newMethod = event.target.value;
                if (character.statGenerationMethod === newMethod && newMethod !== "") return;

                character.statGenerationMethod = newMethod;
                character.statArrayChoice = null;
                character.rolledStatValues = [];
                character.statAssignments = {};
                character.distinguishingFeatures = {};

                if (newMethod === 'pointbuy') {
                    STAT_KEYS.forEach(key => { character.stats[key] = 3; });
                } else if (newMethod === 'manual') {
                    STAT_KEYS.forEach(key => { character.stats[key] = 10; });
                } else {
                    STAT_KEYS.forEach(key => character.stats[key] = 0);
                }
                renderCurrentStep();
            }


            function handleSpecificArraySelectionChange(event) {
                // Dieser Handler ist für die Radio-Buttons der vordefinierten Arrays
                character.statArrayChoice = parseInt(event.target.value);
                // Reset Zuweisungen, wenn neues Array gewählt wird
                character.statAssignments = {};
                STAT_KEYS.forEach(key => character.stats[key] = 0);
                character.distinguishingFeatures = {};
                updateStatAssignmentUI();
                updateNavigationButtons();
            }

            function handleRollStatsClick() {
                generateRolledStatsArray(); // Generiert und speichert Werte in character.rolledStatValues, resettet Zuweisungen
                
                // Anzeige der gewürfelten Werte aktualisieren
                const displayDiv = document.getElementById('rolled-stats-display');
                if (displayDiv) {
                    displayDiv.innerHTML = `<span data-i18n="rolled_values_label">${t('rolled_values_label')}</span> ${character.rolledStatValues.join(', ')}`;
                    translateAllElements(displayDiv); // Für den Fall, dass das Label neu übersetzt werden muss
                }
                updateStatAssignmentUI(); // Baut die Dropdowns für die Zuweisung neu auf
                updateNavigationButtons();
            }

            function handleStatValueAssignmentChange(selectElement) {
                const statKey = selectElement.dataset.statKey;
                const selectedValue = selectElement.value === "" ? null : parseInt(selectElement.value);

                // Alte Zuweisung für diesen Stat entfernen, falls vorhanden und Wert geändert wird
                const oldAssignedValue = character.statAssignments[statKey];
                character.statAssignments[statKey] = selectedValue; // Neue Zuweisung speichern

                // Haupt-Stat im character-Objekt aktualisieren
                character.stats[statKey] = selectedValue !== null ? selectedValue : 0;

                updateStatAssignmentUI(); // Um Dropdowns und Anzeigen zu aktualisieren
                updateNavigationButtons();
            }
            
            function updateStatAssignmentUI() {
                console.log("--- updateStatAssignmentUI CALLED --- Method:", character.statGenerationMethod, "ArrayChoice:", character.statArrayChoice, "RolledValuesLen:", character.rolledStatValues.length);
                const container = document.getElementById('stat-assignment-or-features-container');
                if (!container) {
                    console.error("updateStatAssignmentUI: Container #stat-assignment-or-features-container NOT FOUND");
                    return;
                }

                let sourceArrayForAssignment = null;
                if (character.statGenerationMethod === 'array' && character.statArrayChoice !== null) {
                    sourceArrayForAssignment = STAT_ARRAYS[character.statArrayChoice];
                } else if (character.statGenerationMethod === 'roll' && character.rolledStatValues.length === 6) {
                    sourceArrayForAssignment = character.rolledStatValues;
                }
                console.log("updateStatAssignmentUI - sourceArrayForAssignment:", JSON.parse(JSON.stringify(sourceArrayForAssignment)));

                if (!sourceArrayForAssignment) {
                    console.log("updateStatAssignmentUI - sourceArrayForAssignment IS NULL or empty. Displaying prompt.");
                    if (character.statGenerationMethod === 'array') {
                        container.innerHTML = `<p>${t('alert_select_stat_array')}</p>`;
                    } else if (character.statGenerationMethod === 'roll') {
                        container.innerHTML = `<p>${t('click_to_roll_stats_label')}</p>`;
                    } else {
                        container.innerHTML = `<p>${t('step2_select_method_prompt')}</p>`;
                    }
                    translateAllElements(container); // Wichtig für die Prompts
                    updateNavigationButtons();
                    return;
                }

                console.log("updateStatAssignmentUI - Clearing container and preparing to build rows.");
                container.innerHTML = ''; // Leere für Neuaufbau

                const chosenArrayBaseForLogic = sourceArrayForAssignment; // Umbenennen für Klarheit in der bestehenden Logik

                STAT_KEYS.forEach(currentStatKey => { // Für jeden Stat (STR, CON, etc.), für den wir ein Dropdown bauen
                    console.log(`updateStatAssignmentUI - Building row for ${currentStatKey}`); // NEUER LOG
                    const currentAssignedValueForThisStat = character.statAssignments[currentStatKey];
                    const statValue = character.stats[currentStatKey] || 0;
                    const percentile = statValue * 5;
                    const showFeatureInput = statValue !== 0 && (statValue < 9 || statValue > 12);

                    let workingArray = [...chosenArrayBaseForLogic];
                    STAT_KEYS.forEach(otherStatKey => {
                        if (otherStatKey !== currentStatKey) {
                            const valAssignedToOtherStat = character.statAssignments[otherStatKey];
                            if (valAssignedToOtherStat !== null && valAssignedToOtherStat !== undefined) {
                                const indexToRemove = workingArray.indexOf(valAssignedToOtherStat);
                                if (indexToRemove > -1) {
                                    workingArray.splice(indexToRemove, 1);
                                }
                            }
                        }
                    });
                    const sortedWorkingArray = [...workingArray].sort((a, b) => b - a);

                    let rowHtml = `<div class="stat-allocation-row">
                        <label for="stat-select-${currentStatKey}">${t('stat_' + currentStatKey.toLowerCase() + '_name')}</label>
                        <select id="stat-select-${currentStatKey}" class="stat-value-select" data-stat-key="${currentStatKey}">
                            <option value="">-- ${t('select_one_option')} --</option>`;

                    sortedWorkingArray.forEach(val => {
                        rowHtml += `<option value="${val}" ${currentAssignedValueForThisStat === val ? 'selected' : ''}>${val}</option>`;
                    });

                    rowHtml += `</select>
                        <span class="stat-percentile" id="percentile-${currentStatKey}">${percentile}%</span>
                    </div>`; // Ende .stat-allocation-row

                    // Stelle sicher, dass die ID hier `percentile-${currentStatKey}` ist (OHNE "pointbuy-")
                    // für Array/Roll, das scheinst du schon so zu haben.

                    if (showFeatureInput) {
                         rowHtml += `<div class="distinguishing-feature-input-container">
                                        <label for="feature-${currentStatKey}" class="distinguishing-feature-label">${t('distinguishing_feature_label')}</label>
                                        <input type="text" id="feature-${currentStatKey}" class="distinguishing-feature-input" data-stat-key="${currentStatKey}"
                                               placeholder="${t('distinguishing_feature_placeholder')}"
                                               value="${character.distinguishingFeatures[currentStatKey] || ''}">
                                    </div>`;
                    }
                    // console.log(`updateStatAssignmentUI - Generated rowHtml for ${currentStatKey}:`, rowHtml.substring(0,100) + "..."); // Logge nur einen Teil
                    container.innerHTML += rowHtml; // Füge die Zeile zum Container hinzu
                });
                console.log("updateStatAssignmentUI - Finished building rows. Final container innerHTML length:", container.innerHTML.length);
                translateAllElements(container);
                updateNavigationButtons(); // Wichtig
            }
            function rollDie(sides = 6) {
                return Math.floor(Math.random() * sides) + 1;
            }

            function roll4d6DropLowest() {
                const rolls = [rollDie(), rollDie(), rollDie(), rollDie()];
                rolls.sort((a, b) => a - b); // Sortiere aufsteigend
                rolls.shift(); // Entferne den niedrigsten (ersten)
                return rolls.reduce((sum, current) => sum + current, 0); // Summiere die restlichen drei
            }

            function generateRolledStatsArray() {
                character.rolledStatValues = [];
                for (let i = 0; i < 6; i++) {
                    character.rolledStatValues.push(roll4d6DropLowest());
                }
                // Sortiere die gewürfelten Werte optional absteigend für konsistente Anzeige/Vergleichbarkeit
                character.rolledStatValues.sort((a, b) => b - a);
                
                // Wichtig: Wenn neue Stats gewürfelt werden, müssen alte Zuweisungen und Stats zurückgesetzt werden!
                character.statAssignments = {};
                STAT_KEYS.forEach(key => character.stats[key] = 0);
                character.distinguishingFeatures = {};
            }
            
            function validateStep2(showAlerts = true) {
                if (!character.statGenerationMethod) {
                    if (showAlerts) alert(t('alert_select_stat_method'));
                    return false;
                }

                let sourceArrayForValidation = null;

                if (character.statGenerationMethod === 'array') {
                    if (character.statArrayChoice === null) {
                        if (showAlerts) alert(t('alert_select_stat_array'));
                        return false;
                    }
                    sourceArrayForValidation = STAT_ARRAYS[character.statArrayChoice];
                } else if (character.statGenerationMethod === 'roll') {
                    if (character.rolledStatValues.length !== 6) {
                        if (showAlerts) alert(t('click_to_roll_stats_label'));
                        return false;
                    }
                    sourceArrayForValidation = character.rolledStatValues;
                } else if (character.statGenerationMethod === 'pointbuy') {
                    const TOTAL_POINT_BUY_POINTS = 72;
                    const pointsSpent = calculateTotalPointsSpentInPointBuy();
                    if (pointsSpent !== TOTAL_POINT_BUY_POINTS) {
                        if (showAlerts) alert(t('pointbuy_error_total_points', { spent: pointsSpent, total: TOTAL_POINT_BUY_POINTS }));
                        return false;
                    }
                    let invalidStatFound = false;
                    STAT_KEYS.forEach(key => {
                        const val = character.stats[key] || 0;
                        if (val < 3 || val > 18) { invalidStatFound = true; }
                    });
                    if (invalidStatFound) {
                        if (showAlerts) alert(t('pointbuy_error_stat_range'));
                        return false;
                    }
                    return true;
                } else if (character.statGenerationMethod === 'manual') {
                    let invalidStatFoundManual = false;
                    STAT_KEYS.forEach(key => {
                        const val = character.stats[key] || 0;
                        if (val < 3 || val > 18) { invalidStatFoundManual = true; }
                    });
                    if (invalidStatFoundManual) {
                        if (showAlerts) alert(t('manual_entry_error_stat_range'));
                        return false;
                    }
                    return true;
                } else {
                    if (showAlerts) alert(t('alert_select_stat_method'));
                    return false;
                }

                const assignedStatValues = Object.values(character.statAssignments);
                if (assignedStatValues.some(val => val === null || val === undefined) || assignedStatValues.length < STAT_KEYS.length) {
                    if (showAlerts) alert(t('alert_assign_all_stats'));
                    return false;
                }

                const chosenArraySorted = [...sourceArrayForValidation].sort((a, b) => a - b);
                const currentAssignmentsSorted = [...assignedStatValues].sort((a, b) => a - b);

                if (chosenArraySorted.length !== currentAssignmentsSorted.length) {
                    return false;
                }
                for (let i = 0; i < chosenArraySorted.length; i++) {
                    if (chosenArraySorted[i] !== currentAssignmentsSorted[i]) {
                        if (showAlerts) alert(t('alert_unique_stat_values'));
                        return false;
                    }
                }
                return true;
            }

            function saveStep2() {
                // Die Werte sind bereits in character.stats und character.distinguishingFeatures durch die Handler.
                // character.statAssignments ist ein Hilfsobjekt für die UI-Logik dieses Schritts.
                // console.log("Step 2 Data Saved:", JSON.parse(JSON.stringify(character.stats)), JSON.parse(JSON.stringify(character.distinguishingFeatures)));
            }
            function calculateDerivedAttributes() {
                const stats = character.stats;
                if (!stats.STR || !stats.CON || !stats.POW) { // Stelle sicher, dass Basis-Stats vorhanden sind
                    // console.warn("Cannot calculate derived attributes: Primary stats not fully set.");
                    character.derivedAttributes = { HP: 0, WP: 0, SAN: 0, BP: 0 }; // Setze auf 0, falls nicht berechenbar
                    return;
                }

                const HP = Math.ceil((stats.STR + stats.CON) / 2);
                const WP = stats.POW;
                const SAN = stats.POW * 5;
                const BP = SAN - stats.POW;

                character.derivedAttributes = {
                    HP: HP,
                    WP: WP,
                    SAN: SAN,
                    BP: BP
                };
            }


            // STEP 3: DERIVED ATTRIBUTES
            function renderStep3_DerivedAttributes() {
                calculateDerivedAttributes(); // Sicherstellen, dass die Werte aktuell sind
                const derived = character.derivedAttributes;

                let html = `<div class="step" id="step3-derived-attributes">
                    <h2 data-i18n="step3_info_derived_title"></h2>
                    <div class="info-box">
                        <p data-i18n="step3_info_derived_intro"></p>
                    </div>
                    
                    <div class="derived-attributes-display">
                        <div class="derived-attr-header derived-attr-row">
                            <strong data-i18n="derived_attribute_label"></strong>
                            <strong data-i18n="derived_value_label"></strong>
                            <strong data-i18n="derived_description_label"></strong>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_hp_name"></span>
                            <span>${derived.HP}</span>
                            <span data-i18n="attr_hp_desc"></span>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_wp_name"></span>
                            <span>${derived.WP}</span>
                            <span data-i18n="attr_wp_desc"></span>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_san_name"></span>
                            <span>${derived.SAN}</span>
                            <span data-i18n="attr_san_desc"></span>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_bp_name"></span>
                            <span>${derived.BP}</span>
                            <span data-i18n="attr_bp_desc"></span>
                        </div>
                    </div>
                </div>`;

                // CSS für die Flexbox-Darstellung
                html += `<style>
                    .derived-attributes-display { 
                        margin-top: 20px; 
                        border-top: 1px solid #ccc; /* Trennlinie über der Tabelle */
                    }
                    .derived-attr-row {
                        display: flex; /* Jede Zeile ist ein Flex-Container */
                        align-items: flex-start; /* Vertikale Ausrichtung oben */
                        padding: 10px 0; /* Etwas vertikaler Abstand */
                        border-bottom: 1px dotted #eee;
                    }
                    .derived-attr-row:last-child {
                        border-bottom: none;
                    }
                    /* Styling für die Kinder der Zeilen (also die Spalten-Elemente) */
                    .derived-attr-row > * { 
                        box-sizing: border-box; /* Stellt sicher, dass Padding nicht die Breite erhöht */
                    }
                    .derived-attr-row > :nth-child(1) { /* 1. Spalte: Attributname */
                        flex-basis: 200px;  /* Gib dem Namen etwas mehr Platz, oder max-content */
                        flex-shrink: 0;     /* Verhindert, dass es schrumpft */
                        font-weight: bold;
                        text-align: right;
                        padding-right: 15px; /* Abstand zum Wert */
                    }
                    .derived-attr-row > :nth-child(2) { /* 2. Spalte: Wert */
                        flex-basis: 60px;   /* Feste Breite für den Wert */
                        flex-shrink: 0;
                        font-weight: bold;
                        text-align: center;
                    }
                    .derived-attr-row > :nth-child(3) { /* 3. Spalte: Beschreibung */
                        flex-grow: 1;       /* Nimmt den restlichen Platz ein */
                        font-size: 0.9em;
                        color: #555;        /* Etwas dunklerer Text für bessere Lesbarkeit */
                        padding-left: 15px;  /* Abstand vom Wert */
                        line-height: 1.4;   /* Verbessert Lesbarkeit bei längeren Beschreibungen */
                    }
                    .derived-attr-header > strong {
                         font-weight: bold; /* Stellt sicher, dass Header-Text fett ist (überschreibt ggf. nth-child) */
                         color: #333;      /* Dunklerer Header-Text */
                    }
                    /* Spezifische Ausrichtung für Header-Elemente, falls nötig (meist schon durch obige Regeln abgedeckt) */
                    .derived-attr-header > :nth-child(1) { text-align: right; }
                    .derived-attr-header > :nth-child(2) { text-align: center; }
                    .derived-attr-header > :nth-child(3) { text-align: left; }
                </style>`;

                return html;
            }

            // Für Schritt 3 sind keine spezifischen Listener notwendig, da es eine reine Anzeige ist.
            function attachStep3Listeners() {
                // Leer, oder ggf. Listener, falls man später Interaktionen hinzufügen möchte.
            }
            
            function validateStep3() {
                // Keine Nutzereingaben, die validiert werden müssen.
                // Wir könnten prüfen, ob die abgeleiteten Attribute berechnet wurden,
                // aber das passiert in renderStep3_DerivedAttributes.
                return true;
            }

            function saveStep3() {
                // Die Werte wurden bereits in character.derivedAttributes durch calculateDerivedAttributes() gespeichert,
                // welches in renderStep3_DerivedAttributes() aufgerufen wird.
                // console.log("Step 3 Data (Derived Attributes):", JSON.parse(JSON.stringify(character.derivedAttributes)));
            }
            // STEP 4: BONDS & MOTIVATIONS
            function renderStep4_BondsMotivations() {
                // 1. Bestimme die Anzahl der Bonds und den Startwert
                let numberOfBonds = 0;
                const chaScore = character.stats.CHA || 0; // Fallback auf 0, falls CHA noch nicht gesetzt

                if (character.isCustomProfession) {
                    numberOfBonds = character.customProfessionBonds;
                } else if (character.professionKey && PROFESSIONS[character.professionKey]) {
                    numberOfBonds = PROFESSIONS[character.professionKey].bonds;
                } else {
                    // Fallback, sollte nicht oft eintreten, wenn Schritt 1 valide ist
                    // Man könnte hier auch eine Standardanzahl nehmen oder eine Warnung ausgeben.
                    // Für den Moment: 0, dann wird keine Bond-Eingabe gerendert, wenn kein Beruf.
                }

                // 2. Stelle sicher, dass das character.bonds Array die korrekte Länge hat
                // und die Scores initialisiert sind.
                // Wir erstellen das Array neu, um die richtige Anzahl sicherzustellen.
                // Bereits eingegebene Beschreibungen versuchen wir zu erhalten.
                const oldBonds = [...character.bonds]; // Kopie der alten Bonds
                character.bonds = [];
                for (let i = 0; i < numberOfBonds; i++) {
                    character.bonds.push({
                        description: oldBonds[i]?.description || "", // Behalte alte Beschreibung, wenn möglich
                        score: chaScore // Setze Score basierend auf aktuellem CHA
                    });
                }
                
                // Stelle sicher, dass character.motivations ein Array von 5 Strings ist
                if (!Array.isArray(character.motivations) || character.motivations.length !== 5) {
                    const oldMotivations = Array.isArray(character.motivations) ? [...character.motivations] : [];
                    character.motivations = ["", "", "", "", ""];
                    for(let i=0; i < 5; i++) {
                        if(oldMotivations[i]) character.motivations[i] = oldMotivations[i];
                    }
                }


                let html = `<div class="step" id="step4-bonds-motivations">
                    <h2 data-i18n="step4_title_bonds_motivations"></h2>
                    <div class="info-box">
                        <p data-i18n="step4_info_bonds_mot_intro"></p>
                    </div>

                    <!-- === BONDS === -->
                    <h3 data-i18n="step4_1_bonds_title"></h3>
                    <div class="info-box">
                        <p data-i18n="step4_info_bonds1"></p>
                        <p data-i18n="step4_info_bonds2"></p>
                        <p data-i18n="step4_info_bonds3"></p>
                        <p data-i18n="step4_info_bonds4"></p>
                        <strong data-i18n="bond_examples_label"></strong>
                        <p><small data-i18n="bond_examples_list"></small></p>
                    </div>`;

                if (numberOfBonds > 0) {
                    html += `<p data-i18n="num_bonds_for_profession" data-i18n-replacements='{"count":"${numberOfBonds}"}'>${t('num_bonds_for_profession', {count: numberOfBonds})}</p>`;
                    html += `<div id="bonds-input-container">`;
                    for (let i = 0; i < numberOfBonds; i++) {
                        html += `<div class="bond-entry">
                                    <label for="bond-desc-${i}" data-i18n="bond_label_number" data-i18n-replacements='{"number":"${i + 1}"}'>${t('bond_label_number', {number: i+1})}</label>
                                    <input type="text" id="bond-desc-${i}" class="bond-description-input" data-bond-index="${i}" 
                                           value="${character.bonds[i]?.description || ''}" 
                                           placeholder="${t('bond_description_placeholder')}">
                                    <span data-i18n="bond_score_label"></span> <span>${chaScore}</span>
                                 </div>`;
                    }
                    html += `</div>`;
                } else {
                    html += `<p><em>No bonds available for the current profession selection or CHA score not yet set.</em></p>`; // Fallback-Text
                }
                
                html += `<!-- === MOTIVATIONS === -->
                    <h3 data-i18n="step4_2_motivations_title" style="margin-top: 30px;"></h3>
                    <div class="info-box">
                        <p data-i18n="step4_info_motivations1"></p>
                        <p data-i18n="step4_info_motivations2"></p>
                        <p data-i18n="step4_info_motivations3"></p>
                    </div>
                    <div id="motivations-input-container">`;
                for (let i = 0; i < 5; i++) {
                    html += `<div class="motivation-entry">
                                <label for="motivation-${i}" data-i18n="motivation_label_number" data-i18n-replacements='{"number":"${i + 1}"}'>${t('motivation_label_number', {number: i+1})}</label>
                                <input type="text" id="motivation-${i}" class="motivation-input" data-motivation-index="${i}" 
                                       value="${character.motivations[i] || ''}" 
                                       placeholder="${t('motivation_placeholder')}">
                             </div>`;
                }
                html += `</div></div>`;
                return html;
            }

            function attachStep4Listeners() {
                const bondsContainer = document.getElementById('bonds-input-container');
                if (bondsContainer) {
                    bondsContainer.addEventListener('input', (event) => {
                        if (event.target.classList.contains('bond-description-input')) {
                            const index = parseInt(event.target.dataset.bondIndex);
                            if (character.bonds[index]) {
                                character.bonds[index].description = event.target.value;
                            }
                        }
                    });
                }

                const motivationsContainer = document.getElementById('motivations-input-container');
                if (motivationsContainer) {
                    motivationsContainer.addEventListener('input', (event) => {
                        if (event.target.classList.contains('motivation-input')) {
                            const index = parseInt(event.target.dataset.motivationIndex);
                            if (character.motivations && character.motivations[index] !== undefined) {
                                character.motivations[index] = event.target.value;
                            }
                        }
                    });
                }
            }
            
            function validateStep4(showAlerts = true) {
                // Optional: Prüfen, ob Bond-Beschreibungen ausgefüllt sind, falls das Pflicht sein soll.
                // Für den Moment gehen wir davon aus, dass leere Bond-Beschreibungen okay sind.
                // Man könnte hier prüfen, ob chaScore > 0 ist, falls das eine Voraussetzung wäre,
                // aber die Hauptvalidierung für Stats war in Schritt 2.
                return true; 
            }

            function saveStep4() {
                // Die Daten (Bond-Beschreibungen, Bond-Scores, Motivationen) werden bereits
                // durch die Event-Listener (für Beschreibungen/Motivationen) und beim Rendern
                // (für Scores und Anzahl der Bonds) im character-Objekt aktualisiert.
                // Hier könnte man noch einmal sicherstellen, dass die Bond-Scores aktuell sind.
                const chaScore = character.stats.CHA || 0;
                character.bonds.forEach(bond => bond.score = chaScore);
                // console.log("Step 4 Data Saved:", JSON.parse(JSON.stringify(character.bonds)), JSON.parse(JSON.stringify(character.motivations)));
            }
            // STEP 5: SUMMARY
            function renderStep5_Summary() {
                calculateDerivedAttributes();
                let professionDisplayName = t('not_selected');
                if (character.professionKey) {
                    if (character.professionKey === 'custom_profession') {
                        professionDisplayName = character.customProfessionName.trim() !== "" ? character.customProfessionName : t(PROFESSIONS.custom_profession.nameKey);
                    } else if (PROFESSIONS[character.professionKey]) {
                        professionDisplayName = t(PROFESSIONS[character.professionKey].nameKey);
                    } else {
                        professionDisplayName = character.professionKey.replace(/_/g, ' ');
                    }
                }

                let html = `<div class="step" id="step5-summary">
                    <h2 data-i18n="summary_title"></h2>

                    <div class="summary-block summary-block-personal-data">
                        <h3 class="summary-block-title" data-i18n="summary_section_personal_details"></h3>
                        <div class="summary-personal-grid">
                            <div><strong data-i18n="summary_label_name"></strong> <span class="placeholder-field long"></span></div>
                            <div><strong data-i18n="summary_label_profession"></strong> <span class="value-field">${professionDisplayName}</span></div>
                            <div><strong data-i18n="summary_label_employer"></strong> <span class="placeholder-field long"></span></div>
                            <div><strong data-i18n="summary_label_nationality"></strong> <span class="placeholder-field"></span></div>
                            <div><strong data-i18n="summary_label_sex"></strong> <span class="placeholder-field short"></span></div>
                            <div><strong data-i18n="summary_label_age_dob"></strong> <span class="placeholder-field"></span></div>
                        </div>
                    </div>

                    <div class="summary-grid-stats-psych">
                        <div class="summary-block summary-block-statistical-data">
                            <h3 class="summary-block-title" data-i18n="summary_label_statistical_data"></h3>
                            <h4 class="summary-subsection-title" data-i18n="summary_section_statistics"></h4>
                            <table class="summary-table summary-stats-table">
                                <thead>
                                    <tr>
                                        <th data-i18n="summary_col_statistic"></th>
                                        <th data-i18n="summary_col_score"></th>
                                        <th data-i18n="summary_col_x5"></th>
                                        <th data-i18n="summary_col_features"></th>
                                    </tr>
                                </thead>
                                <tbody>`;
                STAT_KEYS.forEach(key => {
                    const statName = t('stat_' + key.toLowerCase() + '_name').replace(/\s\(.*\)/, '');
                    const statValue = character.stats[key] || 0;
                    const percentile = statValue * 5;
                    const feature = character.distinguishingFeatures[key] || "---";
                    html += `<tr>
                                <td>${statName} (${key})</td>
                                <td class="value-cell">${statValue}</td>
                                <td class="value-cell">${percentile}%</td>
                                <td>${feature}</td>
                             </tr>`;
                });
                html += `       </tbody>
                            </table>
                            <h4 class="summary-subsection-title" data-i18n="summary_section_derived_attr"></h4>
                            <table class="summary-table summary-derived-table">
                                <thead>
                                    <tr>
                                        <th data-i18n="summary_col_derived_attribute"></th>
                                        <th data-i18n="summary_col_maximum_value"></th>
                                        <th data-i18n="summary_col_current_value"></th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td data-i18n="attr_hp_name"></td>
                                        <td class="value-cell">${character.derivedAttributes.HP}</td>
                                        <td class="placeholder-cell"></td>
                                    </tr>
                                    <tr>
                                        <td data-i18n="attr_wp_name"></td>
                                        <td class="value-cell">${character.derivedAttributes.WP}</td>
                                        <td class="placeholder-cell"></td>
                                    </tr>
                                    <tr>
                                        <td data-i18n="attr_san_name"></td>
                                        <td class="value-cell">${character.derivedAttributes.SAN}</td>
                                        <td class="placeholder-cell"></td>
                                    </tr>
                                    <tr>
                                        <td data-i18n="attr_bp_name"></td>
                                        <td class="value-cell">${character.derivedAttributes.BP}</td>
                                        <td class="placeholder-cell"></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="summary-block summary-block-psychological-data">
                            <h3 class="summary-block-title" data-i18n="summary_label_psychological_data"></h3>
                            <h4 class="summary-subsection-title" data-i18n="summary_section_bonds"></h4>
                            <ul class="summary-list">`;
                if (character.bonds && character.bonds.length > 0) {
                    character.bonds.forEach((bond) => {
                        html += `<li><strong>${bond.description || `(${t('not_defined')})`}</strong>: <span class="value-highlight">${bond.score}</span></li>`;
                    });
                } else { html += `<li><em>${t('not_defined')}</em></li>`; }
                html += `       </ul>
                            <h4 class="summary-subsection-title" data-i18n="summary_section_motivations"></h4>
                            <ul class="summary-list">`;
                const definedMotivations = character.motivations.filter(m => m && m.trim() !== "");
                if (definedMotivations.length > 0) {
                    definedMotivations.forEach((motivation) => { html += `<li>${motivation}</li>`; });
                } else { html += `<li><em>${t('not_defined')}</em></li>`; }
                html += `       </ul>
                        </div>
                    </div>

                    <div class="summary-block summary-block-skills">
                        <h3 class="summary-block-title" data-i18n="summary_section_skills"></h3>
                        <div class="summary-skills-multicolumn">`;
                
                // === BEGINN DER KORRIGIERTEN SKILL-AUSGABE ===
                const allCharacterSkills = [];
                if (Array.isArray(character.skills)) {
                    character.skills.forEach(skillInstance => {
                        const baseSkillData = ALL_SKILLS[skillInstance.key];
                        if (!baseSkillData) return;
                        let displayName = t(baseSkillData.nameKey);
                        if (skillInstance.typeName && skillInstance.typeName.trim() !== "") {
                            displayName += ` (${skillInstance.typeName.trim()})`;
                        }
                        const valueFromIncreasesOrProf = skillInstance.value - baseSkillData.base;
                        const isRelevant = valueFromIncreasesOrProf > 0 || 
                                           skillInstance.isProfessional || 
                                           skillInstance.isChoiceSkill || 
                                           (baseSkillData.type && skillInstance.typeName && skillInstance.typeName.trim() !== "") ||
                                           (skillInstance.value > 0 && skillInstance.value === baseSkillData.base && !baseSkillData.type); // Zeige auch unveränderte nicht-typisierte Skills > 0

                        if (isRelevant) {
                             allCharacterSkills.push({ name: displayName, value: skillInstance.value, base: baseSkillData.base });
                        }
                    });
                }
                allCharacterSkills.sort((a, b) => a.name.localeCompare(b.name, currentLanguage));

                if (allCharacterSkills.length > 0) {
                    html += `<ul class="skills-flat-list">`; // Nur EINE UL mit dieser Klasse
                    allCharacterSkills.forEach(skill => {
                        const isModified = skill.value !== skill.base;
                        const baseDisplayValue = (skill.base > 0 || isModified) ? `(${skill.base}%)` : ""; // Zeige Basis nur wenn >0 oder wenn modifiziert
                        const baseDisplaySpan = isModified ? ` <span class="base-value">${baseDisplayValue}</span>` : "";
                        const displayValue = isModified ? `<strong>${skill.value}%</strong>${baseDisplaySpan}` : `${skill.value}%`;
                        html += `<li>${skill.name}: ${displayValue}</li>`;
                    });
                    html += `</ul>`;
                } else { 
                    html += `<p><em>${t('no_skills_available')}</em></p>`; 
                }
                // === ENDE DER KORRIGIERTEN SKILL-AUSGABE ===

                html += `   </div>
                    </div>

                    <div class="summary-actions" style="margin-top: 30px;">
                        <button id="btn-print-summary" class="action-button" data-i18n="btn_print_summary"></button>
                    </div>
                </div>`;
                return html;
            }

            function attachStep5Listeners() {
                const btnPrint = document.getElementById('btn-print-summary');
                if (btnPrint) {
                    btnPrint.addEventListener('click', () => {
                        window.print();
                    });
                }

                // const btnDownload = document.getElementById('btn-download-txt');
                // if (btnDownload) {
                //     btnDownload.addEventListener('click', generateAndDownloadTxtSummary);
                // }
            }

            // function generateAndDownloadTxtSummary() {
            //     let summaryText = `${t('summary_title')}\n\n`;

            //     summaryText += `== ${t('summary_section_personal_details')} ==\n`;
            //     summaryText += `${t('summary_placeholder_name')}\n`;
            //     summaryText += `${t('summary_placeholder_age')}\n`;
            //     summaryText += `${t('summary_placeholder_sex')}\n\n`;

            //     summaryText += `== ${t('summary_section_profession')} ==\n`;
            //     let professionDisplayNameTxt = t('not_selected');
            //     if (character.professionKey) {
            //         if (character.professionKey === 'custom_profession') {
            //             professionDisplayNameTxt = character.customProfessionName.trim() !== "" ? character.customProfessionName : t(PROFESSIONS.custom_profession.nameKey);
            //         } else if (PROFESSIONS[character.professionKey]) {
            //             professionDisplayNameTxt = t(PROFESSIONS[character.professionKey].nameKey);
            //         } else {
            //             professionDisplayNameTxt = character.professionKey.replace(/_/g, ' ');
            //         }
            //     }
            //     summaryText += `${professionDisplayNameTxt}\n\n`;

            //     summaryText += `== ${t('summary_section_statistics')} ==\n`;
            //     STAT_KEYS.forEach(key => {
            //         const statName = t('stat_' + key.toLowerCase() + '_name');
            //         const statValue = character.stats[key] || 0;
            //         const percentile = statValue * 5;
            //         const feature = character.distinguishingFeatures[key] || "";
            //         summaryText += `${statName}: ${statValue} (${percentile}%) ${feature ? `(${feature})` : ''}\n`;
            //     });
            //     summaryText += "\n";

            //     summaryText += `== ${t('summary_section_derived_attr')} ==\n`;
            //     summaryText += `${t('attr_hp_name')}: ${character.derivedAttributes.HP}\n`;
            //     summaryText += `${t('attr_wp_name')}: ${character.derivedAttributes.WP}\n`;
            //     summaryText += `${t('attr_san_name')}: ${character.derivedAttributes.SAN}\n`;
            //     summaryText += `${t('attr_bp_name')}: ${character.derivedAttributes.BP}\n\n`;

            //     summaryText += `== ${t('summary_section_skills')} ==\n`;
            //     const relevantSkills = []; // Dieselbe Logik wie in renderStep5_Summary
            //     for (const skillKey in character.skills) { /* ... */ } // (Code kopieren)
            //     // ... (Schleife kopieren und anpassen für Textausgabe)
            //      for (const skillKey in character.skills) {
            //         const skill = character.skills[skillKey];
            //         const baseSkillData = ALL_SKILLS[skillKey];
            //         if (skill.value > baseSkillData.base || skill.increases > 0 || skill.isProfessional || skill.isChoiceSkill || (baseSkillData.type && skill.typeName)) {
            //             let displayName = t(baseSkillData.nameKey);
            //             if (baseSkillData.type && skill.typeName && skill.typeName.trim() !== "") {
            //                 displayName += ` (${skill.typeName.trim()})`;
            //             }
            //             relevantSkills.push({ name: displayName, value: skill.value });
            //         }
            //     }
            //     relevantSkills.sort((a, b) => a.name.localeCompare(b.name, currentLanguage));
            //     if (relevantSkills.length > 0) {
            //         relevantSkills.forEach(skill => {
            //             summaryText += `${skill.name}: ${skill.value}%\n`;
            //         });
            //     } else {
            //         summaryText += `(${t('not_defined')})\n`;
            //     }
            //     summaryText += "\n";


            //     summaryText += `== ${t('summary_section_bonds')} ==\n`;
            //     if (character.bonds && character.bonds.length > 0) {
            //         character.bonds.forEach((bond, index) => {
            //             summaryText += `${t('bond_label_number', {number: index + 1})}: ${bond.description || `(${t('not_defined')})`} - Score: ${bond.score}\n`;
            //         });
            //     } else {
            //         summaryText += `(${t('not_defined')})\n`;
            //     }
            //     summaryText += "\n";

            //     summaryText += `== ${t('summary_section_motivations')} ==\n`;
            //     const definedMotivations = character.motivations.filter(m => m && m.trim() !== "");
            //     if (definedMotivations.length > 0) {
            //         definedMotivations.forEach((motivation) => {
            //             summaryText += `- ${motivation}\n`;
            //         });
            //     } else {
            //         summaryText += `(${t('not_defined')})\n`;
            //     }

            //     // Download initiieren
            //     const blob = new Blob([summaryText], { type: 'text/plain;charset=utf-8' });
            //     const link = document.createElement("a");
            //     const url = URL.createObjectURL(blob);
            //     link.setAttribute("href", url);
            //     link.setAttribute("download", "delta_green_character.txt");
            //     link.style.visibility = 'hidden';
            //     document.body.appendChild(link);
            //     link.click();
            //     document.body.removeChild(link);
            //     URL.revokeObjectURL(url);
            // }
            
            function validateStep5() { return true; }
            function saveStep5() { /* Nichts zu speichern */ }

            const steps = [
                { render: renderIntro, validate: () => true, save: () => {}, nameKey: "step_name_0" },
                { render: renderStep1_ProfessionSkills, validate: validateStep1, save: saveStep1, nameKey: "step_name_1", attachListeners: attachStep1Listeners },
                // Die folgenden sind noch Platzhalter für die Render-Funktionen.
                // Du musst sie durch die echten ersetzen oder ihre Inhalte anpassen.
                { render: renderStep2_Statistics, validate: validateStep2, save: saveStep2, nameKey: "step_name_2", attachListeners: attachStep2Listeners },
                { render: renderStep3_DerivedAttributes, validate: validateStep3, save: saveStep3, nameKey: "step_name_3", attachListeners: attachStep3Listeners },
                { render: renderStep4_BondsMotivations, validate: validateStep4, save: saveStep4, nameKey: "step_name_4", attachListeners: attachStep4Listeners },
                { render: renderStep5_Summary, validate: validateStep5, save: saveStep5, nameKey: "step_name_5", attachListeners: attachStep5Listeners }
            ];

            function initialize() {
                stepContainer = document.getElementById('step-content-container');
                progressBarContainer = document.getElementById('progress-bar-container');
                btnNext = document.getElementById('btn-next');
                btnBack = document.getElementById('btn-back');
                
                initI18n(); // Setzt die globale `currentLanguage` basierend auf der neuen Logik

                setLanguage(currentLanguage); // Wendet die initial bestimmte Sprache an

                resetCharacter();
                
                btnNext.addEventListener('click', handleNextStep);
                btnBack.addEventListener('click', handlePreviousStep);
                document.getElementById('lang-de').addEventListener('click', () => setLanguage('de'));
                document.getElementById('lang-en').addEventListener('click', () => setLanguage('en'));
                
                renderCurrentStep();
            }
            function handleNextStep() {
                if (!validateStep(currentStep, true)) return;
                saveStepData(currentStep);
                if (currentStep < steps.length - 1) {
                    currentStep++;
                    renderCurrentStep();
                }
            }
            function handlePreviousStep() {
                if (currentStep > 0) {
                    currentStep--;
                    renderCurrentStep();
                }
            }
            function updateNavigationButtons() {
                btnBack.disabled = currentStep === 0;

                if (currentStep === steps.length - 1) { // Letzter Schritt (Summary)
                    btnNext.style.display = 'none';
                } else {
                    btnNext.style.display = 'inline-block';
                    btnNext.textContent = t('btn_next_text');
                    
                    let isStepValid = validateStep(currentStep, false); // Wichtig: showAlerts = false für Button-Status

                    if (currentStep === 1 && character.isCustomProfession) {
                        // Für Custom Profession in 'bonds' oder 'skills' Stage ist der Haupt "Next" Button deaktiviert.
                        // Die Navigation erfolgt über interne "Confirm..." Buttons.
                        if (character.customProfessionSetupStage === 'bonds' || character.customProfessionSetupStage === 'skills') {
                            btnNext.disabled = true;
                        } else { // 'done' stage
                            btnNext.disabled = !isStepValid;
                        }
                    } else {
                        btnNext.disabled = !isStepValid;
                    }
                }
            }
            function renderCurrentStep() {
                if (steps[currentStep] && typeof steps[currentStep].render === 'function') {
                    const stepData = steps[currentStep];
                    const stepContentOrHtml = stepData.render();
                    if (typeof stepContentOrHtml === 'string') {
                        stepContainer.innerHTML = stepContentOrHtml;
                    } else if (stepContentOrHtml instanceof Node) {
                        stepContainer.innerHTML = ''; 
                        stepContainer.appendChild(stepContentOrHtml);
                    }
                    translateAllElements(stepContainer);
                    if (stepData.attachListeners) {
                        stepData.attachListeners();
                    }
                    updateProgressBar(); 
                    updateNavigationButtons(); 
                }
            }
            function updateProgressBar() {
                const stepName = t(steps[currentStep].nameKey) || `Step ${currentStep}`;
                progressBarContainer.textContent = t('progress_bar_text', { current: currentStep , total: steps.length -1, stepName: stepName });
            }
            function validateStep(stepIndex, showAlerts = true) {
                if (steps[stepIndex] && typeof steps[stepIndex].validate === 'function') {
                    return steps[stepIndex].validate(showAlerts);
                }
                return true; 
            }
            function saveStepData(stepIndex) {
                if (steps[stepIndex] && typeof steps[stepIndex].save === 'function') {
                    steps[stepIndex].save();
                }
            }
            function getCurrentCharacterData() {
                return character; // Gibt das aktuelle character Objekt zurück
            }

            // Public API
            return {
                initialize,
                renderCurrentStep,
                getCurrentCharacterData // Exponiere die Methode
            };
        })();

        document.addEventListener('DOMContentLoaded', app.initialize);
    </script>
</body>
</html>
