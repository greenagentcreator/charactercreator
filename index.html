<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="page_title">Delta Green Agent Character Creator</title>
    <meta name="description" content="Create detailed agent character sheets for your Delta Green RPG sessions with this easy-to-use online character creator. Supports custom professions, skills, and more. No Log-in, no ads, free of costs.">
    <meta name="google-site-verification" content="bz_uz4BtBwAXCsKC8RHZXKlqEY0KaTULTd4DrRX0i_w" />
    <style>
        @font-face {
          font-family: 'Roboto Slab';
          font-style: normal;
          font-weight: 400;
          src: url('./fonts/roboto-slab/roboto-slab-v34-latin-regular.woff2') format('woff2');
        }
        
        @font-face {
          font-family: 'Roboto Slab';
          font-style: normal;
          font-weight: 700;
          src: url('./fonts/roboto-slab/roboto-slab-v34-latin-700.woff2') format('woff2');
        }
        
        @font-face {
          font-family: 'Special Elite';
          font-style: normal;
          font-weight: 400;
          src: url('./fonts/special-elite/special-elite-v19-latin-regular.woff2') format('woff2');
        }
        /* --- Global Styles & Reset --- */
        body {
            font-family: 'Roboto Slab', serif;
            background-color: #f4f1e8; /* Parchment/Aged paper */
            color: #222;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        #app-container {
            width: 100%;
            max-width: 800px;
            background-color: #fff;
            border: 1px solid #ccc;
            box-shadow: 3px 3px 10px rgba(0,0,0,0.1);
            padding: 20px 30px;
            border-radius: 3px; /* Slight rounding for document feel */
        }

        /* --- Header & Language Switcher --- */
        header {
            border-bottom: 2px solid #555;
            padding-bottom: 10px;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        header h1 {
            font-family: 'Special Elite', cursive;
            color: #000;
            margin: 0;
            font-size: 1.8em;
        }
        #language-switcher button {
            font-family: 'Roboto Slab', serif;
            background: none;
            border: 1px solid #aaa;
            padding: 5px 10px;
            margin-left: 5px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        #language-switcher button.active {
            background-color: #475c47; /* Darker, desaturated green */
            color: white;
            border-color: #475c47;
        }
        #language-switcher button:not(.active):hover {
            background-color: #e0e0e0;
        }

        /* --- Progress Bar --- */
        #progress-bar-container {
            text-align: center;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #555;
        }
        
        /* --- Step Content & Forms --- */
        .step {
            animation: fadeIn 0.4s ease-in-out;
            margin-bottom: 20px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .info-box {
            background-color: #e9efeB; /* Light, slightly greenish grey */
            border-left: 4px solid #5a7a5a; /* Darker green accent */
            padding: 12px 18px;
            margin-bottom: 20px;
            font-size: 0.95em;
            border-radius: 2px;
        }
        .info-box p:first-child { margin-top: 0; }
        .info-box p:last-child { margin-bottom: 0; }

        h2, h3 {
            font-family: 'Special Elite', cursive;
            margin-top: 25px;
            margin-bottom: 15px;
            color: #333;
        }
        h2 { font-size: 1.5em; }
        h3 { font-size: 1.3em; }

        label {
            display: block;
            margin-bottom: 6px;
            font-weight: bold;
            color: #444;
        }
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
            box-sizing: border-box;
            font-family: 'Roboto Slab', serif;
            border-radius: 2px;
            transition: border-color 0.2s;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            border-color: #5a7a5a;
            outline: none;
            box-shadow: 0 0 0 2px rgba(90, 122, 90, 0.2);
        }
        select {
            appearance: none; /* For custom arrow if desired, or leave default */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20width%3D%2220%22%20height%3D%2220%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M5%208l5%205%205-5z%22%20fill%3D%22%23555%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            padding-right: 30px; /* Make space for arrow */
        }
        input[type="radio"], input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle;
        }
        footer{
            opacity: 30%;
            border-top-style: solid;
            border-width:thin;
            margin-top: 25px;
            font-style: italic;

        }
        .inline-label { /* For radio/checkbox groups */
            font-weight: normal;
            margin-right: 15px;
            display: inline-block;
        }

        /* --- Navigation Buttons --- */
        .nav-button, .action-button {
            font-family: 'Roboto Slab', serif;
            background-color: #444;
            color: white;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 0.5px;
            border-radius: 2px;
            transition: background-color 0.2s;
        }
        .nav-button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        .nav-button:hover:not(:disabled), .action-button:hover {
            background-color: #222;
        }
        #navigation-container {
            margin-top: 30px;
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }

        /* --- Skill List Styling --- */
        .skill-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px dotted #ddd;
        }
        .skill-list-item:last-child {
            border-bottom: none;
        }
        .skill-name-container {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        .skill-name {
            margin-right: 8px;
        }
        .skill-info-icon {
            cursor: help;
            color: #5a7a5a;
            font-size: 0.85em; /* Slightly larger */
            border: 1px solid #99b099; /* Softer border */
            border-radius: 50%;
            width: 18px; /* Slightly larger */
            height: 18px;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            position: relative;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .skill-info-icon:hover {
            background-color: #dde5dd;
        }
        .tooltip {
            visibility: hidden;
            width: 220px;
            background-color: #2b2b2b; /* Darker tooltip */
            color: #f0f0f0;
            text-align: left;
            border-radius: 4px;
            padding: 8px 12px;
            position: absolute;
            z-index: 10;
            bottom: 130%; /* Position above the icon */
            left: 50%;
            margin-left: -110px; /* Center the tooltip */
            opacity: 0;
            transition: opacity 0.3s, visibility 0s 0.3s;
            font-size: 0.9em;
            line-height: 1.4;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .skill-info-icon:hover .tooltip {
            visibility: visible;
            opacity: 1;
            transition-delay: 0s;
        }
        .skill-value-controls {
            display: flex;
            align-items: center;
        }
        .skill-value {
            font-weight: bold;
            min-width: 30px; /* Ensure space for value */
            text-align: right;
            margin-right: 5px;
        }
        .skill-increase-count {
            font-size: 0.8em;
            color: #666;
            min-width: 50px; /* Ensure space */
            text-align: left;
            margin-right: 10px;
        }
        .skill-increase-button {
            padding: 4px 9px;
            font-size: 0.85em;
            background-color: #e8e8e8;
            border: 1px solid #ccc;
            cursor: pointer;
            border-radius: 2px;
            transition: background-color 0.2s;
        }
        .skill-increase-button:hover:not(:disabled) {
            background-color: #d8d8d8;
        }
        .skill-increase-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .skill-decrease-button {
            /* Ähnlich wie skill-increase-button, vielleicht andere Farbe */
            padding: 4px 9px;
            font-size: 0.85em;
            background-color: #f0e0e0; /* Leicht rötlich? */
            border: 1px solid #c9b9b9;
            cursor: pointer;
            border-radius: 2px;
            transition: background-color 0.2s;
            margin-right: 5px; /* Abstand zum + Button */
        }
        .skill-decrease-button:hover:not(:disabled) {
            background-color: #e0d0d0;
        }
        .skill-decrease-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* --- Profession Specific Choices --- */
        #profession-details ul {
            list-style-type: none;
            padding-left: 0;
        }
        #profession-details li {
            margin-bottom: 8px;
        }
        #profession-details input[type="text"].prof-choice-skill-type {
            width: auto; /* Don't take full width */
            margin-left: 10px;
            padding: 6px;
            font-size: 0.9em;
        }

        /* --- Statistics Allocation --- */
        .stat-allocation-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            align-items: center;
        }
        .stat-allocation-row label {
            width: 60px; /* STR, CON etc. */
        }
        .stat-allocation-row select {
            width: 100px; /* For stat value */
            margin-bottom: 0;
        }
        .stat-allocation-row .stat-percentile {
            width: 60px;
            text-align: right;
            font-weight: bold;
        }
        .distinguishing-feature-input {
            margin-top: 5px;
            font-size: 0.9em;
        }
        
        /* --- Summary --- */
        #step5-summary ul {
            list-style-type: none;
            padding-left: 0;
        }
        #step5-summary li {
            padding: 3px 0;
        }
        #step5-summary strong { /* Category labels in summary */
            color: #333;
        }
        .action-button {
            margin-right: 10px;
            margin-top:15px;
        }
        label.disabled-choice {
            opacity: 0.6;
            cursor: not-allowed; /* Zeigt dem Nutzer, dass es nicht klickbar ist */
        }
        label.disabled-choice input[type="checkbox"] {
            cursor: not-allowed; /* Auch den Cursor für die Checkbox selbst ändern */
        }
        .custom-skill-item.disabled-choice { /* Oder z.B. nur .custom-prof-skill-select:disabled + .skill-name */
            opacity: 0.6;
            /* cursor: not-allowed; /* Optional für das gesamte Item */
        }
        .custom-skill-item.disabled-choice .custom-prof-skill-select {
            cursor: not-allowed;
        }

        .bond-entry, .motivation-entry {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #eee;
        }
        .bond-entry:last-child, .motivation-entry:last-child {
            border-bottom: none;
        }
        .bond-entry label, .motivation-entry label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.95em;
        }
        .bond-entry input[type="text"] {
            margin-bottom: 5px;
        }
        .bond-entry span[data-i18n="bond_score_label"] + span { /* Der Span mit dem CHA-Wert */
            font-weight: bold;
            margin-left: 5px;
        }

        /* Anpassungen für die Skill-Instanz-Zeile im Custom Profession Bereich */
        #custom-profession-skill-list .skill-instance-controls {
            display: flex;            /* Hauptcontainer als Flexbox */
            flex-wrap: nowrap;        /* Verhindert Zeilenumbruch der direkten Kinder */
            align-items: center;      /* Zentriert Elemente vertikal in der Zeile */
            margin-left: 25px;
            padding: 8px 5px;         /* Etwas mehr Padding für bessere Optik */
            border-left: 2px solid #eee;
            margin-top: 5px;
            gap: 8px;                 /* Abstand zwischen den Elementen in der Zeile */
        }

        /* Typ-Eingabefeld */
        #custom-profession-skill-list .custom-instance-type-input {
            flex-grow: 1;             /* Nimmt verfügbaren Platz ein, drückt andere Elemente nicht weg */
            min-width: 120px;         /* Mindestbreite, bevor es anfängt zu schrumpfen (falls nötig) */
            max-width: 200px;         /* Maximale Breite, um nicht zu lang zu werden */
            margin-right: 0;          /* Entferne alten margin-right, da wir 'gap' verwenden */
            /* padding und font-size bleiben wie sie sind oder werden hier angepasst */
            padding: 8px;
            font-size: 0.9em;
        }

        /* "Points:" Label */
        #custom-profession-skill-list .skill-instance-controls > span:first-of-type { /* Annahme: "Points:" ist das erste Span-Element */
            white-space: nowrap;      /* Verhindert Umbruch im Label selbst */
            margin-right: 0;          /* 'gap' kümmert sich um den Abstand */
        }

        /* Container für +/- Buttons und Punktzahl */
        /* (Keine spezifische Klasse, also stylen wir die Buttons und das Span direkt) */

        /* +/- Buttons für Punkte */
        #custom-profession-skill-list .custom-skill-point-btn {
            padding: 4px 8px;        /* Konsistentes Padding */
            flex-shrink: 0;          /* Verhindert, dass Buttons schrumpfen */
        }

        /* Angezeigte Punktzahl */
        #custom-profession-skill-list .custom-skill-assigned-points {
            min-width: 25px;         /* Mindestbreite für die Zahl */
            text-align: center;
            font-weight: bold;
            margin: 0 3px;           /* Etwas Abstand zu den +/- Buttons */
            flex-shrink: 0;
        }

        /* "Total:" Anzeige */
        #custom-profession-skill-list .custom-skill-total-value {
            white-space: nowrap;
            margin-left: 5px;        /* Etwas Abstand zum vorherigen Element */
            font-weight: bold;
            flex-shrink: 0;
        }
        #custom-profession-skill-list .skill-instance-controls > strong:last-of-type { /* Geht davon aus, dass "Total: X% (max 60%)" ein strong ist*/
            white-space: nowrap;
        }


        /* Entfernen-Button */
        #custom-profession-skill-list .remove-custom-skill-instance-btn {
            margin-left: auto;       /* Schiebt den Entfernen-Button ganz nach rechts */
            padding: 0 5px;          /* Etwas Padding für Klickfläche */
            flex-shrink: 0;
            /* Bestehende Styles für Farbe, etc. bleiben erhalten */
        }
        .custom-prof-actions-container {
            display: flex;
            justify-content: flex-end; /* Richtet den Inhalt (den Button) rechts aus */
            margin-top: 20px; /* Behalte den oberen Abstand bei oder passe ihn an */
        }

        /* Optional: Entferne den margin-top vom Button selbst, wenn er jetzt vom Container kommt */
        #btn-confirm-custom-skills {
            margin-top: 0; /* Nur wenn der margin-top jetzt am Container ist */
        }

        /* --- Print Styles --- */
        @media print {
            body { 
                padding: 0; 
                background-color: #fff; 
                font-size: 10pt; /* Kleinere Schrift für Druck */
                color: #000;    /* Reines Schwarz für Druck */
            }
            #app-container { 
                box-shadow: none; 
                border: none; 
                max-width: 100%; 
                padding: 0; 
            }
            header, #navigation-container, footer, #language-switcher, #progress-bar-container, .summary-actions { 
                display: none !important; /* Alle UI-Elemente außer der Zusammenfassung ausblenden */
            }
            .info-box { /* Infoboxen im Druck ggf. anders oder weniger prominent */
                border-left-width: 2px;
                padding: 8px 10px;
                background-color: #f8f8f8; 
            }
            h1, h2, h3 { 
                margin-top: 15px; 
                margin-bottom: 8px; 
                color: #000;
            }
            /* Weitere Anpassungen, z.B. für Tabellen oder Listen im Druck */
            .summary-section ul {
                list-style-type: disc; /* Oder none, wenn es sauberer ist */
                padding-left: 20px; /* Einrücken für Listenpunkte */
            }
             .summary-stats-grid, .summary-derived-grid { 
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Ggf. Spalten anpassen für Papier */
            }
            .summary-skills-multicolumn {
                grid-template-columns: repeat(3, 1fr); /* Erzwinge 3 Spalten im Druck */
                gap: 0 10px; /* Weniger Abstand im Druck */
            }
            .summary-skills-multicolumn .skill-column li {
                font-size: 9pt; /* Kleinere Schrift für mehr Inhalt */
                margin-bottom: 1px;
            }
            .summary-bonds-motivations-container {
                display: block; /* Im Druck ggf. untereinander statt nebeneinander, wenn Platz knapp */
            }
            .summary-bonds-motivations-container .summary-column {
                width: 100%; /* Volle Breite, wenn untereinander */
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header>
            <h1 data-i18n="app_header">Delta Green Agent Dossier</h1>
            <div id="language-switcher">
                <button id="lang-de">DE</button>
                <button id="lang-en">EN</button>
            </div>
        </header>

        <main>
            <div id="progress-bar-container"></div>
            <div id="step-content-container">
                <!-- Content dynamically inserted here -->
            </div>
            <div id="navigation-container">
                <button id="btn-back" data-i18n="btn_back_text" class="nav-button" disabled>Back</button>
                <button id="btn-next" data-i18n="btn_next_text" class="nav-button">Next</button>
            </div>
        </main>

        <footer>
            <p data-i18n="footer_text">© DG Character Creator - Based on Delta Green</p>
        </footer>
    </div>
    <script src="https://cdn.counter.dev/script.js" data-id="ebd38259-4f23-48a0-b169-bfa1c5f86192" data-utcoffset="2"></script>
    <script>
        // --- DATA: Embedded Skill Data ---
        const ALL_SKILLS = {
            "accounting":     { base: 10, nameKey: "skill_accounting_name", descKey: "skill_accounting_desc" },
            "alertness":      { base: 20, nameKey: "skill_alertness_name", descKey: "skill_alertness_desc" },
            "anthropology":   { base: 0,  nameKey: "skill_anthropology_name", descKey: "skill_anthropology_desc" },
            "archeology":     { base: 0,  nameKey: "skill_archeology_name", descKey: "skill_archeology_desc" },
            "art":            { base: 0,  nameKey: "skill_art_name", descKey: "skill_art_desc", type: true },
            "artillery":      { base: 0,  nameKey: "skill_artillery_name", descKey: "skill_artillery_desc" },
            "athletics":      { base: 30, nameKey: "skill_athletics_name", descKey: "skill_athletics_desc" },
            "bureaucracy":    { base: 10, nameKey: "skill_bureaucracy_name", descKey: "skill_bureaucracy_desc" },
            "computer_science":{ base: 0, nameKey: "skill_computer_science_name", descKey: "skill_computer_science_desc" },
            "craft":          { base: 0,  nameKey: "skill_craft_name", descKey: "skill_craft_desc", type: true },
            "criminology":    { base: 10, nameKey: "skill_criminology_name", descKey: "skill_criminology_desc" },
            "demolitions":    { base: 0,  nameKey: "skill_demolitions_name", descKey: "skill_demolitions_desc" },
            "disguise":       { base: 10, nameKey: "skill_disguise_name", descKey: "skill_disguise_desc" },
            "dodge":          { base: 30, nameKey: "skill_dodge_name", descKey: "skill_dodge_desc" },
            "drive":          { base: 20, nameKey: "skill_drive_name", descKey: "skill_drive_desc" },
            "firearms":       { base: 20, nameKey: "skill_firearms_name", descKey: "skill_firearms_desc" },
            "first_aid":      { base: 10, nameKey: "skill_first_aid_name", descKey: "skill_first_aid_desc" },
            "foreign_language":{ base: 0, nameKey: "skill_foreign_language_name", descKey: "skill_foreign_language_desc", type: true },
            "forensics":      { base: 0,  nameKey: "skill_forensics_name", descKey: "skill_forensics_desc" },
            "heavy_machinery":{ base: 10, nameKey: "skill_heavy_machinery_name", descKey: "skill_heavy_machinery_desc" },
            "heavy_weapons":  { base: 0,  nameKey: "skill_heavy_weapons_name", descKey: "skill_heavy_weapons_desc" },
            "history":        { base: 10, nameKey: "skill_history_name", descKey: "skill_history_desc" },
            "humint":         { base: 10, nameKey: "skill_humint_name", descKey: "skill_humint_desc" },
            "law":            { base: 0,  nameKey: "skill_law_name", descKey: "skill_law_desc" },
            "medicine":       { base: 0,  nameKey: "skill_medicine_name", descKey: "skill_medicine_desc" },
            "melee_weapons":  { base: 30, nameKey: "skill_melee_weapons_name", descKey: "skill_melee_weapons_desc" },
            "military_science":{ base: 0, nameKey: "skill_military_science_name", descKey: "skill_military_science_desc", type: true },
            "navigate":       { base: 10, nameKey: "skill_navigate_name", descKey: "skill_navigate_desc" },
            "occult":         { base: 10, nameKey: "skill_occult_name", descKey: "skill_occult_desc" },
            "persuade":       { base: 20, nameKey: "skill_persuade_name", descKey: "skill_persuade_desc" },
            "pharmacy":       { base: 0,  nameKey: "skill_pharmacy_name", descKey: "skill_pharmacy_desc" },
            "pilot":          { base: 0,  nameKey: "skill_pilot_name", descKey: "skill_pilot_desc", type: true },
            "psychotherapy":  { base: 10, nameKey: "skill_psychotherapy_name", descKey: "skill_psychotherapy_desc" },
            "ride":           { base: 10, nameKey: "skill_ride_name", descKey: "skill_ride_desc" },
            "science":        { base: 0,  nameKey: "skill_science_name", descKey: "skill_science_desc", type: true },
            "search":         { base: 20, nameKey: "skill_search_name", descKey: "skill_search_desc" },
            "sigint":         { base: 0,  nameKey: "skill_sigint_name", descKey: "skill_sigint_desc" },
            "stealth":        { base: 10, nameKey: "skill_stealth_name", descKey: "skill_stealth_desc" },
            "surgery":        { base: 0,  nameKey: "skill_surgery_name", descKey: "skill_surgery_desc" },
            "survival":       { base: 10, nameKey: "skill_survival_name", descKey: "skill_survival_desc" },
            "swim":           { base: 20, nameKey: "skill_swim_name", descKey: "skill_swim_desc" },
            "unarmed_combat": { base: 40, nameKey: "skill_unarmed_combat_name", descKey: "skill_unarmed_combat_desc" },
            "unnatural":      { base: 0,  nameKey: "skill_unnatural_name", descKey: "skill_unnatural_desc" }
        };

        // --- DATA: Embedded Profession Data ---
        const PROFESSIONS = {
            "anthropologist_archaeologist_historian": {
                nameKey: "profession_anthropologist_name",
                bonds: 4,
                baseSkills: [
                    { orSkills: [{ key: "anthropology", value: 50 }, { key: "archeology", value: 50 }], id: "anth_arch" },
                    { key: "bureaucracy", value: 40 },
                    { key: "foreign_language", value: 50, type: true, id: "fl1" },
                    { key: "foreign_language", value: 30, type: true, id: "fl2" },
                    { key: "history", value: 60 },
                    { key: "occult", value: 40 },
                    { key: "persuade", value: 40 }
                ],
                choiceSkills: {
                    count: 2,
                    options: [
                        { key: "anthropology", value: 40 }, { key: "archeology", value: 40 },
                        { key: "humint", value: 50 }, { key: "navigate", value: 50 },
                        { key: "ride", value: 50 }, { key: "search", value: 60 },
                        { key: "survival", value: 50 }
                    ]
                }
            },
            "computer_scientist_engineer": {
                nameKey: "profession_computer_scientist_name",
                bonds: 3,
                baseSkills: [
                    { key: "computer_science", value: 60 },
                    { key: "craft", value: 30, typeNameDefault: "Electrician", id:"craft_elec", type:true },
                    { key: "craft", value: 30, typeNameDefault: "Mechanic", id:"craft_mech", type:true },
                    { key: "craft", value: 40, typeNameDefault: "Microelectronics", id:"craft_micro", type:true },
                    { key: "science", value: 40, typeNameDefault: "Mathematics", id:"sci_math", type:true },
                    { key: "sigint", value: 40 }
                ],
                choiceSkills: {
                    count: 4,
                    options: [
                        { key: "accounting", value: 50 }, { key: "bureaucracy", value: 50 },
                        { key: "craft", value: 40, type: true, id:"craft_choice" },
                        { key: "foreign_language", value: 40, type: true, id:"fl_cs" },
                        { key: "heavy_machinery", value: 50 }, { key: "law", value: 40 },
                        { key: "science", value: 40, type: true, id:"sci_choice" }
                    ]
                }
            },
            "federal_agent": {
                nameKey: "profession_federal_agent_name",
                bonds: 3,
                baseSkills: [
                    { key: "alertness", value: 50 }, { key: "bureaucracy", value: 40 },
                    { key: "criminology", value: 50 }, { key: "drive", value: 50 },
                    { key: "firearms", value: 50 }, { key: "forensics", value: 30 },
                    { key: "humint", value: 60 }, { key: "law", value: 30 },
                    { key: "persuade", value: 50 }, { key: "search", value: 50 },
                    { key: "unarmed_combat", value: 60 }
                ],
                choiceSkills: {
                    count: 1,
                    options: [
                        { key: "accounting", value: 60 }, { key: "computer_science", value: 50 },
                        { key: "foreign_language", value: 50, type: true, id: "fl_fed" },
                        { key: "heavy_weapons", value: 50 }, { key: "pharmacy", value: 50 }
                    ]
                }
            },
            "physician": {
                nameKey: "profession_physician_name",
                bonds: 3,
                baseSkills: [
                    { key: "bureaucracy", value: 50 }, { key: "first_aid", value: 60 },
                    { key: "medicine", value: 60 }, { key: "persuade", value: 40 },
                    { key: "pharmacy", value: 50 },
                    { key: "science", value: 60, typeNameDefault: "Biology", id:"sci_bio", type:true },
                    { key: "search", value: 40 }
                ],
                choiceSkills: {
                    count: 2,
                    options: [
                        { key: "forensics", value: 50 }, { key: "psychotherapy", value: 60 },
                        { key: "science", value: 50, type: true, id:"sci_choice_phy" },
                        { key: "surgery", value: 50 }
                    ]
                }
            },
            "scientist": {
                nameKey: "profession_scientist_name",
                bonds: 4,
                baseSkills: [
                    { key: "bureaucracy", value: 40 }, { key: "computer_science", value: 40 },
                    { key: "science", value: 60, type: true, id:"sci1" },
                    { key: "science", value: 50, type: true, id:"sci2" },
                    { key: "science", value: 50, type: true, id:"sci3" }
                ],
                choiceSkills: {
                    count: 3,
                    options: [
                        { key: "accounting", value: 50 }, { key: "craft", value: 40, type: true, id:"craft_sci" },
                        { key: "foreign_language", value: 40, type: true, id:"fl_sci" },
                        { key: "forensics", value: 40 }, { key: "law", value: 40 },
                        { key: "pharmacy", value: 40 }
                    ]
                }
            },
            "special_operator": {
                nameKey: "profession_special_operator_name",
                bonds: 2,
                baseSkills: [
                    { key: "alertness", value: 60 }, { key: "athletics", value: 60 },
                    { key: "demolitions", value: 40 }, { key: "firearms", value: 60 },
                    { key: "heavy_weapons", value: 50 }, { key: "melee_weapons", value: 50 },
                    { key: "military_science", value: 60, typeNameDefault: "Land", id:"ms_land", type:true },
                    { key: "navigate", value: 50 }, { key: "stealth", value: 50 },
                    { key: "survival", value: 50 }, { key: "swim", value: 50 },
                    { key: "unarmed_combat", value: 60 }
                ],
                choiceSkills: null
            },
            "custom_profession": { // Eindeutiger Schlüssel
            nameKey: "profession_custom_build_name", // Für die Übersetzung im Dropdown
            isCustom: true // Ein Flag, um es leicht zu identifizieren
            // Bonds und Skills werden dynamisch gesetzt
            }
        };

        // --- DATA: Embedded i18n Translations ---
        const i18nData = {
             en: {
                "page_title": "Delta Green Agent Creator | Fan Project",
                "app_header": "Delta Green Agent Creation",
                "footer_text": "Published by arrangement with the Delta Green Partnership. The intellectual property known as Delta Green is a trademark and copyright owned by the Delta Green Partnership, who has licensed its use here. This includes all elements that are components of the Delta Green intellectual property. – This website uses counter.dev, a privacy-friendly visitor counter. No personal data is collected, no cookies are set, and no IP addresses are stored. The analysis is anonymized and serves only as a rough estimate of page views.", // Slight change
                "btn_back_text": "Back",
                "btn_next_text": "Next",
                "btn_finish_text": "View Summary",
                "progress_bar_text": "Step {current} of {total}: {stepName}",
                "select_one_option": "-- Select One --",
                "specify_type_placeholder": "Specify type (e.g., Physics, French, Acting)",
                "choose_one_label": "Choose one",
                "choose_N_label": "Choose {N} of the following",

                "intro_quote_dg": "Crafting a Delta Green agent involves several key stages: selecting a profession and associated skills, defining core physical and mental statistics to calculate further attributes, and finally, establishing the agent's personal connections and driving motivations.",
                "intro_welcome_text": "Welcome to the Agent Character Creator for Delta Green. Proceed by clicking 'Next' to begin shaping your operative.",
                "step_name_0": "Introduction",
                "step_name_1": "Profession & Skills",
                "step_name_2": "Statistics",
                "step_name_3": "Derived Attributes",
                "step_name_4": "Bonds & Motivations",
                "step_name_5": "Summary",

                "step1_info1": "An agent's profession is foundational, influencing their skill set, initial number of interpersonal Bonds, available resources, and the scope of their authority and duties. The occupations listed below represent common backgrounds for Delta Green agents.",
                "step1_info2": "Each profession grants a specific list of skills with initial ratings that override the default base values. Beyond these professional skills, you have 8 points (each worth +20%) to distribute among any skills on your sheet. A single skill can receive multiple boosts, but no skill may exceed an initial rating of 80%.",
                "add_specialization_button_text": "Add Specialization for {skillName}",
"remove_button_title": "Remove this specialization",
                "step1_select_profession_label": "Step 1.1: Select a Profession",
                "step1_2_profession_specific_label": "Step 1.2: Profession-Specific Choices",
                "bonds_label": "Bonds", // This is a label, likely fine as is.
                "step1_increase_skills_label": "Step 1.3: Distribute Skill Boosts (8 available, +20% each)",
                "increases_chosen_label": "Boosts applied:",
                "alert_select_profession": "Please choose a profession to continue.",
                "alert_max_choices_reached": "You have reached the maximum of {N} selections for this category.",
                "alert_skill_increase_limit": "All 8 skill boosts have been allocated.",
                "alert_skill_max_value_reached": "This skill's rating cannot surpass 80% at character creation.",
                "alert_type_for_skill_needed": "A specific type is required for the skill \"{skillName}\".",

                "profession_anthropologist_name": "Anthropologist, Archaeologist, or Historian",
                "profession_computer_scientist_name": "Computer Scientist or Engineer",
                "profession_federal_agent_name": "Federal Agent",
                "profession_physician_name": "Physician",
                "profession_scientist_name": "Scientist",
                "profession_special_operator_name": "Special Operator",

                "skill_accounting_name": "Accounting", "skill_accounting_desc": "Understanding financial records, business practices, and uncovering fiscal irregularities.",
                "skill_alertness_name": "Alertness", "skill_alertness_desc": "Perceiving subtle details, potential threats, or noticing the unusual in one's surroundings.",
                "skill_anthropology_name": "Anthropology", "skill_anthropology_desc": "The academic study of human societies, cultures, and their development.",
                "skill_archeology_name": "Archeology", "skill_archeology_desc": "Investigating human history and prehistory through excavation and analysis of artifacts.",
                "skill_art_name": "Art", "skill_art_desc": "Proficiency in creating or performing a specific art form (e.g., Painting, Music, Theatre).",
                "skill_artillery_name": "Artillery", "skill_artillery_desc": "Operating and accurately deploying heavy-bore projectile weapons like mortars or missile launchers.",
                "skill_athletics_name": "Athletics", "skill_athletics_desc": "Physical prowess in activities requiring strength, agility, and coordination like running, jumping, or climbing.",
                "skill_bureaucracy_name": "Bureaucracy", "skill_bureaucracy_desc": "Navigating complex organizational structures, procedures, and influencing official channels.",
                "skill_computer_science_name": "Computer Science", "skill_computer_science_desc": "In-depth understanding of computer hardware, software, networks, and data analysis.",
                "skill_craft_name": "Craft", "skill_craft_desc": "Skill in a specific trade or manual creation (e.g., Mechanics, Electronics, Lockpicking).",
                "skill_criminology_name": "Criminology", "skill_criminology_desc": "Knowledge of criminal behavior, investigation techniques, and the workings of illegal enterprises.",
                "skill_demolitions_name": "Demolitions", "skill_demolitions_desc": "The safe and effective use of explosives for breaching, destruction, or creating diversions.",
                "skill_disguise_name": "Disguise", "skill_disguise_desc": "Altering one's appearance, voice, and mannerisms to convincingly impersonate someone else or create a false identity.",
                "skill_dodge_name": "Dodge", "skill_dodge_desc": "Reactively evading physical attacks or sudden hazards through quick reflexes.",
                "skill_drive_name": "Drive", "skill_drive_desc": "Operating ground vehicles like cars or motorcycles proficiently, especially under pressure.",
                "skill_firearms_name": "Firearms", "skill_firearms_desc": "Accurate and safe use of handguns, rifles, and shotguns in combat situations.",
                "skill_first_aid_name": "First Aid", "skill_first_aid_desc": "Providing immediate medical care to stabilize injuries and prevent further harm.",
                "skill_foreign_language_name": "Foreign Language", "skill_foreign_language_desc": "Fluency in a language other than one's native tongue (specify language).",
                "skill_forensics_name": "Forensics", "skill_forensics_desc": "Collecting, analyzing, and interpreting physical evidence from a scene using scientific methods.",
                "skill_heavy_machinery_name": "Heavy Machinery", "skill_heavy_machinery_desc": "Operating large or complex machinery such as construction equipment or industrial tools.",
                "skill_heavy_weapons_name": "Heavy Weapons", "skill_heavy_weapons_desc": "Proficient use of man-portable heavy armaments like machine guns or grenade launchers.",
                "skill_history_name": "History", "skill_history_desc": "Knowledge of past events, societies, and their significance (may require specialization).",
                "skill_humint_name": "HUMINT", "skill_humint_desc": "Human Intelligence: Gathering information through interpersonal contact, interviews, and interrogation.",
                "skill_law_name": "Law", "skill_law_desc": "Understanding legal systems, procedures, and using them to one's advantage or for investigation.",
                "skill_medicine_name": "Medicine", "skill_medicine_desc": "Advanced diagnosis, treatment of illnesses and injuries, beyond basic first aid.",
                "skill_melee_weapons_name": "Melee Weapons", "skill_melee_desc": "Effective use of hand-to-hand combat weapons like knives, clubs, or swords.", // Corrected key
                "skill_military_science_name": "Military Science", "skill_military_science_desc": "Knowledge of military tactics, strategy, organization, and culture (specify branch or focus).",
                "skill_navigate_name": "Navigate", "skill_navigate_desc": "Determining position and planning routes using maps, compasses, or other tools.",
                "skill_occult_name": "Occult", "skill_occult_desc": "Familiarity with esoteric lore, paranormal claims, secret societies, and arcane knowledge.",
                "skill_persuade_name": "Persuade", "skill_persuade_desc": "Influencing others' thoughts, decisions, or actions through argument, charm, or negotiation.",
                "skill_pharmacy_name": "Pharmacy", "skill_pharmacy_desc": "Understanding drugs, their effects, interactions, and preparation.",
                "skill_pilot_name": "Pilot", "skill_pilot_desc": "Operating and navigating aircraft, watercraft, or spacecraft (specify vehicle type).",
                "skill_psychotherapy_name": "Psychotherapy", "skill_psychotherapy_desc": "Diagnosing and treating mental health conditions and emotional distress.",
                "skill_ride_name": "Ride", "skill_ride_desc": "Skill in controlling and riding animals, typically horses or similar mounts.",
                "skill_science_name": "Science", "skill_science_desc": "Expertise in a specific scientific field (e.g., Biology, Chemistry, Physics).",
                "skill_search_name": "Search", "skill_search_desc": "Methodically finding hidden objects, information, or individuals in a given area.",
                "skill_sigint_name": "SIGINT", "skill_sigint_desc": "Signals Intelligence: Intercepting, analyzing, and decrypting electronic communications.",
                "skill_stealth_name": "Stealth", "skill_stealth_desc": "Moving悄悄地 and acting without being detected by sight or sound.",
                "skill_surgery_name": "Surgery", "skill_surgery_desc": "Performing invasive medical procedures to treat severe injuries or complex conditions.",
                "skill_survival_name": "Survival", "skill_survival_desc": "Sustaining oneself in hostile environments using knowledge of nature and improvisation.",
                "skill_swim_name": "Swim", "skill_swim_desc": "Proficiency in swimming, especially in challenging or dangerous water conditions.",
                "skill_unarmed_combat_name": "Unarmed Combat", "skill_unarmed_combat_desc": "Effectiveness in hand-to-hand fighting without weapons, incorporating various martial techniques.",
                "skill_unnatural_name": "Unnatural", "skill_unnatural_desc": "Grasping the sanity-shattering truths and entities that defy conventional understanding of reality.",

                "step2_info_stats": "An agent's six core statistics define their innate physical and mental capabilities. These values typically range from 3 to 18.",
                "stat_str_name": "Strength (STR)", "stat_str_desc": "Measures sheer physical force and brawn.",
                "stat_con_name": "Constitution (CON)", "stat_con_desc": "Indicates an agent's health, resilience, and stamina.",
                "stat_dex_name": "Dexterity (DEX)", "stat_dex_desc": "Reflects an agent's agility, coordination, and reaction speed.",
                "stat_int_name": "Intelligence (INT)", "stat_int_desc": "Represents an agent's reasoning, memory, and problem-solving ability.",
                "stat_pow_name": "Power (POW)", "stat_pow_desc": "Signifies willpower, mental fortitude, and psychic potential.",
                "stat_cha_name": "Charisma (CHA)", "stat_cha_desc": "Measures an agent's force of personality, persuasiveness, and social appeal.",
                "step2_select_array_label": "Step 2.1: Choose a Stat Array", // Modified to be more active
                "step2_assign_stats_label": "Step 2.2: Allocate the chosen values to your Statistics:", // Modified for clarity
                "step2_info_percentile": "For each statistic, note its percentile value (Stat Value × 5). If a statistic is notably low (below 9) or high (above 12), it's considered a distinguishing trait. Briefly describe this trait.", // Reworded
                "distinguishing_feature_label": "Defining Trait:", // Reworded
                "distinguishing_feature_placeholder": "e.g., Exceptionally Strong, Awkward, Sharp Witted, Easily Distracted", // New examples
                "alert_assign_all_stats": "Ensure a value is assigned to every statistic.",
                "alert_unique_stat_values": "Each value from the selected array must be assigned to only one statistic.",

                "step3_info_derived": "Derived attributes are secondary characteristics calculated using your agent's primary statistics.",
                "attr_hp_name": "Hit Points (HP)", "attr_hp_desc": "Indicate an agent's capacity to withstand physical damage. Calculated as (STR + CON) / 2, rounded up.",
                "attr_wp_name": "Willpower Points (WP)", "attr_wp_desc": "Represent an agent's mental energy and resolve. This value is equal to their POW statistic.",
                "attr_san_name": "Sanity (SAN)", "attr_san_desc": "Measures an agent's grip on conventional reality. Calculated as POW × 5.",
                "attr_bp_name": "Breaking Point (BP)", "attr_bp_desc": "The Sanity threshold at which further trauma may induce a new mental disorder. Calculated as SAN - POW.",
                "derived_attributes_title": "Step 3: Derived Attributes",

                "step4_info_bonds_mot": "While your profession, skills, and statistics outline your agent's capabilities, their Bonds and Motivations give depth to who they are as an individual.",
                "step4_1_bonds_title": "Step 4.1: Define Bonds", // More active
                "step4_info_bonds1": "A Bond signifies a crucial human connection in your agent's life. Each Bond starts with a score equal to the agent's Charisma (CHA).",
                "step4_info_bonds2": "Professions with greater demands often limit the number of Bonds an agent can maintain. Initially, Bonds require just a name and the nature of the relationship.",
                "bond_examples_label": "Bond Examples:", // Reworded
                "bond_examples_list": "Partner or former partner; Child; Close friend; Trusted colleague; Members of a support network; A mentor figure.", // New examples
                "bond_name_label": "Bond Relationship", // Reworded
                "bond_score_label": "Initial Score", // Reworded
                "step4_2_motivations_title": "Step 4.2: Establish Motivations (up to 5)", // More active
                "step4_info_motivations1": "Motivations are the personal beliefs, drives, or core principles that guide your agent. These can evolve as your agent's experiences shape them during play.",
                "step4_info_motivations2": "Should an agent's Sanity drop to their Breaking Point, one Motivation is typically replaced by a newly acquired mental disorder.",
                "motivation_label": "Motivation",
                "alert_define_bonds": "Please provide a brief description for each of your agent's Bonds.",

                "summary_title": "Agent Dossier Summary", // Slightly reworded
                "profession_label": "Profession",
                "statistics_label": "Statistics",
                "derived_attributes_label": "Derived Attributes",
                "skills_label": "Skills",
                "bonds_summary_label": "Bonds",
                "motivations_summary_label": "Motivations",
                "not_selected": "Not Yet Selected",
                "not_defined": "Not Yet Defined",
                "btn_print_summary": "Print Dossier", // Reworded
                "btn_download_txt": "Download as TXT",

                "summary_section_personal_details": "Personal Details",
                "summary_section_profession": "Profession",
                "summary_section_statistics": "Statistics",
                "summary_section_derived_attr": "Derived Attributes",
                "summary_section_skills": "Skills",
                "summary_section_bonds": "Bonds",
                "summary_section_motivations": "Motivations",

                "summary_placeholder_name": "Name: _______________",
                "summary_placeholder_age": "Age: __________",
                "summary_placeholder_sex": "Sex: __________",
                "summary_placeholder_employer": "Employer: ________________________",
                "summary_placeholder_nationality": "Nationality: _____________________",

                "profession_custom_build_name": "Custom Profession Build", // Reworded
                "custom_prof_title_bond_setup": "Custom Profession: Part 1 - Define Bonds & Base Skill Points", // Reworded
                "custom_prof_info_rules_title": "Guidelines for Creating a Custom Profession:", // Reworded
                "custom_prof_info_pick_skills": "Select ten core skills that define this new profession.",
                "custom_prof_info_divide_points": "You have <strong>{totalPoints}</strong> points (base 400, modified by Bonds) to allocate among these ten professional skills.",
                "custom_prof_info_add_to_start": "These allocated points are added to each skill's default starting (base) rating.",
                "custom_prof_info_rule_of_thumb": "As a general guideline, aim for professional skill ratings between 30% and 50% after adding these points.",
                "custom_prof_info_max_skill": "No skill chosen as professional can exceed 60% from this initial point allocation (base + allocated).",
                "custom_prof_info_default_bonds": "A custom profession starts with 3 Bonds by default.",
                "custom_prof_info_customize_bonds": "Adjust Bonds: Gain 50 professional skill points for each Bond removed (minimum 1). Lose 50 points for each Bond added (maximum 4).",
                "custom_prof_label_current_bonds": "Current Bonds:",
                "label_custom_profession_name": "Define Profession Name:", // Reworded
                "custom_prof_label_skill_point_budget": "Total Professional Skill Points:", // Reworded
                "custom_prof_btn_confirm_bonds": "Confirm Bonds & Continue to Skill Allocation", // Reworded
                "custom_prof_title_skill_allocation": "Custom Profession: Part 2 - Allocate Skill Points", // Reworded
                "custom_prof_info_skill_allocation": "Choose up to ten professional skills and assign your <strong>{currentBudget}</strong> skill points. Remember, no skill can exceed 60% (base + allocated). Points Remaining: <strong id='custom-skill-points-remaining'>{remainingPoints}</strong>",
                "custom_prof_skills_selected_label_prefix": "Professional Skills Chosen:", // Reworded
                "custom_prof_label_assign_points": "Allocate Points:", // Reworded
                "custom_prof_label_skill_total": "Resulting Total:", // Reworded
                "custom_prof_btn_confirm_skills": "Finalize Professional Skills", // Reworded
                "alert_max_10_custom_skills": "You must select 10 professional skills.", // Adjusted based on common interpretation
                "alert_distribute_all_custom_points": "All {totalBudget} professional skill points must be allocated. You have {remainingPoints} points left.",
                "alert_custom_skill_max_60": "The skill \"{skillName}\" cannot be raised above 60% through professional point allocation.",
                "alert_specify_type_for_custom_skill": "Please define a specific type for the custom professional skill \"{skillName}\".",
                // Note: The duplicate "step2_info_stats" and stat descriptions were already in your list. I've kept them.
                // If they are truly redundant and only one set is used, you can remove the duplicates.
                // I've assumed the second set of stat_..._desc is the one displayed in step 2.
                "step2_info_stats": "An agent's six statistics reflect his or her physical and mental abilities. Values range from 3 to 18.", // This key is duplicated, ensure only one is used or make them unique if context differs.
                
                "stat_str_name": "Strength (STR)", "stat_str_desc": "Measures raw physical might and lifting capacity.", // Slightly different from above
                "stat_con_name": "Constitution (CON)", "stat_con_desc": "Reflects health, resilience to harm, and endurance.", // Slightly different
                "stat_dex_name": "Dexterity (DEX)", "stat_dex_desc": "Denotes agility, hand-eye coordination, and reflexes.", // Slightly different
                "stat_int_name": "Intelligence (INT)", "stat_int_desc": "Governs reasoning, memory, intuition, and analytical skills.", // Slightly different
                "stat_pow_name": "Power (POW)", "stat_pow_desc": "Represents willpower, mental strength, and potential for unusual abilities.", // Slightly different
                "stat_cha_name": "Charisma (CHA)", "stat_cha_desc": "Indicates personal magnetism, leadership qualities, and social influence.", // Slightly different
                "step2_select_array_label": "Step 2.1: Select an array of values to distribute among these statistics.", // Reworded
                "step2_assign_stats_label": "Step 2.2: Assign the selected values to your Statistics:", // Reworded
                "step2_stat_value_label": "Value",
                "step2_stat_x5_label": "x5 Rating", // Reworded
                "step2_info_distinguishing_feature": "If a statistic's value is 8 or lower, or 13 or higher, it is particularly noteworthy. Provide a brief adjective or phrase to describe this characteristic.", // Reworded, slightly different thresholds if that was intended. The original was <9 or >12.
                "distinguishing_feature_label": "Defining Trait:", // Already reworded
                "distinguishing_feature_placeholder": "e.g., Hulking, Frail, Perceptive, Obsessive", // New examples
                "alert_select_stat_array": "You must first select a stat array.",
                "alert_assign_all_stats": "Please assign a value from the array to each statistic.",
                "alert_unique_stat_values": "Each value from the chosen stat array can only be used once per statistic assignment.",
                "stat_array_option_label": "{values}", // Slightly reworded placeholder text

                "step3_info_derived_title": "Step 3: Determine Derived Attributes", // More active
                "step3_info_derived_intro": "These attributes are directly calculated based on your agent's primary statistic scores, providing further definition to their capabilities.",
                "attr_hp_name": "Hit Points (HP)",
                "attr_hp_desc": "Represents an agent's ability to endure physical trauma. Calculated as (STR + CON) ÷ 2, rounding up.",
                "attr_wp_name": "Willpower Points (WP)",
                "attr_wp_desc": "Indicates mental resilience and the capacity to push through adversity. Equal to the POW score.",
                "attr_san_name": "Sanity (SAN)",
                "attr_san_desc": "Measures an agent's mental stability and connection to consensual reality. Calculated as POW × 5.",
                "attr_bp_name": "Breaking Point (BP)",
                "attr_bp_desc": "The Sanity level at which significant trauma risks inflicting a new, lasting mental disorder. Calculated as SAN - POW.",
                "derived_attribute_label": "Attribute",
                "derived_value_label": "Value",
                "derived_description_label": "Description",

                "step4_title_bonds_motivations": "Step 4: Detail Bonds and Motivations", // More active
                "step4_info_bonds_mot_intro": "Beyond capabilities, an agent is defined by their personal connections (Bonds) and their inner drives (Motivations). These elements add crucial depth to your character.",

                "step4_1_bonds_title": "Step 4.1: Establish Bonds", // More active
                "step4_info_bonds1": "Bonds represent the vital human connections in your agent's life. These can be specific individuals (like a spouse, child, or mentor) or tightly-knit groups (such as a former military unit or a close-knit family).",
                "step4_info_bonds2": "The initial score for each Bond is determined by the agent's Charisma (CHA). As a Bond's score decreases, the relationship it represents deteriorates.",
                "step4_info_bonds3": "The nature of an agent's profession can affect the number of Bonds they can realistically maintain. Refer to your chosen profession for the specific count, or the number you set if creating a custom one.",
                "step4_info_bonds4": "For now, each Bond needs a brief description identifying the person or group and the nature of the connection, e.g., “My estranged wife, Sarah” or “Sgt. Miller, my old squad leader.”",
                "bond_examples_label": "Illustrative Bond Examples:", // Reworded
                "bond_examples_list": "Spouse/Ex-spouse; Son/Daughter; Close sibling; Lifelong best friend; Key professional contact; Therapist; Family unit (e.g., spouse and children); Close-knit work team; Shared trauma survivors group.", // Reworded and expanded
                "bond_label_number": "Bond {number}",
                "bond_description_placeholder": "e.g., My partner, Alex Chen", // New example
                "bond_score_label": "Starting Score (CHA):",
                "num_bonds_for_profession": "Your chosen profession allows for {count} Bonds.",

                "step4_2_motivations_title": "Step 4.2: Define Motivations", // More active
                "step4_info_motivations1": "Motivations are the core beliefs, personal drives, or even obsessions that compel your agent. What truly makes them persevere? Is it a desire for knowledge, loyalty to a cause, a cherished hobby, or something more complex?",
                "step4_info_motivations2": "You can define up to five initial motivations. These may change or be replaced as your agent confronts the horrors of their work and their personality develops.",
                "step4_info_motivations3": "When an agent's Sanity reaches their Breaking Point due to trauma, a Motivation is usually replaced by a new mental disorder, reflecting the toll of their experiences.",
                "motivation_label_number": "Motivation {number}",
                "motivation_placeholder": "e.g., Uncover the truth, no matter the cost" // New example
            },
            de: {
                "page_title": "Delta Green Agenten-Ersteller | Fan Projekt",
                "app_header": "Delta Green Agenten Ersteller",
                "footer_text": "Published by arrangement with the Delta Green Partnership. The intellectual property known as Delta Green is a trademark and copyright owned by the Delta Green Partnership, who has licensed its use here. This includes all elements that are components of the Delta Green intellectual property. – This website uses counter.dev, a privacy-friendly visitor counter. No personal data is collected, no cookies are set, and no IP addresses are stored. The analysis is anonymized and serves only as a rough estimate of page views.",
                "btn_back_text": "Zurück",
                "btn_next_text": "Weiter",
                "btn_finish_text": "Zusammenfassung ansehen",
                "progress_bar_text": "Schritt {current} von {total}: {stepName}",
                "select_one_option": "-- Bitte wählen --",
                "specify_type_placeholder": "Typ angeben (z.B. Physik, Französisch, Schauspiel)",
                "choose_one_label": "Wähle eine Option",
                "choose_N_label": "Wähle {N} der folgenden Optionen",

                "intro_quote_dg": "Die Erschaffung deines Delta Green Agenten umfasst mehrere Kernphasen: die Wahl eines Berufs und der damit verbundenen Fertigkeiten, die Festlegung der sechs primären Attribute zur Berechnung weiterer Werte und schließlich die Definition deiner persönlichen Beziehungen und Motivationen.",
                "intro_welcome_text": "Willkommen beim Agentenakten-Ersteller für Delta Green. Klicke auf 'Weiter', um mit der Gestaltung deines Agenten zu beginnen.",
                "step_name_0": "Einleitung",
                "step_name_1": "Beruf & Fertigkeiten",
                "step_name_2": "Attribute",
                "step_name_3": "Abgeleitete Werte",
                "step_name_4": "Beziehungen & Motivationen",
                "step_name_5": "Zusammenfassung",

                "step1_info1": "Dein Beruf ist grundlegend. Er beeinflusst deine Fertigkeiten, die anfängliche Anzahl deiner zwischenmenschlichen Beziehungen, verfügbare Ressourcen sowie den Umfang deiner Befugnisse und Pflichten. Die unten aufgeführten Berufe stellen gängige Hintergründe für Delta Green Agenten dar.",
                "step1_info2": "Jeder Beruf bringt eine spezifische Liste von Fertigkeiten mit Anfangswerten mit, die die Standard-Basiswerte ersetzen. Zusätzlich zu diesen professionellen Fertigkeiten kannst du 8 Punkte (jeder +20%) auf beliebige Fertigkeiten deines Charakterbogens verteilen. Eine einzelne Fertigkeit kann mehrfach verbessert werden, aber keine Fertigkeit darf zu Beginn einen Wert von 80% übersteigen.",
                "step1_select_profession_label": "Schritt 1.1: Beruf wählen",
                "step1_2_profession_specific_label": "Schritt 1.2: Berufsspezifische Optionen",
                "bonds_label": "Beziehungen",
                "step1_increase_skills_label": "Schritt 1.3: Fertigkeitsverbesserungen verteilen (8 verfügbar, je +20%)",
                "increases_chosen_label": "Verbesserungen angewendet:",
                "alert_select_profession": "Bitte wähle einen Beruf, um fortzufahren.",
                "alert_max_choices_reached": "Du hast das Maximum von {N} Auswahlmöglichkeiten für diese Kategorie erreicht.",
                "alert_skill_increase_limit": "Alle 8 Fertigkeitsverbesserungen wurden eingesetzt.",
                "alert_skill_max_value_reached": "Der Wert dieser Fertigkeit darf bei Charaktererschaffung 80% nicht übersteigen.",
                "alert_type_for_skill_needed": "Für die Fertigkeit \"{skillName}\" muss ein spezifischer Typ angegeben werden.",

                "profession_anthropologist_name": "Anthropologe, Archäologe oder Historiker",
                "profession_computer_scientist_name": "Informatiker oder Ingenieur",
                "profession_federal_agent_name": "Bundesagent",
                "profession_physician_name": "Arzt",
                "profession_scientist_name": "Wissenschaftler",
                "profession_special_operator_name": "Spezialeinsatzkraft",

                "add_specialization_button_text": "Spezialisierung für {skillName} hinzufügen",
"remove_button_title": "Diese Spezialisierung entfernen",

                "skill_accounting_name": "Buchhaltung", "skill_accounting_desc": "Verständnis von Finanzunterlagen, Geschäftspraktiken und Aufdeckung fiskalischer Unregelmäßigkeiten.",
                "skill_alertness_name": "Wachsamkeit", "skill_alertness_desc": "Wahrnehmung subtiler Details, potenzieller Bedrohungen oder das Bemerken von Ungewöhnlichem.",
                "skill_anthropology_name": "Anthropologie", "skill_anthropology_desc": "Die akademische Untersuchung menschlicher Gesellschaften, Kulturen und deren Entwicklung.",
                "skill_archeology_name": "Archäologie", "skill_archeology_desc": "Erforschung der Menschheitsgeschichte durch Ausgrabung und Analyse von Artefakten.",
                "skill_art_name": "Kunst", "skill_art_desc": "Fertigkeit in der Ausübung einer Kunstform (z.B. Malerei, Musik, Theater).",
                "skill_artillery_name": "Artillerie", "skill_artillery_desc": "Bedienung schwerer Projektilwaffen wie Mörser oder Raketenwerfer.",
                "skill_athletics_name": "Athletik", "skill_athletics_desc": "Körperliche Leistungsfähigkeit in Bereichen wie Laufen, Springen oder Klettern.",
                "skill_bureaucracy_name": "Bürokratie", "skill_bureaucracy_desc": "Navigation durch komplexe Organisationen und Beeinflussung offizieller Kanäle.",
                "skill_computer_science_name": "Informatik", "skill_computer_science_desc": "Tiefgehendes Wissen über Computer, Systeme und Datenanalyse.",
                "skill_craft_name": "Handwerk", "skill_craft_desc": "Geschick in einem spezifischen Handwerk (z.B. Mechanik, Elektronik, Schlossknacken).",
                "skill_criminology_name": "Kriminologie", "skill_criminology_desc": "Wissen über kriminelles Verhalten, Ermittlungsmethoden und konspirative Strukturen.",
                "skill_demolitions_name": "Sprengwesen", "skill_demolitions_desc": "Sicherer und effektiver Einsatz von Sprengstoffen.",
                "skill_disguise_name": "Verkleiden", "skill_disguise_desc": "Veränderung von Aussehen und Verhalten zur Tarnung oder Imitation.",
                "skill_dodge_name": "Ausweichen", "skill_dodge_desc": "Instinktives Entkommen vor physischen Angriffen oder Gefahren.",
                "skill_drive_name": "Fahren", "skill_drive_desc": "Sichere Steuerung von Kraftfahrzeugen, besonders unter Druck.",
                "skill_firearms_name": "Schusswaffen", "skill_firearms_desc": "Präziser und sicherer Umgang mit Handfeuerwaffen im Kampf.",
                "skill_first_aid_name": "Erste Hilfe", "skill_first_aid_desc": "Sofortige medizinische Versorgung zur Stabilisierung von Verletzungen.",
                "skill_foreign_language_name": "Fremdsprache", "skill_foreign_language_desc": "Beherrschung einer anderen Sprache (Sprache angeben).",
                "skill_forensics_name": "Forensik", "skill_forensics_desc": "Sammlung und Analyse von physischen Beweismitteln.",
                "skill_heavy_machinery_name": "Schwere Maschinen", "skill_heavy_machinery_desc": "Bedienung großer oder komplexer Maschinen (z.B. Baumaschinen).",
                "skill_heavy_weapons_name": "Schwere Waffen", "skill_heavy_weapons_desc": "Umgang mit tragbaren schweren Waffen wie Maschinengewehren.",
                "skill_history_name": "Geschichte", "skill_history_desc": "Wissen über vergangene Ereignisse und Gesellschaften (Spezialisierung möglich).",
                "skill_humint_name": "HUMINT", "skill_humint_desc": "Zwischenmenschlichen Interaktionen lesen und bewerten.",
                "skill_law_name": "Rechtswesen", "skill_law_desc": "Verständnis und Anwendung von Gesetzen und juristischen Prozessen.",
                "skill_medicine_name": "Medizin", "skill_medicine_desc": "Fortgeschrittene Diagnose und Behandlung von Krankheiten und Verletzungen.",
                "skill_melee_weapons_name": "Nahkampfwaffen", "skill_melee_weapons_desc": "Effektiver Einsatz von Waffen im Nahkampf (Messer, Schlagstöcke etc.).",
                "skill_military_science_name": "Militärwissenschaft", "skill_military_science_desc": "Kenntnisse über militärische Taktiken und Strukturen (Spezialisierung angeben).",
                "skill_navigate_name": "Navigation", "skill_navigate_desc": "Positionsbestimmung und Routenplanung mit Karten oder anderen Hilfsmitteln.",
                "skill_occult_name": "Okkultismus", "skill_occult_desc": "Wissen über esoterische Lehren, paranormale Phänomene und Geheimbünde.",
                "skill_persuade_name": "Überzeugen", "skill_persuade_desc": "Beeinflussung anderer durch Argumentation, Charme oder Verhandlung.",
                "skill_pharmacy_name": "Pharmazie", "skill_pharmacy_desc": "Kenntnisse über Medikamente, deren Wirkungen und Herstellung.",
                "skill_pilot_name": "Pilot", "skill_pilot_desc": "Steuerung von Luft-, Wasser- oder Raumfahrzeugen (Typ angeben).",
                "skill_psychotherapy_name": "Psychotherapie", "skill_psychotherapy_desc": "Diagnose und Behandlung von psychischen Erkrankungen.",
                "skill_ride_name": "Reiten", "skill_ride_desc": "Umgang mit und Reiten von Tieren, typischerweise Pferden.",
                "skill_science_name": "Wissenschaft", "skill_science_desc": "Expertise in einem spezifischen wissenschaftlichen Bereich (z.B. Biologie, Chemie).",
                "skill_search_name": "Suchen", "skill_search_desc": "Systematisches Auffinden versteckter Objekte, Informationen oder Personen.",
                "skill_sigint_name": "SIGINT", "skill_sigint_desc": "Fernmeldeaufklärung: Abfangen und Analysieren elektronischer Kommunikation.",
                "skill_stealth_name": "Heimlichkeit", "skill_stealth_desc": "Unauffälliges Bewegen und Handeln, um nicht entdeckt zu werden.",
                "skill_surgery_name": "Chirurgie", "skill_surgery_desc": "Durchführung invasiver medizinischer Eingriffe.",
                "skill_survival_name": "Überleben", "skill_survival_desc": "Sicherung des eigenen Überlebens in feindlichen Umgebungen.",
                "skill_swim_name": "Schwimmen", "skill_swim_desc": "Fortbewegung im Wasser, besonders unter schwierigen Bedingungen.",
                "skill_unarmed_combat_name": "Unbewaffneter Kampf", "skill_unarmed_combat_desc": "Effektive Selbstverteidigung und Kampf ohne Waffen.",
                "skill_unnatural_name": "Das Unnatürliche", "skill_unnatural_desc": "Verständnis der fundamentalen, verstandeszerreißenden Geheimnisse der Realität.",

                "step2_info_stats": "Die sechs Kernattribute deines Agenten definieren seine angeborenen physischen und mentalen Kapazitäten. Diese Werte liegen typischerweise zwischen 3 und 18.",
                "stat_str_name": "Stärke (ST)", "stat_str_desc": "Misst reine physische Kraft und Körperstärke.",
                "stat_con_name": "Konstitution (KO)", "stat_con_desc": "Zeigt deine Gesundheit, Widerstandsfähigkeit und Ausdauer an.",
                "stat_dex_name": "Geschicklichkeit (GE)", "stat_dex_desc": "Spiegelt deine Agilität, Koordination und Reaktionsgeschwindigkeit wider.",
                "stat_int_name": "Intelligenz (IN)", "stat_int_desc": "Repräsentiert deine Denkfähigkeit, dein Gedächtnis und deine Problemlösungskompetenz.",
                "stat_pow_name": "Willenskraft (WK)", "stat_pow_desc": "Bedeutet Willensstärke, mentale Widerstandskraft und psychisches Potenzial.",
                "stat_cha_name": "Charisma (CH)", "stat_cha_desc": "Misst deine Persönlichkeitsstärke, Überzeugungskraft und soziale Ausstrahlung.",
                "step2_select_array_label": "Schritt 2.1: Attributwerte-Gruppe wählen",
                "step2_assign_stats_label": "Schritt 2.2: Gewählte Werte deinen Attributen zuweisen:",
                "step2_info_percentile": "Notiere für jedes Attribut dessen Prozentwert (Attributwert × 5). Ist ein Attribut auffallend niedrig (unter 9) oder hoch (über 12), gilt es als dein hervorstechendes Merkmal. Beschreibe dieses kurz.",
                "distinguishing_feature_label": "Prägendes Merkmal:",
                "distinguishing_feature_placeholder": "z.B. Drahtig, Unbeholfen, Scharfsinnig, Zerstreut",
                "alert_assign_all_stats": "Stelle sicher, dass du jedem Attribut einen Wert zugewiesen hast.",
                "alert_unique_stat_values": "Jeder Wert aus der gewählten Gruppe darf nur einmal einem Attribut zugewiesen werden.",

                "step3_info_derived": "Abgeleitete Werte sind sekundäre Eigenschaften, die aus deinen Primärattributen berechnet werden.",
                "attr_hp_name": "Trefferpunkte (TP)", "attr_hp_desc": "Geben deine Fähigkeit an, physischen Schaden zu widerstehen. Berechnet als (ST + KO) / 2, aufgerundet.",
                "attr_wp_name": "Willenskraftpunkte (WP)", "attr_wp_desc": "Repräsentieren deine mentale Energie und Entschlossenheit. Dieser Wert entspricht deinem WK-Attribut.",
                "attr_san_name": "Stabilität (STA)", "attr_san_desc": "Misst deinen Bezug zur konventionellen Realität. Berechnet als WK × 5.",
                "attr_bp_name": "Belastungsgrenze (BG)", "attr_bp_desc": "Der Stabilitäts-Schwellenwert, bei dem weiteres Trauma eine neue psychische Störung bei dir auslösen kann. Berechnet als STA - WK.",
                "derived_attributes_title": "Schritt 3: Abgeleitete Werte",

                "step4_info_bonds_mot": "Während Beruf, Fertigkeiten und Attribute deine Fähigkeiten umreißen, verleihen dir deine Beziehungen und Motivationen als Individuum Tiefe.",
                "step4_1_bonds_title": "Schritt 4.1: Beziehungen definieren",
                "step4_info_bonds1": "Eine Beziehung stellt eine entscheidende menschliche Verbindung in deinem Leben dar. Jede Beziehung beginnt mit einem Wert, der deinem Charisma (CH) entspricht.",
                "step4_info_bonds2": "Anspruchsvolle Berufe schränken oft die Anzahl der Beziehungen ein, die du pflegen kannst. Zu Beginn benötigen deine Beziehungen nur einen Namen und die Art der Beziehung.",
                "bond_examples_label": "Beispiele für Beziehungen:",
                "bond_examples_list": "Partner/Ex-Partner; Kind; Enger Freund; Vertrauter Kollege; Mitglieder deines Unterstützungsnetzwerks; Eine Mentorenfigur.",
                "bond_name_label": "Beziehungsbeschreibung",
                "bond_score_label": "Anfangswert",
                "step4_2_motivations_title": "Schritt 4.2: Motivationen festlegen (bis zu 5)",
                "step4_info_motivations1": "Motivationen sind deine persönlichen Überzeugungen, Antriebe oder Kernprinzipien, die dich leiten. Diese können sich entwickeln, während deine Erfahrungen dich im Spiel formen.",
                "step4_info_motivations2": "Sollte deine Stabilität auf deine Belastungsgrenze fallen, wird typischerweise eine deiner Motivationen durch eine neu erworbene psychische Störung ersetzt.",
                "motivation_label": "Motivation",
                "alert_define_bonds": "Bitte gib für jede deiner Beziehungen eine kurze Beschreibung an.",

                "summary_title": "Zusammenfassung deiner Agentenakte",
                "profession_label": "Beruf",
                "statistics_label": "Attribute",
                "derived_attributes_label": "Abgeleitete Werte",
                "skills_label": "Fertigkeiten",
                "bonds_summary_label": "Beziehungen",
                "motivations_summary_label": "Motivationen",
                "not_selected": "Noch nicht gewählt",
                "not_defined": "Noch nicht definiert",
                "btn_print_summary": "Akte drucken",
                "btn_download_txt": "Als TXT herunterladen",

                "summary_section_personal_details": "Persönliche Daten",
                "summary_section_profession": "Beruf",
                "summary_section_statistics": "Attribute",
                "summary_section_derived_attr": "Abgeleitete Werte",
                "summary_section_skills": "Fertigkeiten",
                "summary_section_bonds": "Beziehungen",
                "summary_section_motivations": "Motivationen",

                "summary_placeholder_name": "Name: _______________",
                "summary_placeholder_age": "Alter: __________",
                "summary_placeholder_sex": "Geschlecht: __________",
                "summary_placeholder_employer": "Arbeitgeber: ________________________",
                "summary_placeholder_nationality": "Nationalität: _____________________",

                "profession_custom_build_name": "Eigenen Beruf erstellen",
                "label_custom_profession_name": "Benenne deinen Beruf:",
                "custom_prof_title_bond_setup": "Eigener Beruf: Teil 1 - Beziehungen & Fertigkeitspunkte definieren",
                "custom_prof_info_rules_title": "Richtlinien zur Erstellung deines eigenen Berufs:",
                "custom_prof_info_pick_skills": "Wähle zehn Kernfertigkeiten, die diesen neuen Beruf definieren.",
                "custom_prof_info_divide_points": "Du hast <strong>{totalPoints}</strong> Punkte (Basis 400, durch Beziehungen modifiziert) zur Verteilung auf diese zehn Berufsfertigkeiten.",
                "custom_prof_info_add_to_start": "Wähle jetzt deine Berufsfertigkeiten und weise ihnen Punkte zu. Die zugewiesenen Punkte werden zum Standard-Anfangswert (Basiswert) jeder Fertigkeit addiert.",
                "custom_prof_info_rule_of_thumb": "Als allgemeine Richtlinie sollten deine Berufsfertigkeiten nach Hinzufügung dieser Punkte zwischen 30% und 50% liegen.",
                "custom_prof_info_max_skill": "Keine als beruflich gewählte Fertigkeit darf durch diese anfängliche Punktevergabe 60% übersteigen (Basis + zugewiesene Punkte).",
                "custom_prof_info_default_bonds": "Ein eigener Beruf beginnt standardmäßig mit 3 Beziehungen.",
                "custom_prof_info_customize_bonds": "Passe deine Beziehungen an: Erhalte 50 Berufsfertigkeitspunkte für jede entfernte Beziehung (Minimum 1). Verliere 50 Punkte für jede hinzugefügte Beziehung (Maximum 4).",
                "custom_prof_label_current_bonds": "Deine aktuellen Beziehungen:",
                "custom_prof_label_skill_point_budget": "Deine gesamten Berufsfertigkeitspunkte:",
                "custom_prof_btn_confirm_bonds": "Beziehungen bestätigen & Weiter zur Fertigkeitszuweisung",
                "custom_prof_title_skill_allocation": "Eigener Beruf: Teil 2 - Fertigkeitspunkte zuweisen",
                "custom_prof_info_skill_allocation": "Wähle bis zu zehn Berufsfertigkeiten und verteile deine <strong>{currentBudget}</strong> Fertigkeitspunkte. Denke daran, keine Fertigkeit darf 60% übersteigen (Basis + zugewiesen). Verbleibende Punkte: <strong id='custom-skill-points-remaining'>{remainingPoints}</strong>",
                "custom_prof_skills_selected_label_prefix": "Deine gewählten Berufsfertigkeiten:",
                "custom_prof_label_assign_points": "Punkte zuweisen:",
                "custom_prof_label_skill_total": "Resultierender Gesamtwert:",
                "custom_prof_btn_confirm_skills": "Berufsfertigkeiten bestätigen",
                "alert_max_10_custom_skills": "Du musst 10 Berufsfertigkeiten wählen.",
                "alert_distribute_all_custom_points": "Alle {totalBudget} Berufsfertigkeitspunkte müssen zugewiesen werden. Du hast noch {remainingPoints} Punkte übrig.",
                "alert_custom_skill_max_60": "Die Fertigkeit \"{skillName}\" kann durch Zuweisung von Berufsfertigkeitspunkten nicht über 60% erhöht werden.",
                "alert_specify_type_for_custom_skill": "Bitte definiere einen spezifischen Typ für deine eigene Berufsfertigkeit \"{skillName}\".",

                "step2_select_array_label": "Schritt 2.1: Eine Gruppe von Werten wählen, um sie auf deine Attribute zu verteilen.",
                "step2_assign_stats_label": "Schritt 2.2: Die gewählten Werte deinen Attributen zuweisen:",
                "step2_stat_value_label": "Wert",
                "step2_stat_x5_label": "x5 Wert",
                "step2_info_distinguishing_feature": "Wenn der Wert eines deiner Attribute 8 oder niedriger bzw. 13 oder höher ist, ist es besonders bemerkenswert. Gib ein kurzes Adjektiv oder eine Phrase zur Beschreibung dieser Eigenschaft an.",
                "alert_select_stat_array": "Du musst zuerst eine Attributwerte-Gruppe auswählen.",
                "alert_assign_all_stats": "Bitte weise jedem deiner Attribute einen Wert aus der Gruppe zu.",
                "alert_unique_stat_values": "Jeder Wert aus der gewählten Attributwerte-Gruppe darf nur einmal für die Attribute verwendet werden.",
                "stat_array_option_label": "{values}",

                "step3_info_derived_title": "Schritt 3: Abgeleitete Werte bestimmen",
                "step3_info_derived_intro": "Diese Werte werden direkt auf Basis deiner Primärattribute berechnet und definieren deine Fähigkeiten weiter.",
                "attr_hp_desc": "Stellt deine Fähigkeit dar, körperliches Trauma zu ertragen. Berechnet als (ST + KO) ÷ 2, aufgerundet.",
                "attr_wp_desc": "Zeigt deine mentale Widerstandsfähigkeit und die Fähigkeit, Widrigkeiten zu überwinden. Entspricht deinem WK-Wert.",
                "attr_san_desc": "Misst deine mentale Stabilität und deine Verbindung zur allgemeinen Realität. Berechnet als WK × 5.",
                "attr_bp_desc": "Das Stabilitätsniveau, bei dem erhebliches Trauma eine neue, bleibende psychische Störung bei dir verursachen kann. Berechnet als STA - WK.",
                "derived_attribute_label": "Abgeleiteter Wert",
                "derived_value_label": "Wert",
                "derived_description_label": "Beschreibung",

                "step4_title_bonds_motivations": "Schritt 4: Beziehungen und Motivationen detaillieren",
                "step4_info_bonds_mot_intro": "Über die reinen Fähigkeiten hinaus wirst du durch deine persönlichen VerBeziehungen (Beziehungen) und deine inneren Antriebe (Motivationen) definiert. Diese Elemente verleihen deinem Charakter entscheidende Tiefe.",

                "step4_1_bonds_title": "Schritt 4.1: Beziehungen festlegen",
                "step4_info_bonds1": "Beziehungen repräsentieren die wichtigsten menschlichen Beziehungen in deinem Leben. Dies können bestimmte Personen (wie Ehepartner, Kind oder Mentor) oder eng verbundene Gruppen sein (wie eine ehemalige Militäreinheit oder deine Familie).",
                "step4_info_bonds2": "Der Anfangswert jeder Beziehung wird durch dein Charisma (CH) bestimmt. Sinkt der Wert einer Beziehung, verschlechtert sich die Beziehung, die sie darstellt.",
                "step4_info_bonds3": "Die Art deines Berufs kann die Anzahl der Beziehungen beeinflussen, die du realistischerweise aufrechterhalten kannst. Die genaue Anzahl entnimmst du deinem gewählten Beruf oder der von dir festgelegten Zahl, falls du einen eigenen Beruf erstellst.",
                "step4_info_bonds4": "Vorerst benötigt jede Beziehung eine kurze Beschreibung, die die Person oder Gruppe und die Art eurer Verbindung identifiziert, z.B. „Meine entfremdete Frau, Sarah“ oder „Sgt. Miller, mein alter Truppführer.“",
                "bond_examples_label": "Veranschaulichende Beispiele für Beziehungen:",
                "bond_examples_list": "Ehepartner/Ex-Partner; Sohn/Tochter; Enges Geschwisterkind; Bester Freund/Beste Freundin seit Langem; Wichtiger beruflicher Kontakt; Therapeut; Familieneinheit (z.B. Partner und Kinder); Eng verbundenes Arbeitsteam; Gruppe von Überlebenden eines gemeinsamen Traumas.",
                "bond_label_number": "Beziehung {number}",
                "bond_description_placeholder": "z.B. Mein Partner, Alex Chen",
                "bond_score_label": "Anfangswert (CH):",
                "num_bonds_for_profession": "Dein gewählter Beruf ermöglicht {count} Beziehungen.",

                "step4_2_motivations_title": "Schritt 4.2: Motivationen definieren",
                "step4_info_motivations1": "Motivationen sind deine Kernüberzeugungen, persönlichen Antriebe oder sogar Obsessionen, die dich bewegen. Was treibt dich wirklich an? Ist es Wissensdurst, Loyalität zu einer Sache, ein geschätztes Hobby oder etwas Komplexeres?",
                "step4_info_motivations2": "Du kannst bis zu fünf anfängliche Motivationen definieren. Diese können sich ändern oder ersetzt werden, wenn du mit den Schrecken deiner Arbeit konfrontiert wirst und sich deine Persönlichkeit entwickelt.",
                "step4_info_motivations3": "Wenn deine Stabilität aufgrund eines Traumas deine Belastungsgrenze erreicht, wird eine deiner Motivationen üblicherweise durch eine neue psychische Störung ersetzt, was den Tribut deiner Erfahrungen widerspiegelt.",
                "motivation_label_number": "Motivation {number}",
                "motivation_placeholder": "z.B. Die Wahrheit aufdecken, egal was es kostet"
            }
        };

        // --- LOGIK: i18n (Internationalization) ---
        const translations = {};
        let currentLanguage = 'en';

        function setupTranslations() {
            if (i18nData && i18nData.en) translations.en = i18nData.en;
            if (i18nData && i18nData.de) translations.de = i18nData.de;
        }

        function t(key, replacements = {}) {
            if (typeof key !== 'string' || key === "") return "";
            let translationString;
            if (translations[currentLanguage] && translations[currentLanguage][key] !== undefined) {
                translationString = translations[currentLanguage][key];
            } else if (translations['en'] && translations['en'][key] !== undefined) {
                translationString = translations['en'][key];
            } else {
                return `[[${key}]]`;
            }
            if (typeof translationString !== 'string') {
                return `[[${key}_TYPE_ERR]]`;
            }
            for (const placeholder in replacements) {
                if (replacements.hasOwnProperty(placeholder)) {
                    translationString = translationString.replace(new RegExp(`{${placeholder}}`, 'g'), replacements[placeholder]);
                }
            }
            return translationString;
        }
        
        function applyTranslationsToElement(el, key, directReplacements = {}) {
                let replacements = { ...directReplacements }; // Starte mit direkt übergebenen Ersetzungen

                // Versuche, zusätzliche Ersetzungen aus dem data-Attribut zu lesen
                const attrReplacementsString = el.getAttribute('data-i18n-replacements');
                if (attrReplacementsString) {
                    try {
                        // Erwartet ein JSON-Objekt als String, z.B. '{"name": "Agent", "level": "5"}'
                        const parsedAttrReplacements = JSON.parse(attrReplacementsString);
                        // Füge die geparsten Attribute hinzu oder überschreibe sie, falls sie nicht schon direkt übergeben wurden
                        for (const rKey in parsedAttrReplacements) {
                            if (parsedAttrReplacements.hasOwnProperty(rKey) && !replacements.hasOwnProperty(rKey)) {
                                replacements[rKey] = parsedAttrReplacements[rKey];
                            }
                        }
                    } catch (e) {
                        console.warn(`Error parsing data-i18n-replacements for key "${key}": ${attrReplacementsString}`, e);
                    }
                }
                
                const translatedText = t(key, replacements);

                if (el.tagName === 'INPUT' && el.type === 'text' && el.hasAttribute('placeholder')) {
                    el.placeholder = translatedText;
                } else if (el.tagName === 'INPUT' && (el.type === 'button' || el.type === 'submit')) {
                    el.value = translatedText;
                } else if (el.tagName === 'BUTTON' || el.tagName === 'OPTION' || el.tagName === 'SPAN') { // SPAN hinzugefügt
                    el.textContent = translatedText; // Für SPANs ist textContent oft besser als innerHTML, wenn kein HTML im String ist
                } else {
                    el.innerHTML = translatedText; 
                }
            }

            function translateAllElements(container = document) {
                const charData = window.app ? window.app.getCurrentCharacterData() : null;

                container.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.getAttribute('data-i18n');
                    if (key) { 
                        let directReplacements = {}; // Direkte Ersetzungen basierend auf charData
                        if (charData) {
                            if (key === "custom_prof_info_divide_points") {
                                directReplacements.totalPoints = charData.customProfessionSkillPointBudget;
                            } else if (key === "custom_prof_info_skill_allocation") {
                                const budget = charData.customProfessionSkillPointBudget;
                                let pointsSpent = 0;
                                if (charData.customProfessionSelectedSkills && typeof charData.customProfessionSelectedSkills === 'object') {
                                   Object.values(charData.customProfessionSelectedSkills).forEach(skill => pointsSpent += (skill.points || 0) );
                                }
                                const remainingPoints = budget - pointsSpent;
                                directReplacements.currentBudget = budget;
                                directReplacements.remainingPoints = remainingPoints;
                            } else if (key === "custom_prof_skills_selected_count") {
                                directReplacements.count = charData.customProfessionSelectedSkills ? Object.keys(charData.customProfessionSelectedSkills).length : 0;
                            }
                            // Für stat_array_option_label werden die replacements direkt aus dem data-i18n-replacements Attribut gelesen
                        }
                        applyTranslationsToElement(el, key, directReplacements);
                    }
                });
            }

        function setLanguage(lang) {
            if (!translations[lang] && lang !== 'en') {
                lang = 'en';
            }
            currentLanguage = lang;
            document.documentElement.lang = lang;
            localStorage.setItem('preferredLanguage', lang);
            
            translateAllElements(); 

            if (window.app && typeof window.app.renderCurrentStep === 'function') {
                window.app.renderCurrentStep(); 
            }
            const langDeButton = document.getElementById('lang-de');
            const langEnButton = document.getElementById('lang-en');
            if (langDeButton) langDeButton.classList.toggle('active', lang === 'de');
            if (langEnButton) langEnButton.classList.toggle('active', lang === 'en');
        }

        function initI18n() {
            setupTranslations();
            let langToSet = 'en'; // Standard-Fallback ist Englisch

            // 1. Prüfe, ob eine Sprache explizit vom Nutzer im localStorage gespeichert wurde
            const storedLang = localStorage.getItem('preferredLanguage');
            if (storedLang && translations[storedLang]) {
                langToSet = storedLang;
            } else {
                // 2. Wenn nichts im localStorage, versuche die Browsersprache zu verwenden
                const browserLangFull = navigator.language || navigator.userLanguage; // navigator.language ist Standard
                if (browserLangFull) {
                    const browserLangBase = browserLangFull.split('-')[0].toLowerCase(); // z.B. "de" aus "de-DE"

                    if (browserLangBase === 'de' && translations.de) {
                        // Hier könntest du noch spezifischer auf Regionen prüfen, falls nötig,
                        // z.B. if (browserLangFull.toLowerCase().startsWith('de-de') || browserLangFull.toLowerCase().startsWith('de-at') ...)
                        // Für den Moment reicht es, wenn die Basis "de" ist und wir eine "de"-Übersetzung haben.
                        langToSet = 'de';
                    }
                    // Für alle anderen Browsersprachen bleibt langToSet 'en' (unser Fallback)
                }
            }

            currentLanguage = langToSet;
            // Die erste UI-Aktualisierung und das Setzen von document.documentElement.lang
            // erfolgt durch app.initialize() -> setLanguage(currentLanguage).
        }


        // --- LOGIK: Hauptanwendung (app) ---
        window.app = (function() {
            const MAX_SKILL_INCREASES = 8;
            const SKILL_INCREASE_AMOUNT = 20;
            const MAX_SKILL_VALUE = 80;
            const STAT_ARRAYS = [
                [13, 13, 12, 12, 11, 11],
                [15, 14, 12, 11, 10, 10],
                [17, 14, 13, 10, 10, 8]
            ];
            const STAT_KEYS = ["STR", "CON", "DEX", "INT", "POW", "CHA"];

            let currentStep = 0;
            let character = {};

            let stepContainer, progressBarContainer, btnNext, btnBack;

            function resetCharacter() {
                character = {
                    professionKey: null,
                    customProfessionName: "", // NEU: Für den Namen des Custom Berufs
                    isCustomProfession: false, 
                    customProfessionBonds: 3,  
                    customProfessionSkillPointBudget: 400, 
                    customProfessionSelectedSkills: [], // Wird jetzt ein Array von {key, typeName, points} Objekten
                    customProfessionSetupStage: 'bonds', 
                    
                    orSkillChoices: {},          // Für Standardberufe: Speichert die Wahl bei "SkillA ODER SkillB"
                    profChoiceSkillSelections: {},// Für Standardberufe: Speichert die Wahl bei Checkbox-Skills

                    skills: [],                 // WIRD JETZT EIN ARRAY VON SKILL-INSTANZ-OBJEKTEN

                    stats: { STR: 0, CON: 0, DEX: 0, INT: 0, POW: 0, CHA: 0 },
                    statArrayChoice: null,      
                    statAssignments: {},        
                    distinguishingFeatures: {}, 
                    derivedAttributes: { HP: 0, WP: 0, SAN: 0, BP: 0 },
                    bonds: [],                  
                    motivations: ["", "", "", "", ""] 
                };
                initializeCharacterSkills(); // Ruft die überarbeitete Funktion auf
            }

            // Hilfsfunktion zum Generieren einer eindeutigen ID (vereinfacht)
            function generateInstanceId(baseKey, typeName = null) {
                const typePart = typeName ? typeName.toLowerCase().replace(/\s+/g, '_') : 'general';
                return `${baseKey}_${typePart}_${Date.now().toString(36)}${Math.random().toString(36).substr(2, 5)}`;
            }

            function initializeCharacterSkills() {
                character.skills = []; // Startet als leeres Array

                for (const skillKey in ALL_SKILLS) {
                    if (ALL_SKILLS.hasOwnProperty(skillKey)) {
                        const skillDef = ALL_SKILLS[skillKey];
                        
                        // Nur nicht-typisierte Skills als Basis-Instanzen hinzufügen.
                        // Typisierte Skills werden erst hinzugefügt, wenn sie durch Beruf/Custom spezifiziert werden
                        // oder durch die +20% Sonderregel.
                        if (!skillDef.type) { 
                            character.skills.push({
                                instanceId: generateInstanceId(skillKey),
                                key: skillKey,
                                typeName: null, // Nicht-typisierte Skills haben keinen typeName
                                value: skillDef.base,
                                // baseValueFromProfession ist der Wert, der *nur* durch den Beruf kommt (ohne ALL_SKILLS.base)
                                // Für einen reinen Basis-Skill ist dieser 0.
                                baseValueFromProfession: 0, 
                                increases: 0,
                                isProfessional: false 
                            });
                        }
                        // Für typisierte Skills wird hier noch nichts gemacht.
                        // Ausnahme: Wenn wir eine "Allgemein"-Instanz für jeden typisierten Skill wollen,
                        // könnten wir sie hier mit Wert 0 hinzufügen, aber das ist vielleicht nicht ideal,
                        // da sie dann immer in der Liste wären, auch wenn nie genutzt.
                        // Besser ist, sie bei Bedarf zu erstellen (Schritt 1.3 Sonderregel).
                    }
                }
                // console.log("Initialized character.skills:", JSON.parse(JSON.stringify(character.skills)));
            }
            
            function updateSkill(skillKey, newValue, isProfessional = false, isChoiceSkill = false, typeName = undefined) {
                if (!character.skills[skillKey]) return;
                const skill = character.skills[skillKey];
                skill.value = Math.max(0, Math.min(99, newValue));
                if (isProfessional) skill.isProfessional = true;
                if (isChoiceSkill) skill.isChoiceSkill = true;
                if (typeName !== undefined) skill.typeName = typeName;
            }

            function renderIntro() {
                if (currentStep === 0) resetCharacter();
                return `
                    <div class="step" id="step-intro">
                        <div class="info-box"><p data-i18n="intro_quote_dg"></p></div>
                        <p data-i18n="intro_welcome_text"></p>
                    </div>`;
            }

            // STEP 1: PROFESSION & SKILLS (Haupt-Renderfunktion für Schritt 1)
            // renderStep1_ProfessionSkills (Anpassung für 'done' Stage)
            function renderStep1_ProfessionSkills() {
                console.log("RenderStep1 - Start. isCustom:", character.isCustomProfession, "Stage:", character.customProfessionSetupStage); // LOG
                if (character.isCustomProfession) { 
                    if (character.customProfessionSetupStage === 'bonds') {
                        console.log("RenderStep1 - Rendering Custom Bond Setup"); // LOG
                        return renderCustomProfession_BondSetup();
                    } else if (character.customProfessionSetupStage === 'skills') {
                        console.log("RenderStep1 - Rendering Custom Skill Allocation"); // LOG
                        return renderCustomProfession_SkillAllocation();
                    } else { // customProfessionSetupStage === 'done'
                        console.log("RenderStep1 - Rendering Custom Done (+20% list)"); // LOG
                        // Hier die UI für die 8x +20% Erhöhungen anzeigen
                        // HTML-Struktur für die +20% Erhöhungen
                        let html = `<div class="step" id="step1-final-skill-increases">
                            <div class="info-box">
                                <p data-i18n="step1_info2"></p>
                            </div>
                            <h3 data-i18n="step1_increase_skills_label"></h3>
                            <p style="text-align: right;"><span data-i18n="increases_chosen_label"></span> <span id="increases-chosen-count">0</span> / ${MAX_SKILL_INCREASES}</p>
                            <div id="all-skills-list-container"></div>
                        </div>`;
                        return html; 
                        // renderAllSkillsList() wird dann von attachStep1Listeners aufgerufen,
                        // nachdem dieses HTML im DOM ist.
                    }
                } else { // Standard-Beruf Logik
                    character.isCustomProfession = false; // Sicherstellen, dass das Flag korrekt ist
                    character.customProfessionSetupStage = 'bonds'; 
                    let html = `<div class="step" id="step1-profession-standard">
                        <div class="info-box">
                            <p data-i18n="step1_info1"></p>
                            <p data-i18n="step1_info2"></p>
                        </div>
                        <h2><label for="profession-select" data-i18n="step1_select_profession_label"></label></h2>
                        <select id="profession-select">
                            <option value="" data-i18n="select_one_option">${t('select_one_option')}</option>`;
                    for (const profKey in PROFESSIONS) {
                        // Stelle sicher, dass PROFESSIONS[profKey] existiert, bevor auf nameKey zugegriffen wird
                        if (PROFESSIONS[profKey] && PROFESSIONS[profKey].nameKey) {
                           html += `<option value="${profKey}" ${character.professionKey === profKey ? 'selected' : ''}>${t(PROFESSIONS[profKey].nameKey)}</option>`;
                        }
                    }
                    html += `</select>
                        <div id="profession-details-container"></div>
                        <div id="skill-increase-section" style="display: ${character.professionKey && !character.isCustomProfession ? 'block' : 'none'}; margin-top: 20px;">
                            <h3 data-i18n="step1_increase_skills_label"></h3>
                            <p style="text-align: right;"><span data-i18n="increases_chosen_label"></span> <span id="increases-chosen-count">0</span> / ${MAX_SKILL_INCREASES}</p>
                            <div id="all-skills-list-container"></div>
                        </div>
                    </div>`;
                    return html;
                }
            }

            // NEU: Render-Funktion für Custom Profession - Bond Setup
            function renderCustomProfession_BondSetup() {
                const initialTotalPoints = 400;
                character.customProfessionSkillPointBudget = initialTotalPoints - ((character.customProfessionBonds - 3) * 50);

                let html = `<div class="step" id="step1-custom-bonds">
                    <h2 data-i18n="custom_prof_title_bond_setup"></h2>
                    <div class="info-box">
                        <h3 data-i18n="custom_prof_info_rules_title"></h3>
                        
                        <p data-i18n="custom_prof_info_default_bonds"></p>
                        <p data-i18n="custom_prof_info_customize_bonds"></p>
                        <p data-i18n="custom_prof_info_divide_points" data-i18n-replacements='{"totalPoints": "${character.customProfessionSkillPointBudget}"}'></p>
                    </div>
                    <!-- NEU: Eingabefeld für Custom Profession Name -->
                    <div id="custom-profession-name-input-container" style="margin-top: 15px; ${character.professionKey === 'custom_profession' ? '' : 'display: none;'}">
                        <label for="custom-profession-name" data-i18n="label_custom_profession_name">Name your Profession:</label> 
                        <input type="text" id="custom-profession-name" value="${character.customProfessionName || ''}" placeholder="e.g., Occult Detective">
                    </div>
                    
                    <div>
                        <label data-i18n="custom_prof_label_current_bonds"></label>
                        <button id="btn-decrease-bonds" ${character.customProfessionBonds <= 1 ? 'disabled' : ''}>-</button>
                        <span id="custom-bonds-display">${character.customProfessionBonds}</span>
                        <button id="btn-increase-bonds" ${character.customProfessionBonds >= 4 ? 'disabled' : ''}>+</button>
                    </div>
                    <div>
                        <label data-i18n="custom_prof_label_skill_point_budget"></label>
                        <span id="custom-skill-budget-display">${character.customProfessionSkillPointBudget}</span>
                    </div>
                    <button id="btn-confirm-bonds" class="action-button" data-i18n="custom_prof_btn_confirm_bonds"></button>
                </div>`;
                // ... rest der Funktion ...
                return html;
            }

            // NEU: Render-Funktion für Custom Profession - Skill Allocation
            function renderCustomProfession_SkillAllocation() {
                const budget = character.customProfessionSkillPointBudget;
                let pointsSpent = 0;
                character.customProfessionSelectedSkills.forEach(inst => pointsSpent += (inst.points || 0));
                const remainingPoints = budget - pointsSpent;
                const selectedInstancesCount = character.customProfessionSelectedSkills.length;

                let html = `<div class="step" id="step1-custom-skills">
                    <h2 data-i18n="custom_prof_title_skill_allocation"></h2>
                    <div class="info-box">
                        <p id="custom-prof-skill-allocation-info" data-i18n="custom_prof_info_skill_allocation">${t('custom_prof_info_skill_allocation', {currentBudget: budget, remainingPoints: remainingPoints})}</p>
                    </div>
                    <p><span data-i18n="custom_prof_skills_selected_label_prefix">${t('custom_prof_skills_selected_label_prefix')}</span> <span id="custom-skills-selected-actual-count">${selectedInstancesCount}</span> / 10</p>
                    
                    <div id="custom-profession-skill-list">`;

                const sortedBaseSkillKeys = Object.keys(ALL_SKILLS).sort((a, b) => t(ALL_SKILLS[a].nameKey).localeCompare(t(ALL_SKILLS[b].nameKey), currentLanguage));

                sortedBaseSkillKeys.forEach(baseKey => {
                    const skillDef = ALL_SKILLS[baseKey];
                    const instancesOfThisBaseKey = character.customProfessionSelectedSkills.filter(inst => inst.key === baseKey);
                    const isBaseSkillSelectedAtLeastOnce = instancesOfThisBaseKey.length > 0;

                    html += `<div class="skill-list-item custom-skill-item-base" data-base-skill-key="${baseKey}">
                                <div class="base-skill-line" style="display: flex; align-items: center; justify-content: space-between;"> <!-- Flexbox für die Hauptzeile -->
                                    <div style="display: flex; align-items: center;"> <!-- Wrapper für Checkbox, Name und Info-Icon -->
                                        <label class="inline-label" style="margin-right: 5px;"> <!-- Weniger Margin, da Icon folgt -->
                                            <input type="checkbox" class="custom-prof-skill-select-main" 
                                                   data-skill-key="${baseKey}" 
                                                   data-is-typed="${skillDef.type ? 'true' : 'false'}"
                                                   ${isBaseSkillSelectedAtLeastOnce ? 'checked' : ''}
                                                   ${selectedInstancesCount >= 10 && !isBaseSkillSelectedAtLeastOnce ? 'disabled' : ''}>
                                            ${t(skillDef.nameKey)}
                                        </label>
                                        <!-- NEU: Skill Info Icon hier hinzufügen -->
                                        <span class="skill-info-icon" title="${t(skillDef.descKey)}">i
                                            <span class="tooltip">${t(skillDef.descKey)}</span>
                                        </span>
                                    </div>`;
                    // Button, um weitere Spezialisierungen hinzuzufügen
                    if (skillDef.type && isBaseSkillSelectedAtLeastOnce && selectedInstancesCount < 10) {
                        html += `<button class="btn-add-another-specialization action-button-small" data-skill-key="${baseKey}" style="margin-left: 10px; font-size:0.8em; padding: 2px 5px;">+ ${t('add_specialization_button_text', {skillName: t(skillDef.nameKey)})}</button>`; // i18n für Button Text
                    } else {
                        html += `<div></div>`; // Leeres Div für Flexbox-Ausrichtung, wenn kein Button da ist
                    }
                    html += `   </div> <!-- Ende .base-skill-line -->
                                <div class="skill-instances-container" data-skill-key-instances="${baseKey}">`;

                    instancesOfThisBaseKey.forEach(instance => {
                        const currentSkillTotal = skillDef.base + (instance.points || 0);
                        // Der Rest der Instanz-Controls bleibt gleich
                        html += `<div class="skill-instance-controls" data-instance-temp-id="${instance.tempInstanceId}"> 
                                    ${skillDef.type ? `<input type="text" class="custom-instance-type-input" data-instance-temp-id="${instance.tempInstanceId}" value="${instance.typeName || ''}" placeholder="${t('specify_type_placeholder')}">` : '<span style="display: inline-block; width: 150px; margin-right: 8px;"></span>' /* Platzhalter für nicht-typisierte Skills */}
                                    <span>${t('custom_prof_label_assign_points')}</span>
                                    <button class="custom-skill-point-btn" data-action="decrease" data-amount="10" data-instance-temp-id="${instance.tempInstanceId}">-10</button>
                                    <button class="custom-skill-point-btn" data-action="decrease" data-amount="5" data-instance-temp-id="${instance.tempInstanceId}">-5</button>
                                    <span class="custom-skill-assigned-points">${instance.points || 0}</span>
                                    <button class="custom-skill-point-btn" data-action="increase" data-amount="5" data-instance-temp-id="${instance.tempInstanceId}">+5</button>
                                    <button class="custom-skill-point-btn" data-action="increase" data-amount="10" data-instance-temp-id="${instance.tempInstanceId}">+10</button>
                                    <strong class="custom-skill-total-value">${t('custom_prof_label_skill_total')} ${currentSkillTotal}% (max 60%)</strong>
                                    ${instancesOfThisBaseKey.length > 1 ?
                                        `<button class="remove-custom-skill-instance-btn" data-instance-temp-id="${instance.tempInstanceId}" title="${t('remove_button_title')}" style="color:red; border:none; background:none; cursor:pointer; font-weight:bold; font-size:1.2em;">×</button>`
                                        : ''
                                    }
                                 </div>`;
                    });
                    html += `       </div>
                             </div>`;
                });
                html += `   </div>
                            <div class="custom-prof-actions-container">
                                <button id="btn-confirm-custom-skills" class="action-button" data-i18n="custom_prof_btn_confirm_skills"></button>
                            </div>
                        </div>`;
                return html;
            }

            // attachStep1Listeners (Anpassung für 'done' Stage)
            // attachStep1Listeners (Anpassung für Custom Stages und Dropdown-Handling)
            function attachStep1Listeners() {
                // console.log("===> ENTERING attachStep1Listeners - ProfKey:", character.professionKey, "isCustom:", character.isCustomProfession, "CustomStage:", character.customProfessionSetupStage);
                const mainSelect = document.getElementById('profession-select'); // Für Standard-Layout
                const customSelect = document.getElementById('profession-select-custom'); // Für Custom-Layout

                if (character.isCustomProfession) {
                    if (customSelect) {
                        // Um sicherzustellen, dass wir nicht mehrere Listener auf dasselbe Element binden,
                        // wenn attachStep1Listeners mehrmals für denselben DOM-Zustand aufgerufen wird (sollte nicht, aber defensiv).
                        // Eine sauberere Methode ist, Listener nur einmal zu binden oder mit cloneNode zu arbeiten,
                        // aber für den Moment:
                        customSelect.removeEventListener('change', handleMainProfessionSelectChange); // Alten Listener entfernen
                        customSelect.addEventListener('change', handleMainProfessionSelectChange);   // Neuen binden
                        
                        if (customSelect.value !== character.professionKey) {
                            customSelect.value = character.professionKey; // Wert synchronisieren
                        }
                    }

                    if (character.customProfessionSetupStage === 'bonds') {
                        attachCustomBondSetupListeners();
                    } else if (character.customProfessionSetupStage === 'skills') {
                        attachCustomSkillAllocationListeners();
                    } else if (character.customProfessionSetupStage === 'done') {
                        renderAllSkillsList(); 
                    }
                } else { // Standard Berufsansicht oder kein Beruf gewählt
                    if (mainSelect) {
                        mainSelect.removeEventListener('change', handleMainProfessionSelectChange); // Alten Listener entfernen
                        mainSelect.addEventListener('change', handleMainProfessionSelectChange);   // Neuen binden

                        if (mainSelect.value !== character.professionKey) {
                             mainSelect.value = character.professionKey; // Wert synchronisieren
                        }

                        // Rendere die spezifischen Auswahlmöglichkeiten für den Standardberuf
                        if (character.professionKey && PROFESSIONS[character.professionKey] && !PROFESSIONS[character.professionKey].isCustom) {
                            renderProfessionSpecificChoices(PROFESSIONS[character.professionKey]);
                            const skillIncreaseSection = document.getElementById('skill-increase-section');
                            if(skillIncreaseSection) skillIncreaseSection.style.display = 'block';
                        } else {
                             const profDetailsContainer = document.getElementById('profession-details-container');
                             if(profDetailsContainer) profDetailsContainer.innerHTML = '';
                             const skillIncreaseSection = document.getElementById('skill-increase-section');
                             if(skillIncreaseSection) skillIncreaseSection.style.display = 'none';
                        }
                        renderAllSkillsList(); 
                    } else if (!character.professionKey && currentStep === 1) { // Speziell für Schritt 1, wenn kein Beruf gewählt
                        const skillIncreaseSection = document.getElementById('skill-increase-section');
                        if(skillIncreaseSection) skillIncreaseSection.style.display = 'none';
                        const profDetailsContainer = document.getElementById('profession-details-container');
                        if(profDetailsContainer) profDetailsContainer.innerHTML = '';
                        renderAllSkillsList(); // Zeigt Basiswerte
                    }
                }
            }
            // Hilfsfunktion, um eine Skill-Instanz im character.skills Array zu finden oder zu erstellen
            // Gibt die gefundene/erstellte Instanz zurück
            function findOrCreateSkillInstance(skillKey, typeName = null, isProfessional = false, baseValueFromProf = 0) {
                // Versuche, eine exakte Übereinstimmung mit key UND typeName zu finden
                // Wenn typeName null oder leer ist für einen typisierten Skill, ist das eine "allgemeine" oder noch nicht spezifizierte Instanz.
                let instance = character.skills.find(s => s.key === skillKey && s.typeName === typeName);
                
                if (!instance && typeName === null && ALL_SKILLS[skillKey]?.type) {
                    // Fall: typisierter Skill, aber kein Typ angegeben, suche nach einer "allgemeinen" Instanz oder erstelle eine
                    instance = character.skills.find(s => s.key === skillKey && (s.typeName === null || s.typeName === ""));
                }

                if (!instance) { 
                    const skillDef = ALL_SKILLS[skillKey];
                    if (!skillDef) {
                        console.error(`Skill-Definition für Key ${skillKey} nicht in ALL_SKILLS gefunden!`);
                        return null;
                    }
                    const newInstanceId = generateInstanceId(skillKey, typeName);
                    instance = {
                        instanceId: newInstanceId,
                        key: skillKey,
                        typeName: typeName, // Hier wird der Typ gesetzt
                        value: skillDef.base + baseValueFromProf,
                        baseValueFromProfession: baseValueFromProf,
                        increases: 0,
                        isProfessional: isProfessional,
                        isChoiceSkill: false // Wird später ggf. von Choice-Logik gesetzt
                    };
                    character.skills.push(instance);
                } else { 
                    if (isProfessional) {
                        instance.isProfessional = true;
                        instance.baseValueFromProfession = Math.max(instance.baseValueFromProfession, baseValueFromProf);
                        // Wichtig: Wenn der Typ vorher anders war und jetzt ein Default kommt, diesen nicht blind überschreiben,
                        // es sei denn, es ist explizit gewünscht. Für den Moment: Wenn Instanz existiert, behalte ihren Typ.
                        // ABER: Wenn wir einen `typeNameDefault` anwenden, wollen wir ihn setzen, wenn der aktuelle Typ leer ist.
                        if (typeName !== null && (instance.typeName === null || instance.typeName === "")) {
                            instance.typeName = typeName;
                        }
                    }
                }
                // Wert neu berechnen, basierend auf aktueller Basis, Prof-Wert und Erhöhungen
                instance.value = ALL_SKILLS[skillKey].base + instance.baseValueFromProfession + (instance.increases * SKILL_INCREASE_AMOUNT);
                instance.value = Math.min(instance.value, MAX_SKILL_VALUE);
                return instance;
            }


            // Wird von handleMainProfessionSelectChange aufgerufen, wenn ein Standardberuf gewählt wird
            // Neuer Handler für das Haupt-Profession-Dropdown (um zwischen Standard und Custom zu wechseln)
            function handleMainProfessionSelectChange(event) {
                const newProfessionKey = event.target.value;
                const oldProfessionKey = character.professionKey; 
                
                // console.log("handleMainProfessionSelectChange - Target:", event.target.id, "NewKey:", newProfessionKey, "OldKey:", oldProfessionKey, "Current CustomStage:", character.customProfessionSetupStage);

                // Wenn der Wert sich nicht geändert hat, nichts tun (wichtig, um Endlosschleifen bei manchen Browsern zu vermeiden)
                if (newProfessionKey === oldProfessionKey && newProfessionKey !== "") {
                    // console.log("handleMainProfessionSelectChange: No actual change in profession key. Exiting.");
                    return;
                }

                character.professionKey = newProfessionKey; 

                if (newProfessionKey === "custom_profession") {
                    const wasNotCustomBeforeOrProcessWasDone = oldProfessionKey !== "custom_profession" || character.customProfessionSetupStage === 'done' || oldProfessionKey === "";
                    
                    character.isCustomProfession = true;
                    
                    if (wasNotCustomBeforeOrProcessWasDone) {
                        // console.log("Switching/Resetting to Custom Profession. Setting stage to 'bonds'.");
                        character.customProfessionSetupStage = 'bonds';
                        // Initialisiere Custom Profession spezifische Daten
                        character.customProfessionBonds = 3;
                        // Budget wird in renderCustomProfession_BondSetup berechnet
                        character.customProfessionSelectedSkills = []; 
                        // Wichtig: Skills NICHT hier mit initializeCharacterSkills() zurücksetzen,
                        // da der Nutzer vielleicht zwischen Standard und Custom hin- und herwechselt und
                        // seine bisherigen Skill-Anpassungen (die +20%) nicht verlieren soll, bis er
                        // explizit einen neuen *Beruf* (Standard oder Custom bestätigt) festlegt.
                        // Das Zurücksetzen der Skills passiert in `handleProfessionChange` (für Standard)
                        // und in `handleConfirmCustomSkills` (für Custom).
                    } else {
                        // console.log("Already in Custom Profession (bonds or skills stage), stage remains:", character.customProfessionSetupStage);
                    }
                } else if (newProfessionKey) { // Ein Standardberuf wurde gewählt
                    const wasCustom = character.isCustomProfession; 
                    character.isCustomProfession = false;
                    character.customProfessionSetupStage = 'bonds'; // Custom Stage immer zurücksetzen

                    // Hier wird die Logik zum Anwenden des Standardberufs aufgerufen.
                    // Diese Funktion sollte `initializeCharacterSkills()` aufrufen, wenn nötig.
                    applyStandardProfessionLogic(newProfessionKey, oldProfessionKey, wasCustom);

                } else { // "-- Select One --" wurde gewählt oder leerer String
                    character.isCustomProfession = false;
                    character.professionKey = null;
                    character.customProfessionSetupStage = 'bonds';
                    initializeCharacterSkills(); // Setzt Skills auf Basiswerte zurück
                    // UI leeren
                    const profDetailsContainer = document.getElementById('profession-details-container');
                    if(profDetailsContainer) profDetailsContainer.innerHTML = '';
                    const skillIncreaseSection = document.getElementById('skill-increase-section');
                    if(skillIncreaseSection) skillIncreaseSection.style.display = 'none';
                }
                renderCurrentStep(); // Den aktuellen Schritt (Schritt 1) neu rendern, um die UI umzuschalten/aktualisieren
            }
            // Hilfsfunktion für Standardberufslogik, ausgelagert aus handleMainProfessionSelectChange
            function applyStandardProfessionLogic(newProfessionKey, oldProfessionKey, wasPreviouslyCustom) {
                const profData = PROFESSIONS[newProfessionKey];
                if (!profData || profData.isCustom) return; // Nur für Standardberufe

                // Nur initialisieren, wenn sich der Beruf *wirklich* geändert hat
                if (oldProfessionKey !== newProfessionKey || wasPreviouslyCustom) {
                    // console.log("Applying Standard Profession:", newProfessionKey, "from Old:", oldProfessionKey, "Was Custom:", wasPreviouslyCustom);
                    initializeCharacterSkills(); 
                    character.orSkillChoices = {};
                    character.profChoiceSkillSelections = {};
                }
                
                // Basis-Skills des Standardberufs anwenden
                profData.baseSkills.forEach(skillInfo => {
                    let skillToApplyKey = skillInfo.key; // Für nicht-"or" Skills
                    let skillToApplyValue = skillInfo.value;
                    let typeToApply = null;

                    if (ALL_SKILLS[skillInfo.key]?.type && !skillInfo.orSkills) { // Direkter typisierter Basis-Skill
                        typeToApply = skillInfo.typeNameDefault || "";
                    }

                    if (skillInfo.orSkills) {
                        const chosenOrSkillKey = character.orSkillChoices[skillInfo.id] || skillInfo.orSkills[0].key;
                        const chosenOrSkillData = skillInfo.orSkills.find(os => os.key === chosenOrSkillKey);
                        if (chosenOrSkillData) {
                            skillToApplyKey = chosenOrSkillData.key;
                            skillToApplyValue = chosenOrSkillData.value;
                            // Wenn die "or"-Option selbst typisiert ist
                            typeToApply = ALL_SKILLS[skillToApplyKey]?.type ? "" : null; 
                        } else { skillToApplyKey = null; } // Sollte nicht passieren
                    }
                    
                    if (skillToApplyKey) {
                       const instance = findOrCreateSkillInstance(skillToApplyKey, typeToApply, true, skillToApplyValue);
                       // Wenn es ein typisierter Skill war und typeToApply gesetzt wurde (auch als "" für Nutzereingabe),
                       // sicherstellen, dass es in der Instanz landet.
                       if (instance && ALL_SKILLS[skillToApplyKey]?.type && typeToApply !== null) {
                           instance.typeName = typeToApply;
                       }
                    }
                });
                
                // Choice Skills des Standardberufs (werden in renderProfessionSpecificChoices und dessen Listenern gehandhabt)
                // Hier werden nur die professionellen Flags für bereits getroffene Wahlen gesetzt, falls nötig.
                if (profData.choiceSkills) {
                    profData.choiceSkills.options.forEach(choiceOpt => {
                        if (character.profChoiceSkillSelections[choiceOpt.key]) { 
                            let typeNameForChoice = null;
                            if (ALL_SKILLS[choiceOpt.key].type) {
                                const existingInstance = character.skills.find(s => s.key === choiceOpt.key && s.isChoiceSkill);
                                typeNameForChoice = existingInstance?.typeName || "";
                            }
                            const instance = findOrCreateSkillInstance(choiceOpt.key, typeNameForChoice, true, choiceOpt.value);
                            if(instance) instance.isChoiceSkill = true;
                        }
                    });
                }
                // Die UI für berufsabhängige Wahlen wird durch renderCurrentStep -> renderStep1 -> attachStep1Listeners -> renderProfessionSpecificChoices aktualisiert
            }
            function attachCustomBondSetupListeners() {
                console.log("===> ENTERING attachCustomBondSetupListeners - Stage:", character.customProfessionSetupStage);
                const btnDecreaseBonds = document.getElementById('btn-decrease-bonds');
                const btnIncreaseBonds = document.getElementById('btn-increase-bonds');
                const btnConfirmBonds = document.getElementById('btn-confirm-bonds'); 
                
                console.log("btnDecreaseBonds:", btnDecreaseBonds);
                console.log("btnIncreaseBonds:", btnIncreaseBonds);
                console.log("btnConfirmBonds:", btnConfirmBonds);

                if (btnDecreaseBonds) {
                    // Um sicherzugehen, dass wir keine alten Listener haben, wenn diese Funktion
                    // unerwartet mehrmals für denselben Button aufgerufen wird:
                    // Ersetze den Button durch einen Klon, um alte Listener zu entfernen (alte Methode)
                    // ODER definiere den Handler außerhalb und entferne ihn explizit (sauberer)
                    const decreaseHandler = () => {
                        console.log("Decrease Bonds clicked. Current bonds:", character.customProfessionBonds);
                        if (character.customProfessionBonds > 1) {
                            character.customProfessionBonds--;
                            console.log("Bonds decreased to:", character.customProfessionBonds);
                            renderCurrentStep(); 
                        }
                    };
                    // Um alte Listener zu entfernen, falls vorhanden (einfache Methode ohne Klonen)
                    // Speichere den Handler, um ihn später entfernen zu können, falls nötig (nicht hier, aber als Prinzip)
                    btnDecreaseBonds.onclick = decreaseHandler; // Einfachere Zuweisung, überschreibt alte .onclick
                }

                if (btnIncreaseBonds) {
                     const increaseHandler = () => {
                        console.log("Increase Bonds clicked. Current bonds:", character.customProfessionBonds);
                        if (character.customProfessionBonds < 4) {
                            character.customProfessionBonds++;
                            console.log("Bonds increased to:", character.customProfessionBonds);
                            renderCurrentStep(); 
                        }
                    };
                    btnIncreaseBonds.onclick = increaseHandler;
                }

                if (btnConfirmBonds) {
                    console.log("Found #btn-confirm-bonds, attaching listener.");
                     const confirmHandler = () => {
                        console.log("Confirm Bonds button CLICKED! Current stage before change:", character.customProfessionSetupStage); 
                        character.customProfessionSetupStage = 'skills';
                        // Wichtig: customProfessionSelectedSkills als Array initialisieren für den nächsten Schritt
                        character.customProfessionSelectedSkills = []; 
                        console.log("Stage changed to 'skills'. Rendering current step..."); 
                        renderCurrentStep();
                    };
                    btnConfirmBonds.onclick = confirmHandler; // Verwende .onclick für Einfachheit hier
                } else {
                    console.error("#btn-confirm-bonds NOT FOUND in attachCustomBondSetupListeners!");
                }
                const customProfNameInput = document.getElementById('custom-profession-name');
                if (customProfNameInput) {
                    customProfNameInput.addEventListener('input', (event) => {
                        character.customProfessionName = event.target.value;
                        // Optional: Validierung hier, ob der Name nicht leer sein darf, um fortzufahren.
                        // Dann updateNavigationButtons() oder spezifischen Confirm-Button-Status anpassen.
                    });
                }
            }
            // Neuer Handler für das Haupt-Profession-Dropdown (um zwischen Standard und Custom zu wechseln)
            function handleMainProfessionSelectChange(event) {
                const newProfessionKey = event.target.value;
                const oldProfessionKey = character.professionKey;
                character.professionKey = newProfessionKey; // ProfessionKey global setzen
                console.log("MainProfSelectChange: OldKey:", oldProfessionKey, "NewKey:", newProfessionKey, "Current CustomStage:", character.customProfessionSetupStage);
                const customNameInputContainer = document.getElementById('custom-profession-name-input-container');
                if (customNameInputContainer) { // Überprüfen, ob das Element im aktuellen DOM (Schritt) existiert
                    customNameInputContainer.style.display = (newProfessionKey === 'custom_profession') ? 'block' : 'none';
                }
                if (newProfessionKey !== 'custom_profession') {
                    character.customProfessionName = ""; // Namen löschen, wenn nicht mehr Custom
                }
                if (newProfessionKey === "custom_profession") {
                    character.isCustomProfession = true;
                    // Wenn man zu Custom wechselt oder innerhalb von Custom bleibt,
                    // aber vielleicht von einem anderen Custom-Stage kommt.
                    if (oldProfessionKey !== "custom_profession" || !character.customProfessionSetupStage || character.customProfessionSetupStage === 'done') {
                        console.log("MainProfSelectChange: Switching to Custom or resetting Custom. Setting stage to 'bonds'.");
                        character.customProfessionSetupStage = 'bonds';
                        // Standardwerte für Custom Profession nur setzen, wenn man *neu* zu Custom kommt
                        // oder den Prozess neu starten will.
                        // Für den Moment: Immer zurücksetzen, wenn 'bonds' Stage erreicht wird.
                        character.customProfessionBonds = 3;
                        character.customProfessionSkillPointBudget = 400; // Wird in renderCustomProfession_BondSetup neu berechnet
                        character.customProfessionSelectedSkills = {};
                    }
                    else {
                        console.log("MainProfSelectChange: Already in Custom Profession, stage remains:", character.customProfessionSetupStage);
                    }
                } else if (newProfessionKey) { // Ein Standardberuf wurde gewählt
                    character.isCustomProfession = false;
                    character.customProfessionSetupStage = 'bonds'; 

                    const profData = PROFESSIONS[newProfessionKey];
                    if (profData && !profData.isCustom) {
                        if (oldProfessionKey !== newProfessionKey || (oldProfessionKey === "custom_profession" && newProfessionKey)) {
                            initializeCharacterSkills(); 
                            character.orSkillChoices = {};
                            character.profChoiceSkillSelections = {};
                        }
                        
                        profData.baseSkills.forEach(skillInfo => {
                            let skillToApplyKey = skillInfo.key;
                            let skillToApplyValue = skillInfo.value;
                            // **NEU: typeName explizit aus typeNameDefault holen, wenn vorhanden**
                            let typeToApply = null;
                            if (ALL_SKILLS[skillInfo.key]?.type) { // Ist der Skill überhaupt typisiert?
                                typeToApply = skillInfo.typeNameDefault || ""; // Nimm Default oder leer
                            }

                            if (skillInfo.orSkills) {
                                const chosenOrSkillKey = character.orSkillChoices[skillInfo.id] || skillInfo.orSkills[0].key;
                                const chosenOrSkillData = skillInfo.orSkills.find(os => os.key === chosenOrSkillKey);
                                if (chosenOrSkillData) {
                                    skillToApplyKey = chosenOrSkillData.key;
                                    skillToApplyValue = chosenOrSkillData.value;
                                    // Wenn die "or"-Option selbst typisiert ist, muss ihr Typ hier ermittelt werden (aktuell nicht der Fall in deinen Daten)
                                    typeToApply = ALL_SKILLS[skillToApplyKey]?.type ? "" : null; // Setze auf leer für Typ-Eingabe, wenn typisiert
                                } else { skillToApplyKey = null; }
                            }
                            
                            if (skillToApplyKey) {
                               // Erstelle oder aktualisiere die Instanz und setze den Typ
                               const instance = findOrCreateSkillInstance(skillToApplyKey, typeToApply, true, skillToApplyValue);
                               if (instance && typeToApply !== null && ALL_SKILLS[skillToApplyKey]?.type) { // Stelle sicher, dass der Typ auch gesetzt wird
                                   instance.typeName = typeToApply;
                               }
                            }
                        });
                        // Choice Skills (Annahme: typeNameDefault wird hier nicht direkt angewendet, Nutzer muss wählen/eingeben)
                        if (profData.choiceSkills) {
                            profData.choiceSkills.options.forEach(choiceOpt => {
                                if (character.profChoiceSkillSelections[choiceOpt.key]) {
                                    let typeNameForChoice = null;
                                    if (ALL_SKILLS[choiceOpt.key].type) {
                                        // Versuche, einen gespeicherten Typ zu laden, sonst leer lassen für Eingabe
                                        const existingInstance = character.skills.find(s => s.key === choiceOpt.key && s.isChoiceSkill);
                                        typeNameForChoice = existingInstance?.typeName || "";
                                    }
                                    const instance = findOrCreateSkillInstance(choiceOpt.key, typeNameForChoice, false, choiceOpt.value); // isProfessional ist false, isChoiceSkill wird im Listener gesetzt
                                    if(instance) instance.isChoiceSkill = true;
                                }
                            });
                        }
                    }
                } else { // "-- Select One --"
                    // ... (wie vorher) ...
                }
                renderCurrentStep();
            }
            function renderProfessionSpecificChoices(profData) {
                const container = document.getElementById('profession-details-container');
                if (!container) return;

                let detailsHtml = `<h3 data-i18n="step1_2_profession_specific_label">${t('step1_2_profession_specific_label')}</h3>`;
                detailsHtml += `<p><strong data-i18n="bonds_label">${t('bonds_label')}:</strong> ${profData.bonds}</p>`;

                // 1. Basis-Skills des Berufs (inkl. orSkills und typisierte Skills)
                profData.baseSkills.forEach(skillInfo => {
                    if (skillInfo.orSkills) { // z.B. Anthropology OR Archeology
                        const currentChoice = character.orSkillChoices[skillInfo.id] || skillInfo.orSkills[0].key;
                        detailsHtml += `<div class="profession-choice-group or-skill-group">
                                            <p>${t('choose_one_label')}:</p>`;
                        skillInfo.orSkills.forEach((orSkillOption) => {
                            const isChecked = currentChoice === orSkillOption.key;
                            detailsHtml += `<label class="inline-label">
                                                <input type="radio" name="orSkill_${skillInfo.id}" 
                                                       value="${orSkillOption.key}" 
                                                       data-group-id="${skillInfo.id}" 
                                                       data-value="${orSkillOption.value}" 
                                                       ${isChecked ? 'checked' : ''}> 
                                                ${t(ALL_SKILLS[orSkillOption.key].nameKey)} (${orSkillOption.value}%)
                                            </label> `;
                        });
                        detailsHtml += `</div>`;
                    } else if (ALL_SKILLS[skillInfo.key].type) { 
                        let instanceIdToUse = `${skillInfo.key}_prof_${skillInfo.id || 'default'}`; // Eindeutige ID für diesen Slot
                        let existingInstance = character.skills.find(s => s.instanceId === instanceIdToUse);

                        if (!existingInstance) { // Fallback: Erstelle temporär, falls nicht von handleProfChange erstellt
                            // Dies sollte idealerweise nicht nötig sein, wenn handleProfessionChange robust ist.
                            // Aber es stellt sicher, dass das Feld einen Wert hat.
                            // Wichtig: Dieser Aufruf fügt es zu character.skills hinzu!
                            existingInstance = findOrCreateSkillInstance(skillInfo.key, skillInfo.typeNameDefault || "", true, skillInfo.value);
                            existingInstance.instanceId = instanceIdToUse; // Stelle sicher, dass die ID die Slot-ID ist
                        }
                        
                        const typeNameValue = existingInstance?.typeName || skillInfo.typeNameDefault || "";

                        detailsHtml += `<div class="profession-choice-group typed-base-skill-group">
                                            <label for="typed_base_${instanceIdToUse}">${t(ALL_SKILLS[skillInfo.key].nameKey)} (${skillInfo.value}%): </label>
                                            <input type="text" id="typed_base_${instanceIdToUse}" 
                                                   class="skill-type-input base-skill-type-input" 
                                                   data-skill-key="${skillInfo.key}" 
                                                   data-skill-value="${skillInfo.value}"
                                                   data-instance-id="${instanceIdToUse}"
                                                   value="${typeNameValue}" 
                                                   placeholder="${t('specify_type_placeholder')}">
                                         </div>`;
                    }
                    // Nicht-typisierte Basis-Skills werden hier nicht extra gerendert, da sie keine weitere Eingabe erfordern.
                    // Ihre Werte werden direkt in handleProfessionChange gesetzt.
                });

                // 2. Choice Skills (Checkboxen)
                if (profData.choiceSkills) {
                    detailsHtml += `<div class="profession-choice-group choice-skill-group">
                                        <p>${t('choose_N_label', { N: profData.choiceSkills.count })}:</p>
                                        <ul>`;
                    profData.choiceSkills.options.forEach(choiceOpt => {
                        // Prüfe, ob dieser Choice Skill bereits im character.skills Array als Instanz existiert und ausgewählt wurde
                        const isActuallySelectedAsChoice = character.profChoiceSkillSelections[choiceOpt.key]; // Aus Schritt 1.2 Wahl
                        let typeNameValue = "";
                        if (isActuallySelectedAsChoice && ALL_SKILLS[choiceOpt.key].type) {
                             const choiceInstance = character.skills.find(s => s.key === choiceOpt.key && s.isChoiceSkill); // Vereinfachte Suche
                             typeNameValue = choiceInstance?.typeName || "";
                        }

                        detailsHtml += `<li>
                                            <label class="inline-label">
                                                <input type="checkbox" class="prof-choice-skill-cb" 
                                                       data-skill-key="${choiceOpt.key}" 
                                                       data-skill-value="${choiceOpt.value}"
                                                       data-is-typed="${ALL_SKILLS[choiceOpt.key].type ? 'true' : 'false'}"
                                                       ${isActuallySelectedAsChoice ? 'checked' : ''}> 
                                                ${t(ALL_SKILLS[choiceOpt.key].nameKey)} (${choiceOpt.value}%)
                                            </label>`;
                        if (ALL_SKILLS[choiceOpt.key].type) {
                             detailsHtml += `<input type="text" class="skill-type-input choice-skill-type-input" 
                                                    data-skill-key="${choiceOpt.key}" 
                                                    placeholder="${t('specify_type_placeholder')}" 
                                                    value="${typeNameValue}" 
                                                    style="display:${isActuallySelectedAsChoice ? 'inline-block':'none'}; margin-left: 10px;">`;
                        }
                        detailsHtml += `</li>`;
                    });
                    detailsHtml += `</ul></div>`;
                }
                container.innerHTML = detailsHtml;
                attachProfessionChoiceListenersInternal(profData); // Übergebe profData für Kontext
            }
            function attachProfessionChoiceListenersInternal(profData) {
                // Listener für "orSkill" Radio-Buttons
                document.querySelectorAll('input[type="radio"][name^="orSkill_"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        const selectedKey = e.target.value;
                        const groupId = e.target.dataset.groupId;
                        const skillValue = parseInt(e.target.dataset.value);
                        character.orSkillChoices[groupId] = selectedKey; 

                        const orSkillGroupDef = profData.baseSkills.find(bs => bs.id === groupId);
                        if (orSkillGroupDef) {
                            // Alle Skills in dieser "or"-Gruppe im character.skills-Array als nicht-professionell markieren
                            // und ihren baseValueFromProfession zurücksetzen, falls sie die vorherige Wahl waren.
                            orSkillGroupDef.orSkills.forEach(osOption => {
                                const instance = character.skills.find(s => s.key === osOption.key && s.isProfessional && !s.isChoiceSkill); // Finde die alte Prof-Instanz
                                if (instance) {
                                    instance.isProfessional = false;
                                    instance.baseValueFromProfession = 0;
                                    instance.value = ALL_SKILLS[instance.key].base + (instance.increases * SKILL_INCREASE_AMOUNT);
                                }
                            });
                            // Den neu gewählten Skill als professionell setzen/erstellen
                            let typeName = null;
                            if(ALL_SKILLS[selectedKey].type) {
                                // Hier müssten wir einen Weg finden, den Typ zu bekommen, falls diese "or"-Option typisiert ist.
                                // Das ist ein komplexer Fall, wenn die "or"-Option selbst eine Typ-Eingabe benötigt.
                                // Für den Moment nehmen wir an, "or"-Skills sind nicht direkt typ-eingabepflichtig in *dieser* UI,
                                // sondern der Typ kommt aus typeNameDefault oder ist implizit.
                                // Wenn doch, müsste hier ein Typ-Input-Feld erscheinen/ausgelesen werden.
                            }
                            findOrCreateSkillInstance(selectedKey, typeName, true, skillValue);
                        }
                        renderAllSkillsList();
                        updateNavigationButtons();
                    });
                });

                // Listener für Typ-Eingabefelder von direkten typisierten Basis-Skills
                document.querySelectorAll('.base-skill-type-input').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const skillKey = e.target.dataset.skillKey;
                        const instanceId = e.target.dataset.instanceId; // Die spezifische ID
                        const typeName = e.target.value.trim();
                        const profValue = parseInt(e.target.dataset.skillValue);

                        let instance = character.skills.find(s => s.instanceId === instanceId);
                        if (instance) {
                            instance.typeName = typeName;
                        } else { // Instanz existiert noch nicht (sollte durch handleProfessionChange erstellt worden sein, aber als Fallback)
                            instance = findOrCreateSkillInstance(skillKey, typeName, true, profValue);
                            instance.instanceId = instanceId; // Stelle sicher, dass die ID konsistent ist
                        }
                        renderAllSkillsList(); // Um den Typ in der Hauptliste zu aktualisieren
                        updateNavigationButtons();
                    });
                });
                
                // Listener für Checkbox Choice Skills
                document.querySelectorAll('.prof-choice-skill-cb').forEach(checkbox => {
                    checkbox.addEventListener('change', (e) => {
                        const skillKey = e.target.dataset.skillKey;
                        const skillValue = parseInt(e.target.dataset.skillValue);
                        const isTyped = e.target.dataset.isTyped === 'true';
                        const typeInput = e.target.closest('li').querySelector('.choice-skill-type-input');
                        
                        const maxChoices = profData.choiceSkills.count; // Hole maxChoices aus profData
                        let checkedCount = 0;
                        document.querySelectorAll('.prof-choice-skill-cb:checked').forEach(() => checkedCount++);

                        if (e.target.checked) {
                            if (checkedCount > maxChoices) {
                                e.target.checked = false; 
                                alert(t('alert_max_choices_reached', { N: maxChoices }));
                                return;
                            }
                            character.profChoiceSkillSelections[skillKey] = true;
                            let typeName = null;
                            if (isTyped && typeInput) {
                                typeName = typeInput.value.trim();
                                typeInput.style.display = 'inline-block';
                            }
                            const instance = findOrCreateSkillInstance(skillKey, typeName, true, skillValue);
                            instance.isChoiceSkill = true; // Markiere als Choice Skill

                        } else { // Checkbox wurde abgewählt
                            character.profChoiceSkillSelections[skillKey] = false;
                            if (typeInput) typeInput.style.display = 'none';
                            
                            // Finde die Instanz und setze sie zurück oder entferne sie, wenn sie NUR ein Choice Skill war
                            const instance = character.skills.find(s => s.key === skillKey && s.isChoiceSkill); // Finde die spezifische Choice-Instanz
                            if (instance) {
                                instance.isChoiceSkill = false;
                                instance.isProfessional = false; // Wenn es NUR ein Choice war, ist es nicht mehr professionell
                                instance.baseValueFromProfession = 0;
                                instance.value = ALL_SKILLS[skillKey].base + (instance.increases * SKILL_INCREASE_AMOUNT);
                                // Optional: Wenn der Skill (key+typeName) nicht auch ein fester Berufsskill ist,
                                // und keine Erhöhungen hat, könnte man die Instanz ganz entfernen.
                                // Fürs Erste: Wert zurücksetzen.
                            }
                        }
                        // Deaktivierungslogik für Checkboxen
                        checkedCount = document.querySelectorAll('.prof-choice-skill-cb:checked').length;
                        document.querySelectorAll('.prof-choice-skill-cb').forEach(cb => {
                            if (!cb.checked) {
                                cb.disabled = checkedCount >= maxChoices;
                                cb.closest('label').classList.toggle('disabled-choice', cb.disabled);
                            } else {
                                cb.disabled = false; // Bereits ausgewählte können immer abgewählt werden
                                cb.closest('label').classList.remove('disabled-choice');
                            }
                        });
                        renderAllSkillsList();
                        updateNavigationButtons();
                    });
                    // Initialer Zustand der Checkbox-Deaktivierung und Typ-Input-Sichtbarkeit
                    const maxChoices = profData.choiceSkills.count;
                    const checkedCount = document.querySelectorAll('.prof-choice-skill-cb:checked').length;
                    if (!checkbox.checked) {
                        checkbox.disabled = checkedCount >= maxChoices;
                        checkbox.closest('label').classList.toggle('disabled-choice', checkbox.disabled);
                    }
                    if (checkbox.checked && checkbox.dataset.isTyped === 'true') {
                        const typeInput = checkbox.closest('li').querySelector('.choice-skill-type-input');
                        if(typeInput) typeInput.style.display = 'inline-block';
                    }
                });

                 // Listener für Typ-Eingabefelder von Choice Skills
                document.querySelectorAll('.choice-skill-type-input').forEach(input => {
                    input.addEventListener('input', (e) => {
                        const skillKey = e.target.dataset.skillKey;
                        const typeName = e.target.value.trim();
                        // Finde die entsprechende Choice-Skill-Instanz und aktualisiere ihren Typnamen
                        const instance = character.skills.find(s => s.key === skillKey && s.isChoiceSkill);
                        if (instance) {
                            instance.typeName = typeName;
                        } else {
                            // Fall: Typ wird eingegeben, bevor der Skill als Instanz existiert (sollte nicht passieren, wenn UI korrekt ist)
                            // Hier könnte man temporär im character.profChoiceSkillSelections speichern
                            if(character.profChoiceSkillSelections[skillKey] && ALL_SKILLS[skillKey].type) {
                                // Erstelle eine temporäre Struktur oder warte, bis die Checkbox die Instanz erstellt.
                                // Besser ist es, wenn die Instanz schon da ist.
                            }
                        }
                        renderAllSkillsList();
                        updateNavigationButtons();
                    });
                });
            }
            function renderAllSkillsList() {
                const listContainer = document.getElementById('all-skills-list-container');
                if (!listContainer) {
                    // console.warn("#all-skills-list-container nicht im DOM gefunden!");
                    // Stelle sicher, dass das HTML von renderStep1_ProfessionSkills diesen Container hat,
                    // wenn diese Phase erreicht ist (Standardberuf oder Custom 'done').
                    return; 
                }
                listContainer.innerHTML = ''; 

                let totalIncreases = 0;
                character.skills.forEach(s => totalIncreases += (s.increases || 0)); // Sicherstellen, dass increases existiert
                
                const increasesChosenEl = document.getElementById('increases-chosen-count');
                if(increasesChosenEl) increasesChosenEl.textContent = totalIncreases;

                // Sortiere die Skill-Instanzen alphabetisch nach ihrem vollen Anzeigenamen
                const sortedSkillInstances = [...character.skills].sort((a, b) => {
                    const nameA = t(ALL_SKILLS[a.key].nameKey) + (a.typeName ? ` (${a.typeName})` : "");
                    const nameB = t(ALL_SKILLS[b.key].nameKey) + (b.typeName ? ` (${b.typeName})` : "");
                    return nameA.localeCompare(nameB, currentLanguage);
                });

                if (sortedSkillInstances.length === 0 && character.professionKey) {
                    // Dieser Fall sollte nicht eintreten, wenn initializeCharacterSkills korrekt Basis-Skills für nicht-typisierte erstellt
                    // oder handleProfessionChange Instanzen für Berufsskills erstellt.
                    listContainer.innerHTML = "<p><em>No skills loaded for this profession yet. This might be an error.</em></p>";
                    return;
                }


                for (const skillInstance of sortedSkillInstances) {
                    const skillDef = ALL_SKILLS[skillInstance.key]; // Basis-Definition
                    if (!skillDef) {
                        console.warn(`Keine Basis-Definition für Skill-Key ${skillInstance.key} gefunden.`);
                        continue;
                    }
                    
                    let displayName = t(skillDef.nameKey);
                    if (skillInstance.typeName && skillInstance.typeName.trim() !== "") {
                        displayName += ` (${skillInstance.typeName.trim()})`;
                    }

                    const item = document.createElement('div');
                    item.classList.add('skill-list-item');

                    const currentSkillValue = skillInstance.value || 0; // Fallback
                    //const currentIncreases = skillInstance.increases || 0;

                    const plusButtonDisabled = totalIncreases >= MAX_SKILL_INCREASES || currentSkillValue >= MAX_SKILL_VALUE;
                    const minusButtonDisabled = (skillInstance.increases || 0) === 0; // Bleibt gleich

                    item.innerHTML = `
                        <div class="skill-name-container">
                            <span class="skill-name">${displayName}</span>
                            <span class="skill-info-icon" title="${t(skillDef.descKey)}">i
                                <span class="tooltip">${t(skillDef.descKey)}</span>
                            </span>
                        </div>
                        <div class="skill-value-controls">
                            <span class="skill-value">${currentSkillValue}%</span>
                            <span class="skill-increase-count">${(skillInstance.increases || 0) > 0 ? `(${(skillInstance.increases || 0)}x +${SKILL_INCREASE_AMOUNT}%)` : ''}</span>
                            <button class="skill-decrease-button" data-instance-id="${skillInstance.instanceId}" ${minusButtonDisabled ? 'disabled' : ''}>-${SKILL_INCREASE_AMOUNT}%</button>
                            <button class="skill-increase-button" data-instance-id="${skillInstance.instanceId}" ${plusButtonDisabled ? 'disabled' : ''}>+${SKILL_INCREASE_AMOUNT}%</button>
                        </div>
                    `;
                    listContainer.appendChild(item);
                }

                document.querySelectorAll('.skill-increase-button').forEach(button => {
                    button.addEventListener('click', handleSkillIncreaseClick); // Name bleibt gleich, Logik ändert sich
                });
                document.querySelectorAll('.skill-decrease-button').forEach(button => {
                    button.addEventListener('click', handleSkillDecreaseClick); // Name bleibt gleich, Logik ändert sich
                });
            }

            // Angepasster Handler für +20%
            function handleSkillIncreaseClick(event) {
                const instanceId = event.target.dataset.instanceId;
                const skillInstance = character.skills.find(s => s.instanceId === instanceId);
                if (!skillInstance) return;

                let totalIncreases = 0;
                character.skills.forEach(s => totalIncreases += (s.increases || 0));

                if (skillInstance.value >= MAX_SKILL_VALUE) {
                    // console.log("Max skill value reached for", skillInstance.key);
                    return; 
                }
                
                // **NEUE, STRIKTERE PRÜFUNG**
                if (totalIncreases >= MAX_SKILL_INCREASES) {
                    alert(t('alert_skill_increase_limit'));
                    return; 
                }
                
                // Nur wenn beide obigen Bedingungen nicht zutreffen, Erhöhung durchführen
                skillInstance.increases = (skillInstance.increases || 0) + 1;
                const baseVal = ALL_SKILLS[skillInstance.key].base;
                const profVal = skillInstance.baseValueFromProfession || 0;
                skillInstance.value = Math.min(baseVal + profVal + (skillInstance.increases * SKILL_INCREASE_AMOUNT), MAX_SKILL_VALUE);
                
                renderAllSkillsList(); 
                updateNavigationButtons();
            }

            // Angepasster Handler für -20%
            function handleSkillDecreaseClick(event) {
                const instanceId = event.target.dataset.instanceId;
                const skillInstance = character.skills.find(s => s.instanceId === instanceId);
                if (!skillInstance || (skillInstance.increases || 0) === 0) return;

                skillInstance.increases--;
                const baseVal = ALL_SKILLS[skillInstance.key].base;
                const profVal = skillInstance.baseValueFromProfession || 0;
                skillInstance.value = baseVal + profVal + (skillInstance.increases * SKILL_INCREASE_AMOUNT);
                // Wert darf nicht unter den "natürlichen" Wert (Basis + Beruf) fallen
                skillInstance.value = Math.max(skillInstance.value, baseVal + profVal);
                skillInstance.value = Math.max(skillInstance.value, 0); // Nicht unter 0

                renderAllSkillsList();
                updateNavigationButtons();
            }
            // NEU: Listener und Handler für Custom Profession - Skill Allocation
            function attachCustomSkillAllocationListeners() {
                const skillListDiv = document.getElementById('custom-profession-skill-list'); // Hauptcontainer
                const confirmBtn = document.getElementById('btn-confirm-custom-skills');
                // const customProfessionSelect = ...; // Wird von attachStep1Listeners gehandhabt

                if (skillListDiv) {
                    // Listener für Haupt-Checkboxen der Basis-Skills
                    skillListDiv.addEventListener('change', (event) => {
                        if (event.target.classList.contains('custom-prof-skill-select-main')) {
                            handleCustomBaseSkillMainCheckboxChange(event.target);
                        } else if (event.target.classList.contains('custom-instance-type-input')) {
                            handleCustomInstanceTypeChange(event.target);
                        }
                    });

                    skillListDiv.addEventListener('click', (event) => {
                        if (event.target.classList.contains('btn-add-another-specialization')) {
                            handleAddAnotherSpecializationClick(event.target);
                        } else if (event.target.classList.contains('remove-custom-skill-instance-btn')) {
                            handleRemoveCustomSkillInstanceClick(event.target);
                        } else if (event.target.classList.contains('custom-skill-point-btn')) {
                            handleCustomInstancePointChangeFromButton(event.target);
                        }
                    });
                }
                if (confirmBtn) { confirmBtn.addEventListener('click', handleConfirmCustomSkills); }
                updateCustomSkillAllocationUI();
                updateNavigationButtons();
            }
            function handleCustomBaseSkillMainCheckboxChange(checkbox) {
                const baseKey = checkbox.dataset.skillKey;
                const isTyped = checkbox.dataset.isTyped === 'true';
                const isChecked = checkbox.checked;

                const existingInstances = character.customProfessionSelectedSkills.filter(inst => inst.key === baseKey);

                if (isChecked) {
                    if (character.customProfessionSelectedSkills.length >= 10 && existingInstances.length === 0) {
                        checkbox.checked = false; // Verhindern
                        alert(t('alert_max_10_custom_skills'));
                        return;
                    }
                    // Wenn angehakt und noch keine Instanz dieses Basis-Skills existiert, füge eine hinzu.
                    if (existingInstances.length === 0) {
                        character.customProfessionSelectedSkills.push({
                            key: baseKey,
                            typeName: "", 
                            points: 0,
                            tempInstanceId: generateInstanceId(baseKey, "inst0") 
                        });
                    }
                } else {
                    // Wenn Haupt-Checkbox abgewählt, entferne ALLE Instanzen dieses Basis-Skills
                    character.customProfessionSelectedSkills = character.customProfessionSelectedSkills.filter(
                        inst => inst.key !== baseKey
                    );
                }
                renderCurrentStep(); // Um die UI komplett neu zu zeichnen
            }

            function handleCustomBaseSkillSelectChange(checkbox) {
                const baseKey = checkbox.dataset.skillKey;
                const isTyped = checkbox.dataset.isTyped === 'true';
                const isChecked = checkbox.checked;

                const existingInstancesOfThisBaseKey = character.customProfessionSelectedSkills.filter(inst => inst.key === baseKey);

                if (isChecked) {
                    if (character.customProfessionSelectedSkills.length >= 10) {
                        checkbox.checked = false; // Verhindern
                        alert(t('alert_max_10_custom_skills'));
                        return;
                    }
                    // Wenn angehakt und noch keine Instanz dieses Basis-Skills existiert, füge eine hinzu.
                    if (existingInstancesOfThisBaseKey.length === 0) {
                        character.customProfessionSelectedSkills.push({
                            key: baseKey,
                            typeName: "", 
                            points: 0,
                            tempInstanceId: generateInstanceId(baseKey, "custom_0") 
                        });
                    }
                } else {
                    // Wenn abgewählt, entferne ALLE Instanzen dieses Basis-Skills
                    character.customProfessionSelectedSkills = character.customProfessionSelectedSkills.filter(
                        inst => inst.key !== baseKey
                    );
                }
                renderCurrentStep(); // Um die Instanzenliste und die UI neu zu zeichnen
            }
            function handleAddAnotherSpecializationClick(button) {
                if (character.customProfessionSelectedSkills.length >= 10) {
                    alert(t('alert_max_10_custom_skills'));
                    return;
                }
                const baseKey = button.dataset.skillKey;
                const count = character.customProfessionSelectedSkills.filter(i => i.key === baseKey).length;
                character.customProfessionSelectedSkills.push({
                    key: baseKey,
                    typeName: "",
                    points: 0,
                    tempInstanceId: generateInstanceId(baseKey, `inst${count}`)
                });
                renderCurrentStep();
            }
            function handleRemoveCustomSkillInstanceClick(button) {
                const tempIdToRemove = button.dataset.instanceTempId;
                character.customProfessionSelectedSkills = character.customProfessionSelectedSkills.filter(
                    inst => inst.tempInstanceId !== tempIdToRemove
                );
                renderCurrentStep();
            }
           function handleCustomInstanceTypeChange(inputField) {
                const tempId = inputField.dataset.instanceTempId;
                const instance = character.customProfessionSelectedSkills.find(inst => inst.tempInstanceId === tempId);
                if (instance) {
                    instance.typeName = inputField.value.trim();
                }
                updateNavigationButtons(); 
            }

             function handleCustomInstancePointChangeFromButton(button) {
                const tempId = button.dataset.instanceTempId;
                
                const instance = character.customProfessionSelectedSkills.find(inst => inst.tempInstanceId === tempId);
                if (!instance) return;

                let currentPoints = instance.points || 0;
                const baseValue = ALL_SKILLS[instance.key].base;
                let newPoints = currentPoints; 
                const action = button.dataset.action;
                const amount = parseInt(button.dataset.amount);

                if (action === "increase") {
                    let totalSpent = 0;
                    character.customProfessionSelectedSkills.forEach(s => totalSpent += (s.points || 0));
                    if ((totalSpent - currentPoints + (currentPoints + amount)) > character.customProfessionSkillPointBudget) {
                        return; 
                    }
                    if ((baseValue + currentPoints + amount) > 60) {
                        if (baseValue + currentPoints < 60) newPoints = 60 - baseValue;
                        else return;
                    } else {
                        newPoints = currentPoints + amount;
                    }
                } else if (action === "decrease") {
                    newPoints = currentPoints - amount < 0 ? 0 : currentPoints - amount;
                }

                if ((baseValue + newPoints) > 60) newPoints = 60 - baseValue;
                if (newPoints < 0) newPoints = 0;

                if (newPoints !== currentPoints) instance.points = newPoints;
                updateCustomSkillAllocationUI();
            }



            function handleCustomSkillTypeInputChange(inputField) {
                const skillKey = inputField.dataset.skillKey;
                if (character.customProfessionSelectedSkills[skillKey]) {
                    character.customProfessionSelectedSkills[skillKey].typeName = inputField.value.trim();
                }
                updateNavigationButtons(); // Validierung für "Weiter"-Knopf (Confirm Custom Skills) prüfen
            }
            
            // handleCustomSkillPointChange (die verbesserte Version aus der vorherigen Antwort)
            function handleCustomSkillPointChange(button) {
                const skillKey = button.dataset.skillKey;
                const action = button.dataset.action; 
                const amount = parseInt(button.dataset.amount); 

                if (!character.customProfessionSelectedSkills[skillKey] && action === "increase") {
                    // Dies sollte nicht passieren, wenn Skill nicht ausgewählt ist, aber als Sicherheitsnetz
                    character.customProfessionSelectedSkills[skillKey] = { points: 0, typeName: "" };
                } else if (!character.customProfessionSelectedSkills[skillKey]) {
                    return;
                }


                let currentPoints = character.customProfessionSelectedSkills[skillKey].points;
                const baseValue = ALL_SKILLS[skillKey].base;
                let newPoints = currentPoints; 

                if (action === "increase") {
                    let totalSpent = 0;
                    Object.values(character.customProfessionSelectedSkills).forEach(s => totalSpent += (s.points || 0));
                    
                    if (totalSpent - currentPoints + (currentPoints + amount) > character.customProfessionSkillPointBudget) {
                        // console.log("Budget limit for increase");
                        updateCustomSkillAllocationUI(); // Nur UI neu zeichnen
                        return; 
                    }
                    
                    if ((baseValue + currentPoints + amount) > 60) {
                        if (baseValue + currentPoints < 60) { // Nur anpassen, wenn es noch nicht 60 ist
                            newPoints = 60 - baseValue; 
                        } else { // Ist schon bei 60 oder drüber (sollte nicht passieren)
                            updateCustomSkillAllocationUI();
                            return;
                        }
                    } else {
                        newPoints = currentPoints + amount;
                    }
                } else if (action === "decrease") {
                    if (currentPoints - amount < 0) {
                        newPoints = 0;
                    } else {
                        newPoints = currentPoints - amount;
                    }
                } else { return; }

                if (newPoints < 0) newPoints = 0; // Doppelte Sicherung
                if ((baseValue + newPoints) > 60) newPoints = 60 - baseValue; // Doppelte Sicherung


                if (newPoints !== currentPoints) {
                    character.customProfessionSelectedSkills[skillKey].points = newPoints;
                }
                
                updateCustomSkillAllocationUI(); 
            }
            function handleCustomInstancePointChange(instanceIndex, action, amount) {
                const instance = character.customProfessionSelectedSkills[instanceIndex];
                if (!instance) return;

                let currentPoints = instance.points;
                const baseValue = ALL_SKILLS[instance.key].base;
                let newPoints = currentPoints;

                if (action === "increase") {
                    let totalSpent = 0;
                    character.customProfessionSelectedSkills.forEach(s => totalSpent += (s.points || 0));
                    if ((totalSpent - currentPoints + (currentPoints + amount)) > character.customProfessionSkillPointBudget) {
                        return; 
                    }
                    if ((baseValue + currentPoints + amount) > 60) {
                        if (baseValue + currentPoints < 60) newPoints = 60 - baseValue;
                        else return;
                    } else {
                        newPoints = currentPoints + amount;
                    }
                } else if (action === "decrease") {
                    newPoints = currentPoints - amount < 0 ? 0 : currentPoints - amount;
                }

                if ((baseValue + newPoints) > 60) newPoints = 60 - baseValue; // Doppelte Sicherung
                if (newPoints < 0) newPoints = 0;

                if (newPoints !== currentPoints) {
                    instance.points = newPoints;
                }
                updateCustomSkillAllocationUI();
            }
            
            // updateCustomSkillAllocationUI muss jetzt die Liste der Instanzen aktualisieren
            // updateCustomSkillAllocationUI muss ggf. leicht angepasst werden,
            // um mit `data-instance-temp-id` und der neuen Struktur zu arbeiten.
            // Die Logik für das Aktualisieren der Texte und Button-Disabled-Status bleibt ähnlich.
            function updateCustomSkillAllocationUI() {
                const budget = character.customProfessionSkillPointBudget;
                let pointsSpent = 0;
                character.customProfessionSelectedSkills.forEach(inst => pointsSpent += (inst.points || 0));
                const remainingPoints = budget - pointsSpent;
                const numSelectedInstances = character.customProfessionSelectedSkills.length;

                const infoP = document.getElementById('custom-prof-skill-allocation-info');
                if (infoP) infoP.innerHTML = t("custom_prof_info_skill_allocation", { currentBudget: budget, remainingPoints: remainingPoints });
                
                const countSpan = document.getElementById('custom-skills-selected-actual-count');
                if (countSpan) countSpan.textContent = numSelectedInstances;
                
                // Aktualisiere den Zustand der Haupt-Checkboxes und Add-Specialization-Buttons
                // (Dieser Teil scheint in Ordnung zu sein, wenn renderCurrentStep() nicht immer sofort folgt)
                // Es ist aber besser, wenn renderCurrentStep() sich darum kümmert, falls die Struktur komplexer wird.
                // Für den Moment lassen wir es, da es spezifisch für die Checkboxen ist.
                document.querySelectorAll('.custom-skill-item-base').forEach(baseItemDiv => { // Iteriere über die Basis-Skill-Container
                    const mainCheckbox = baseItemDiv.querySelector('.custom-prof-skill-select-main');
                    if (!mainCheckbox) return;

                    const baseKey = mainCheckbox.dataset.skillKey;
                    const isBaseRepresented = character.customProfessionSelectedSkills.some(inst => inst.key === baseKey);
                    mainCheckbox.checked = isBaseRepresented;

                    if (!isBaseRepresented) { // Wenn keine Instanz dieses Basis-Skills ausgewählt ist
                        mainCheckbox.disabled = numSelectedInstances >= 10;
                    } else {
                        mainCheckbox.disabled = false; 
                    }
                    mainCheckbox.closest('label').classList.toggle('disabled-choice', mainCheckbox.disabled);


                    const addSpecButton = baseItemDiv.querySelector('.btn-add-another-specialization');
                    if (addSpecButton) {
                        addSpecButton.style.display = (ALL_SKILLS[baseKey].type && isBaseRepresented && numSelectedInstances < 10) ? 'inline-block' : 'none';
                         // Deaktiviere den Add-Button auch, wenn die maximale Anzahl von Skills erreicht ist
                        addSpecButton.disabled = numSelectedInstances >= 10;
                    }
                });


                // Aktualisiere die Controls für jede gerenderte Instanz
                // ***** HIER IST DIE WICHTIGE ÄNDERUNG DES SELEKTORS *****
                document.querySelectorAll('#custom-profession-skill-list .skill-instance-controls').forEach(itemDiv => {
                    const tempId = itemDiv.dataset.instanceTempId;
                    const instance = character.customProfessionSelectedSkills.find(inst => inst.tempInstanceId === tempId);
                    
                    if (!instance) { 
                        // Wenn die Instanz nicht mehr im Datenmodell ist (z.B. entfernt),
                        // sollte das DOM-Element entfernt werden. Am besten durch renderCurrentStep().
                        // Hier können wir es ausblenden oder entfernen, wenn renderCurrentStep() nicht unmittelbar folgt.
                        // itemDiv.remove(); // Vorsicht damit, wenn renderCurrentStep sowieso kommt.
                        return;
                    }

                    const skillDef = ALL_SKILLS[instance.key];
                    const currentPoints = instance.points || 0;
                    const currentTotal = skillDef.base + currentPoints;

                    const assignedPointsSpan = itemDiv.querySelector('.custom-skill-assigned-points');
                    const totalValueSpan = itemDiv.querySelector('.custom-skill-total-value');
                    
                    if(assignedPointsSpan) assignedPointsSpan.textContent = currentPoints;
                    if(totalValueSpan) totalValueSpan.textContent = `${currentTotal}%`;
                    
                    // Aktualisiere Button-Disabled-Status
                    itemDiv.querySelectorAll('.custom-skill-point-btn').forEach(btn => {
                        const action = btn.dataset.action;
                        const amount = parseInt(btn.dataset.amount);

                        if (action === "decrease") {
                            // Deaktiviere, wenn die aktuellen Punkte des Skills 0 sind oder weniger als der Betrag zum Verringern.
                            btn.disabled = (currentPoints === 0 || currentPoints < amount);
                        } else if (action === "increase") {
                            const skillTotalValue = skillDef.base + currentPoints;
                            // Deaktiviere, wenn:
                            // 1. Der Skill-Gesamtwert bereits 60% oder mehr beträgt.
                            // 2. Oder nicht genügend Punkte im Gesamtbudget übrig sind, um diesen Inkrementbetrag zu decken.
                            btn.disabled = (skillTotalValue >= 60) || (remainingPoints < amount);
                        }
                    });
                });
                // Sicherstellen, dass die Navigation (Next Button) auch aktualisiert wird,
                // da sich die Gültigkeit des Schritts ändern kann (z.B. alle Punkte verteilt).
                updateNavigationButtons();
            }


            function handleConfirmCustomSkills() {
                // Validierung zuerst (bleibt gleich)
                if (!validateStep1(true)) {
                    return;
                }

                // Schritt 1: Skills aus Custom Setup ins Haupt-Skill-Array übertragen
                // `initializeCharacterSkills()` erstellt die Basis-Skill-Instanzen (ohne Typ für typisierte).
                initializeCharacterSkills(); // Setzt alle Skills auf ihre Basiswerte zurück

                // Jetzt die professionellen Skills aus dem Custom Setup hinzufügen/aktualisieren
                character.customProfessionSelectedSkills.forEach(customInstance => {
                    const skillKey = customInstance.key;
                    const typeName = customInstance.typeName;
                    const pointsFromCustom = customInstance.points || 0;
                    const baseValue = ALL_SKILLS[skillKey] ? ALL_SKILLS[skillKey].base : 0;
                    const finalValue = Math.min(baseValue + pointsFromCustom, 60); // Max 60% aus Prof.

                    // Finde oder erstelle die spezifische Instanz im Haupt-Skill-Array
                    // `findOrCreateSkillInstance` sollte die Instanz korrekt erstellen oder aktualisieren
                    const mainSkillInstance = findOrCreateSkillInstance(skillKey, typeName, true, pointsFromCustom);
                    
                    if (mainSkillInstance) {
                        mainSkillInstance.isProfessional = true; // Markiere als professionell
                        // Der Wert wurde in findOrCreateSkillInstance bereits berechnet
                        // mainSkillInstance.value = finalValue; // Sollte schon durch findOrCreate korrekt sein
                        // mainSkillInstance.baseValueFromProfession = pointsFromCustom; // Wird auch in findOrCreate gesetzt
                    } else {
                        console.error("Konnte Skill-Instanz nicht erstellen/finden für Custom Skill:", customInstance);
                    }
                });

                // Schritt 2: Status ändern
                character.customProfessionSetupStage = 'done';

                // Schritt 3: UI aktualisieren, um die +20% Erhöhungsliste anzuzeigen
                renderCurrentStep();
            }


            // VALIDATE STEP 1 (ERWEITERT für alle Phasen)
            function validateStep1(showAlerts = true) {
                // console.log("--- ENTERING validateStep1 ---");
                // console.log("Current professionKey:", character.professionKey);
                // console.log("Is Custom Profession:", character.isCustomProfession);
                // console.log("Custom Profession Stage:", character.customProfessionSetupStage);

                if (!character.professionKey) {
                    if (showAlerts) alert(t('alert_select_profession'));
                    // console.log("validateStep1 FAILS: No professionKey");
                    return false;
                }

                if (character.isCustomProfession) {
                    if (character.customProfessionSetupStage === 'bonds') {
                        // console.log("validateStep1 (Custom/Bonds): OK (Button-driven)");
                        return true; // Nächster Schritt ist hier der "Confirm Bonds"-Button
                    } else if (character.customProfessionSetupStage === 'skills') { 
                        // console.log("--- Validating Custom Profession - Skills Stage ---");
                        const selectedSkillsCount = Object.keys(character.customProfessionSelectedSkills).length;
                        if (selectedSkillsCount !== 10) { 
                            if (showAlerts) alert(t('alert_max_10_custom_skills'));
                            // console.log(`validateStep1 FAILS (Custom/Skills): Skill count is ${selectedSkillsCount}, not 10`);
                            return false;
                        }

                        let pointsSpent = 0;
                        Object.values(character.customProfessionSelectedSkills).forEach(skill => pointsSpent += (skill.points || 0));
                        if (pointsSpent !== character.customProfessionSkillPointBudget) {
                            if (showAlerts) alert(t('alert_distribute_all_custom_points', { 
                                totalBudget: character.customProfessionSkillPointBudget, 
                                remainingPoints: character.customProfessionSkillPointBudget - pointsSpent 
                            }));
                            // console.log(`validateStep1 FAILS (Custom/Skills): Points not fully distributed. Spent: ${pointsSpent}, Budget: ${character.customProfessionSkillPointBudget}`);
                            return false;
                        }

                        for (const skillKey in character.customProfessionSelectedSkills) {
                            const customSkill = character.customProfessionSelectedSkills[skillKey];
                            const baseSkillValue = ALL_SKILLS[skillKey] ? ALL_SKILLS[skillKey].base : 0;
                            if ((baseSkillValue + customSkill.points) > 60) {
                                if (showAlerts) alert(t('alert_custom_skill_max_60', { skillName: t(ALL_SKILLS[skillKey].nameKey) }));
                                // console.log(`validateStep1 FAILS (Custom/Skills): Skill ${skillKey} exceeds 60%`);
                                return false;
                            }
                            if (ALL_SKILLS[skillKey]?.type && (!customSkill.typeName || customSkill.typeName.trim() === "")) {
                                if (showAlerts) alert(t('alert_specify_type_for_custom_skill', { skillName: t(ALL_SKILLS[skillKey].nameKey) }));
                                // console.log(`validateStep1 FAILS (Custom/Skills): Type needed for ${skillKey}`);
                                return false;
                            }
                        }
                        // console.log("validateStep1 (Custom/Skills): OK");
                        return true; 
                    } else if (character.customProfessionSetupStage === 'done') {
                        // console.log("--- Validating Custom Profession - Done Stage (+20% increases) ---");
                        // Validierung der +20% Erhöhungen (optional, da UI es meist handhabt)
                        // Hier primär wichtig: Sind alle *vorher definierten typisierten Skills* noch valide (haben Typ)? Sollten sie sein.
                    }
                } else { // Standardberuf
                    // console.log("--- Validating Standard Profession ---");
                    const profData = PROFESSIONS[character.professionKey];
                    if (!profData) {
                        // console.log("validateStep1 FAILS (Standard): profData is undefined for professionKey:", character.professionKey);
                        return false; 
                    }
                    
                    // Prüfe typisierte Basis-Skills des Berufs
                    if (profData.baseSkills) {
                        for (const skillInfo of profData.baseSkills) {
                            let skillToCheckKey = skillInfo.key;
                            let requiresType = ALL_SKILLS[skillInfo.key]?.type; // Ist der Basis-Skill an sich typisiert?
                            let typeNameToCheck = null;
                            let instanceIdToCheck = null;

                            if (skillInfo.orSkills) {
                                const activeOrSkillKey = character.orSkillChoices[skillInfo.id] || skillInfo.orSkills[0].key;
                                const activeOrSkillData = skillInfo.orSkills.find(os => os.key === activeOrSkillKey);
                                if (activeOrSkillData) {
                                    skillToCheckKey = activeOrSkillData.key;
                                    requiresType = ALL_SKILLS[skillToCheckKey]?.type;
                                    // Für "or" Skills, die typisiert sind, muss der Typ von der Instanz kommen,
                                    // die in handleProfessionChange oder den Choice Listeners erstellt wurde.
                                    // Die ID-Logik für orSkills Instanzen muss konsistent sein.
                                    // Suchen wir die relevante Instanz:
                                    const orInstance = character.skills.find(s => s.key === skillToCheckKey && s.isProfessional && !s.isChoiceSkill); // Vereinfacht
                                    typeNameToCheck = orInstance?.typeName;
                                } else { continue; } 
                            } else if (requiresType) { // Direkter typisierter Basis-Skill
                                // Finde die spezifische Instanz für diesen Berufsskill
                                // Die ID-Logik hier muss mit der in renderProfessionSpecificChoices übereinstimmen
                                instanceIdToCheck = `${skillInfo.key}_prof_${skillInfo.id}`; 
                                const baseInstance = character.skills.find(s => s.instanceId === instanceIdToCheck);
                                typeNameToCheck = baseInstance?.typeName;
                            }

                            if (requiresType && (!typeNameToCheck || typeNameToCheck.trim() === "")) {
                                if (showAlerts) alert(t('alert_type_for_skill_needed', { skillName: t(ALL_SKILLS[skillToCheckKey].nameKey) }));
                                // console.log(`validateStep1 FAILS (Standard/Base): Type needed for ${skillToCheckKey} (Instance ID: ${instanceIdToCheck})`);
                                return false;
                            }
                        }
                    }
                    // Prüfe ausgewählte Choice Skills mit Typ
                    if (profData.choiceSkills) {
                        for (const choice of profData.choiceSkills.options) {
                            if (character.profChoiceSkillSelections[choice.key] && ALL_SKILLS[choice.key]?.type) {
                                // Finde die Instanz dieses Choice Skills
                                const choiceInstance = character.skills.find(s => s.key === choice.key && s.isChoiceSkill);
                                if (!choiceInstance || !choiceInstance.typeName || choiceInstance.typeName.trim() === "") {
                                    if (showAlerts) alert(t('alert_type_for_skill_needed', { skillName: t(ALL_SKILLS[choice.key].nameKey) }));
                                    // console.log(`validateStep1 FAILS (Standard/Choice): Type needed for choice skill ${choice.key}`);
                                    return false;
                                }
                            }
                        }
                    }
                    // console.log("validateStep1 (Standard): OK");
                }
                // Finale Prüfung für die +20% Erhöhungsphase (gilt für Standard und Custom 'done')
                // Diese Phase wird erreicht, NACHDEM alle Typen für Berufs-Skills gesetzt sein sollten.
                if (!character.isCustomProfession || (character.isCustomProfession && character.customProfessionSetupStage === 'done')) {
                    // Hier könnte man prüfen, ob z.B. mindestens eine Erhöhung gemacht wurde, falls gewünscht,
                    // oder ob die maximale Anzahl nicht überschritten wurde (obwohl die UI das verhindern sollte).
                    // Für den Moment: Wenn wir hier sind, ist es okay für den "Next"-Button dieses Schritts.
                    // Die eigentliche Logik für die +20% ist in renderAllSkillsList und den Handlern.
                }
                // console.log("validateStep1: Reached end, returning true.");
                return true; 
            }

            // SAVE STEP 1 (angepasst)
            function saveStep1() {
                // Die meisten Daten sind schon im character-Objekt durch die Event-Handler.
                // Hier passiert nichts Zusätzliches für Standardberufe.
                // Für Custom Berufe ist die Haupt"speicherung" (Übertragung zu character.skills)
                // in handleConfirmCustomSkills.
                // console.log("Step 1 saved/processed. Character object:", JSON.parse(JSON.stringify(character)));
            }

            // STEP 2: STATISTICS
            function renderStep2_Statistics() {
                let html = `<div class="step" id="step2-statistics">
                    <h2 data-i18n="step_name_2"></h2>
                    <div class="info-box">
                        <p data-i18n="step2_info_stats"></p>
                        <ul>`;
                STAT_KEYS.forEach(key => {
                    html += `<li><strong>${t('stat_' + key.toLowerCase() + '_name')}</strong>: <span data-i18n="stat_${key.toLowerCase()}_desc"></span></li>`;
                });
                html += `</ul></div>

                    <h3 data-i18n="step2_select_array_label"></h3>
                    <div id="stat-array-selection">`;
                STAT_ARRAYS.forEach((arr, index) => {
                    const isChecked = character.statArrayChoice === index;
                    // Stelle sicher, dass die values als String im JSON sind.
                    // JSON.stringify stellt sicher, dass es ein korrekter JSON-String ist.
                    const replacementsJsonString = JSON.stringify({index: (index + 1).toString(), values: arr.join(', ')});

                    html += `<label class="inline-label">
                                <input type="radio" name="stat-array" value="${index}" ${isChecked ? 'checked' : ''}>
                                <span data-i18n="stat_array_option_label" data-i18n-replacements='${replacementsJsonString}'>
                                    ${t('stat_array_option_label', {index: index + 1, values: arr.join(', ')})}
                                </span>
                             </label><br>`;
                });
                html += `</div>

                    <h3 data-i18n="step2_assign_stats_label" style="margin-top: 20px;"></h3>
                    <div class="info-box" style="margin-top: 20px;">
                        <p data-i18n="step2_info_distinguishing_feature"></p>
                    </div>
                    <div id="stat-assignment-container">`;

                // Container für Attributzuweisungen (wird von updateStatAssignmentUI gefüllt)
                html += `</div>

                
                </div>`;
                return html;
            }
            function attachStep2Listeners() {
                const arraySelectionRadios = document.querySelectorAll('input[name="stat-array"]');
                arraySelectionRadios.forEach(radio => {
                    radio.addEventListener('change', handleStatArraySelectionChange);
                });

                // Event Delegation für die dynamisch erstellten Selects
                const assignmentContainer = document.getElementById('stat-assignment-container');
                if (assignmentContainer) {
                    assignmentContainer.addEventListener('change', (event) => {
                        if (event.target.classList.contains('stat-value-select')) {
                            handleStatValueAssignmentChange(event.target);
                        }
                    });
                    assignmentContainer.addEventListener('input', (event) => {
                        if (event.target.classList.contains('distinguishing-feature-input')) {
                            const statKey = event.target.dataset.statKey;
                            character.distinguishingFeatures[statKey] = event.target.value;
                            // Keine UI-Aktualisierung hier nötig, Validierung prüft nichts dazu
                        }
                    });
                }
                
                // Initialisiere die Zuweisungs-UI, falls ein Array bereits ausgewählt ist
                if (character.statArrayChoice !== null) {
                    updateStatAssignmentUI();
                }
            }

            function handleStatArraySelectionChange(event) {
                character.statArrayChoice = parseInt(event.target.value);
                // Setze bestehende Zuweisungen und Merkmale zurück, da sich das Array geändert hat
                character.statAssignments = {};
                STAT_KEYS.forEach(key => character.stats[key] = 0); // Setze Hauptstats zurück
                character.distinguishingFeatures = {};
                updateStatAssignmentUI();
                updateNavigationButtons();
            }

            function handleStatValueAssignmentChange(selectElement) {
                const statKey = selectElement.dataset.statKey;
                const selectedValue = selectElement.value === "" ? null : parseInt(selectElement.value);

                // Alte Zuweisung für diesen Stat entfernen, falls vorhanden und Wert geändert wird
                const oldAssignedValue = character.statAssignments[statKey];
                character.statAssignments[statKey] = selectedValue; // Neue Zuweisung speichern

                // Haupt-Stat im character-Objekt aktualisieren
                character.stats[statKey] = selectedValue !== null ? selectedValue : 0;

                updateStatAssignmentUI(); // Um Dropdowns und Anzeigen zu aktualisieren
                updateNavigationButtons();
            }
            
            function updateStatAssignmentUI() {
                const container = document.getElementById('stat-assignment-container');
                if (!container || character.statArrayChoice === null) {
                    if (container) container.innerHTML = `<p>${t('alert_select_stat_array')}</p>`;
                    return;
                }
                container.innerHTML = ''; // Leere für Neuaufbau

                const chosenArrayBase = STAT_ARRAYS[character.statArrayChoice];

                STAT_KEYS.forEach(currentStatKey => {
                    const currentAssignedValueForThisStat = character.statAssignments[currentStatKey];
                    const statValue = character.stats[currentStatKey] || 0;
                    const percentile = statValue * 5;
                    const showFeatureInput = statValue !== 0 && (statValue < 9 || statValue > 12);

                    // 1. Erstelle eine Arbeitskopie des Basis-Arrays
                    let workingArray = [...chosenArrayBase];

                    // 2. Entferne Werte, die *anderen* Stats als dem aktuellen `currentStatKey` bereits zugewiesen sind
                    STAT_KEYS.forEach(otherStatKey => {
                        if (otherStatKey !== currentStatKey) {
                            const valAssignedToOtherStat = character.statAssignments[otherStatKey];
                            if (valAssignedToOtherStat !== null && valAssignedToOtherStat !== undefined) {
                                const indexToRemove = workingArray.indexOf(valAssignedToOtherStat);
                                if (indexToRemove > -1) {
                                    workingArray.splice(indexToRemove, 1);
                                }
                            }
                        }
                    });
                    // `workingArray` enthält jetzt alle Werte, die für den `currentStatKey` noch potenziell verfügbar sind,
                    // inklusive Duplikaten. z.B. [13, 13, 12, 11]

                    // 3. Sortiere das workingArray für die Anzeige im Dropdown
                    const sortedWorkingArray = [...workingArray].sort((a, b) => b - a);

                    // Stelle sicher, dass der aktuell zugewiesene Wert auch angezeigt wird,
                    // falls er durch irgendeine Logik (sollte hier nicht passieren) aus sortedWorkingArray gefallen wäre.
                    // Für den Fall, dass der `currentAssignedValueForThisStat` nicht in `sortedWorkingArray` ist,
                    // fügen wir ihn nicht hinzu, da das bedeuten würde, dass er nicht mehr verfügbar sein sollte.
                    // Die `selected`-Logik unten kümmert sich darum, den richtigen Wert auszuwählen.

                    // DEBUGGING:
                    // console.log(`Dropdown für ${currentStatKey}: currentAssigned=${currentAssignedValueForThisStat}, sortedWorkingArray=${JSON.stringify(sortedWorkingArray)}`);

                    let rowHtml = `<div class="stat-allocation-row">
                        <label for="stat-select-${currentStatKey}">${t('stat_' + currentStatKey.toLowerCase() + '_name')}</label>
                        <select id="stat-select-${currentStatKey}" class="stat-value-select" data-stat-key="${currentStatKey}">
                            <option value="">-- ${t('select_one_option')} --</option>`;

                    // ***** HIER DIE ÄNDERUNG: Iteriere über sortedWorkingArray (mit Duplikaten) *****
                    sortedWorkingArray.forEach(val => {
                        // Das `selected`-Attribut wird nur gesetzt, wenn der Wert der Option
                        // mit dem `currentAssignedValueForThisStat` übereinstimmt.
                        // Wenn es mehrere Optionen mit demselben Wert gibt (z.B. zwei "13" Optionen),
                        // wird der Browser in der Regel die erste davon als "selected" markieren,
                        // wenn currentAssignedValueForThisStat = 13 ist. Das ist für die Anzeige okay.
                        // Die Logik beim *Auswählen* aus dem Dropdown (handleStatValueAssignmentChange)
                        // und die Validierung (validateStep2) müssen dann die korrekte Verteilung sicherstellen.
                        rowHtml += `<option value="${val}" ${currentAssignedValueForThisStat === val ? 'selected' : ''}>${val}</option>`;
                    });

                    rowHtml += `</select>
                        <span class="stat-percentile" id="percentile-${currentStatKey}">${percentile}%</span>
                    </div>`;
                    if (showFeatureInput) {
                         rowHtml += `<div class="distinguishing-feature-input-container">
                                        <label for="feature-${currentStatKey}" class="distinguishing-feature-label">${t('distinguishing_feature_label')}</label>
                                        <input type="text" id="feature-${currentStatKey}" class="distinguishing-feature-input" data-stat-key="${currentStatKey}"
                                               placeholder="${t('distinguishing_feature_placeholder')}"
                                               value="${character.distinguishingFeatures[currentStatKey] || ''}">
                                    </div>`;
                    }
                    container.innerHTML += rowHtml;
                });
                translateAllElements(container);
            }
            
            function validateStep2(showAlerts = true) {
                if (character.statArrayChoice === null) {
                    if (showAlerts) alert(t('alert_select_stat_array'));
                    return false;
                }
                const assignedStatValues = Object.values(character.statAssignments);
                if (assignedStatValues.some(val => val === null) || assignedStatValues.length < STAT_KEYS.length) {
                    if (showAlerts) alert(t('alert_assign_all_stats'));
                    return false;
                }

                // Prüfe auf Eindeutigkeit der zugewiesenen Werte gemäß dem gewählten Array
                const chosenArray = [...STAT_ARRAYS[character.statArrayChoice]].sort();
                const currentAssignments = [...assignedStatValues].sort();

                if (chosenArray.length !== currentAssignments.length) return false; // Sollte nicht passieren
                for (let i = 0; i < chosenArray.length; i++) {
                    if (chosenArray[i] !== currentAssignments[i]) {
                        if (showAlerts) alert(t('alert_unique_stat_values'));
                        return false;
                    }
                }
                return true;
            }

            function saveStep2() {
                // Die Werte sind bereits in character.stats und character.distinguishingFeatures durch die Handler.
                // character.statAssignments ist ein Hilfsobjekt für die UI-Logik dieses Schritts.
                // console.log("Step 2 Data Saved:", JSON.parse(JSON.stringify(character.stats)), JSON.parse(JSON.stringify(character.distinguishingFeatures)));
            }
            function calculateDerivedAttributes() {
                const stats = character.stats;
                if (!stats.STR || !stats.CON || !stats.POW) { // Stelle sicher, dass Basis-Stats vorhanden sind
                    // console.warn("Cannot calculate derived attributes: Primary stats not fully set.");
                    character.derivedAttributes = { HP: 0, WP: 0, SAN: 0, BP: 0 }; // Setze auf 0, falls nicht berechenbar
                    return;
                }

                const HP = Math.ceil((stats.STR + stats.CON) / 2);
                const WP = stats.POW;
                const SAN = stats.POW * 5;
                const BP = SAN - stats.POW;

                character.derivedAttributes = {
                    HP: HP,
                    WP: WP,
                    SAN: SAN,
                    BP: BP
                };
            }


            // STEP 3: DERIVED ATTRIBUTES
            function renderStep3_DerivedAttributes() {
                calculateDerivedAttributes(); // Sicherstellen, dass die Werte aktuell sind
                const derived = character.derivedAttributes;

                let html = `<div class="step" id="step3-derived-attributes">
                    <h2 data-i18n="step3_info_derived_title"></h2>
                    <div class="info-box">
                        <p data-i18n="step3_info_derived_intro"></p>
                    </div>
                    
                    <div class="derived-attributes-display">
                        <div class="derived-attr-header derived-attr-row">
                            <strong data-i18n="derived_attribute_label"></strong>
                            <strong data-i18n="derived_value_label"></strong>
                            <strong data-i18n="derived_description_label"></strong>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_hp_name"></span>
                            <span>${derived.HP}</span>
                            <span data-i18n="attr_hp_desc"></span>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_wp_name"></span>
                            <span>${derived.WP}</span>
                            <span data-i18n="attr_wp_desc"></span>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_san_name"></span>
                            <span>${derived.SAN}</span>
                            <span data-i18n="attr_san_desc"></span>
                        </div>
                        <div class="derived-attr-row">
                            <span data-i18n="attr_bp_name"></span>
                            <span>${derived.BP}</span>
                            <span data-i18n="attr_bp_desc"></span>
                        </div>
                    </div>
                </div>`;

                // CSS für die Flexbox-Darstellung
                html += `<style>
                    .derived-attributes-display { 
                        margin-top: 20px; 
                        border-top: 1px solid #ccc; /* Trennlinie über der Tabelle */
                    }
                    .derived-attr-row {
                        display: flex; /* Jede Zeile ist ein Flex-Container */
                        align-items: flex-start; /* Vertikale Ausrichtung oben */
                        padding: 10px 0; /* Etwas vertikaler Abstand */
                        border-bottom: 1px dotted #eee;
                    }
                    .derived-attr-row:last-child {
                        border-bottom: none;
                    }
                    /* Styling für die Kinder der Zeilen (also die Spalten-Elemente) */
                    .derived-attr-row > * { 
                        box-sizing: border-box; /* Stellt sicher, dass Padding nicht die Breite erhöht */
                    }
                    .derived-attr-row > :nth-child(1) { /* 1. Spalte: Attributname */
                        flex-basis: 200px;  /* Gib dem Namen etwas mehr Platz, oder max-content */
                        flex-shrink: 0;     /* Verhindert, dass es schrumpft */
                        font-weight: bold;
                        text-align: right;
                        padding-right: 15px; /* Abstand zum Wert */
                    }
                    .derived-attr-row > :nth-child(2) { /* 2. Spalte: Wert */
                        flex-basis: 60px;   /* Feste Breite für den Wert */
                        flex-shrink: 0;
                        font-weight: bold;
                        text-align: center;
                    }
                    .derived-attr-row > :nth-child(3) { /* 3. Spalte: Beschreibung */
                        flex-grow: 1;       /* Nimmt den restlichen Platz ein */
                        font-size: 0.9em;
                        color: #555;        /* Etwas dunklerer Text für bessere Lesbarkeit */
                        padding-left: 15px;  /* Abstand vom Wert */
                        line-height: 1.4;   /* Verbessert Lesbarkeit bei längeren Beschreibungen */
                    }
                    .derived-attr-header > strong {
                         font-weight: bold; /* Stellt sicher, dass Header-Text fett ist (überschreibt ggf. nth-child) */
                         color: #333;      /* Dunklerer Header-Text */
                    }
                    /* Spezifische Ausrichtung für Header-Elemente, falls nötig (meist schon durch obige Regeln abgedeckt) */
                    .derived-attr-header > :nth-child(1) { text-align: right; }
                    .derived-attr-header > :nth-child(2) { text-align: center; }
                    .derived-attr-header > :nth-child(3) { text-align: left; }
                </style>`;

                return html;
            }

            // Für Schritt 3 sind keine spezifischen Listener notwendig, da es eine reine Anzeige ist.
            function attachStep3Listeners() {
                // Leer, oder ggf. Listener, falls man später Interaktionen hinzufügen möchte.
            }
            
            function validateStep3() {
                // Keine Nutzereingaben, die validiert werden müssen.
                // Wir könnten prüfen, ob die abgeleiteten Attribute berechnet wurden,
                // aber das passiert in renderStep3_DerivedAttributes.
                return true;
            }

            function saveStep3() {
                // Die Werte wurden bereits in character.derivedAttributes durch calculateDerivedAttributes() gespeichert,
                // welches in renderStep3_DerivedAttributes() aufgerufen wird.
                // console.log("Step 3 Data (Derived Attributes):", JSON.parse(JSON.stringify(character.derivedAttributes)));
            }
            // STEP 4: BONDS & MOTIVATIONS
            function renderStep4_BondsMotivations() {
                // 1. Bestimme die Anzahl der Bonds und den Startwert
                let numberOfBonds = 0;
                const chaScore = character.stats.CHA || 0; // Fallback auf 0, falls CHA noch nicht gesetzt

                if (character.isCustomProfession) {
                    numberOfBonds = character.customProfessionBonds;
                } else if (character.professionKey && PROFESSIONS[character.professionKey]) {
                    numberOfBonds = PROFESSIONS[character.professionKey].bonds;
                } else {
                    // Fallback, sollte nicht oft eintreten, wenn Schritt 1 valide ist
                    // Man könnte hier auch eine Standardanzahl nehmen oder eine Warnung ausgeben.
                    // Für den Moment: 0, dann wird keine Bond-Eingabe gerendert, wenn kein Beruf.
                }

                // 2. Stelle sicher, dass das character.bonds Array die korrekte Länge hat
                // und die Scores initialisiert sind.
                // Wir erstellen das Array neu, um die richtige Anzahl sicherzustellen.
                // Bereits eingegebene Beschreibungen versuchen wir zu erhalten.
                const oldBonds = [...character.bonds]; // Kopie der alten Bonds
                character.bonds = [];
                for (let i = 0; i < numberOfBonds; i++) {
                    character.bonds.push({
                        description: oldBonds[i]?.description || "", // Behalte alte Beschreibung, wenn möglich
                        score: chaScore // Setze Score basierend auf aktuellem CHA
                    });
                }
                
                // Stelle sicher, dass character.motivations ein Array von 5 Strings ist
                if (!Array.isArray(character.motivations) || character.motivations.length !== 5) {
                    const oldMotivations = Array.isArray(character.motivations) ? [...character.motivations] : [];
                    character.motivations = ["", "", "", "", ""];
                    for(let i=0; i < 5; i++) {
                        if(oldMotivations[i]) character.motivations[i] = oldMotivations[i];
                    }
                }


                let html = `<div class="step" id="step4-bonds-motivations">
                    <h2 data-i18n="step4_title_bonds_motivations"></h2>
                    <div class="info-box">
                        <p data-i18n="step4_info_bonds_mot_intro"></p>
                    </div>

                    <!-- === BONDS === -->
                    <h3 data-i18n="step4_1_bonds_title"></h3>
                    <div class="info-box">
                        <p data-i18n="step4_info_bonds1"></p>
                        <p data-i18n="step4_info_bonds2"></p>
                        <p data-i18n="step4_info_bonds3"></p>
                        <p data-i18n="step4_info_bonds4"></p>
                        <strong data-i18n="bond_examples_label"></strong>
                        <p><small data-i18n="bond_examples_list"></small></p>
                    </div>`;

                if (numberOfBonds > 0) {
                    html += `<p data-i18n="num_bonds_for_profession" data-i18n-replacements='{"count":"${numberOfBonds}"}'>${t('num_bonds_for_profession', {count: numberOfBonds})}</p>`;
                    html += `<div id="bonds-input-container">`;
                    for (let i = 0; i < numberOfBonds; i++) {
                        html += `<div class="bond-entry">
                                    <label for="bond-desc-${i}" data-i18n="bond_label_number" data-i18n-replacements='{"number":"${i + 1}"}'>${t('bond_label_number', {number: i+1})}</label>
                                    <input type="text" id="bond-desc-${i}" class="bond-description-input" data-bond-index="${i}" 
                                           value="${character.bonds[i]?.description || ''}" 
                                           placeholder="${t('bond_description_placeholder')}">
                                    <span data-i18n="bond_score_label"></span> <span>${chaScore}</span>
                                 </div>`;
                    }
                    html += `</div>`;
                } else {
                    html += `<p><em>No bonds available for the current profession selection or CHA score not yet set.</em></p>`; // Fallback-Text
                }
                
                html += `<!-- === MOTIVATIONS === -->
                    <h3 data-i18n="step4_2_motivations_title" style="margin-top: 30px;"></h3>
                    <div class="info-box">
                        <p data-i18n="step4_info_motivations1"></p>
                        <p data-i18n="step4_info_motivations2"></p>
                        <p data-i18n="step4_info_motivations3"></p>
                    </div>
                    <div id="motivations-input-container">`;
                for (let i = 0; i < 5; i++) {
                    html += `<div class="motivation-entry">
                                <label for="motivation-${i}" data-i18n="motivation_label_number" data-i18n-replacements='{"number":"${i + 1}"}'>${t('motivation_label_number', {number: i+1})}</label>
                                <input type="text" id="motivation-${i}" class="motivation-input" data-motivation-index="${i}" 
                                       value="${character.motivations[i] || ''}" 
                                       placeholder="${t('motivation_placeholder')}">
                             </div>`;
                }
                html += `</div></div>`;
                return html;
            }

            function attachStep4Listeners() {
                const bondsContainer = document.getElementById('bonds-input-container');
                if (bondsContainer) {
                    bondsContainer.addEventListener('input', (event) => {
                        if (event.target.classList.contains('bond-description-input')) {
                            const index = parseInt(event.target.dataset.bondIndex);
                            if (character.bonds[index]) {
                                character.bonds[index].description = event.target.value;
                            }
                        }
                    });
                }

                const motivationsContainer = document.getElementById('motivations-input-container');
                if (motivationsContainer) {
                    motivationsContainer.addEventListener('input', (event) => {
                        if (event.target.classList.contains('motivation-input')) {
                            const index = parseInt(event.target.dataset.motivationIndex);
                            if (character.motivations && character.motivations[index] !== undefined) {
                                character.motivations[index] = event.target.value;
                            }
                        }
                    });
                }
            }
            
            function validateStep4(showAlerts = true) {
                // Optional: Prüfen, ob Bond-Beschreibungen ausgefüllt sind, falls das Pflicht sein soll.
                // Für den Moment gehen wir davon aus, dass leere Bond-Beschreibungen okay sind.
                // Man könnte hier prüfen, ob chaScore > 0 ist, falls das eine Voraussetzung wäre,
                // aber die Hauptvalidierung für Stats war in Schritt 2.
                return true; 
            }

            function saveStep4() {
                // Die Daten (Bond-Beschreibungen, Bond-Scores, Motivationen) werden bereits
                // durch die Event-Listener (für Beschreibungen/Motivationen) und beim Rendern
                // (für Scores und Anzahl der Bonds) im character-Objekt aktualisiert.
                // Hier könnte man noch einmal sicherstellen, dass die Bond-Scores aktuell sind.
                const chaScore = character.stats.CHA || 0;
                character.bonds.forEach(bond => bond.score = chaScore);
                // console.log("Step 4 Data Saved:", JSON.parse(JSON.stringify(character.bonds)), JSON.parse(JSON.stringify(character.motivations)));
            }
            // STEP 5: SUMMARY
            function renderStep5_Summary() {
                calculateDerivedAttributes(); 

                let html = `<div class="step" id="step5-summary">
                    <h2 data-i18n="summary_title"></h2>`;

                    let professionDisplayName = t('not_selected');
                    if (character.professionKey) {
                        if (character.professionKey === 'custom_profession') {
                            professionDisplayName = character.customProfessionName.trim() !== "" ? character.customProfessionName : t(PROFESSIONS.custom_profession.nameKey);
                        } else if (PROFESSIONS[character.professionKey]) {
                            professionDisplayName = t(PROFESSIONS[character.professionKey].nameKey);
                        } else {
                            professionDisplayName = character.professionKey.replace(/_/g, ' '); // Fallback
                        }
                    }

                    html += `<!-- Zeile 1: Persönliche Details & Beruf -->
                            <div class="summary-section summary-header-line">
                                <span><strong data-i18n="summary_placeholder_name">Name:</strong></span>
                                <span><strong data-i18n="summary_placeholder_age">Age:</strong></span>
                                <span><strong data-i18n="summary_placeholder_sex">Sex:</strong></span>
                                <span class="summary-profession-header">
                                    <strong data-i18n="summary_section_profession"></strong>: 
                                    ${professionDisplayName}
                                </span>
                            </div>

                    <!-- Hauptcontainer für zweispaltiges Layout (Stats/Bonds | Derived/Motivations) -->
                    <div class="summary-main-columns-container">
                        <!-- Linke Spalte -->
                        <div class="summary-main-column-left">
                            <!-- Statistics -->
                            <h3 data-i18n="summary_section_statistics"></h3>
                            <div class="summary-section summary-stats-grid">`;
                STAT_KEYS.forEach(key => {
                    const statName = t('stat_' + key.toLowerCase() + '_name');
                    const statValue = character.stats[key] || 0;
                    const percentile = statValue * 5;
                    const feature = character.distinguishingFeatures[key] || "";
                    html += `<div class="summary-stat-item">
                                <strong>${statName}:</strong> ${statValue} (${percentile}%)
                                ${feature ? `<em>(${feature})</em>` : ''}
                             </div>`;
                });
                html += `       </div>

                            <!-- Derived Attributes -->
                            <h3 data-i18n="summary_section_derived_attr" style="margin-top: 15px;"></h3>
                            <div class="summary-section summary-derived-grid">
                                <div><strong>${t('attr_hp_name')}:</strong> ${character.derivedAttributes.HP}</div>
                                <div><strong>${t('attr_wp_name')}:</strong> ${character.derivedAttributes.WP}</div>
                                <div><strong>${t('attr_san_name')}:</strong> ${character.derivedAttributes.SAN}</div>
                                <div><strong>${t('attr_bp_name')}:</strong> ${character.derivedAttributes.BP}</div>
                            </div>
                        </div>

                        <!-- Rechte Spalte -->
                        <div class="summary-main-column-right">
                            <!-- Bonds (neben Statistics) -->
                            <h3 data-i18n="summary_section_bonds"></h3>
                            <div class="summary-section">`;
                if (character.bonds && character.bonds.length > 0) {
                    html += `<ul>`;
                    character.bonds.forEach((bond, index) => {
                        html += `<li><strong>${t('bond_label_number', {number: index + 1})}:</strong> ${bond.description || `(${t('not_defined')})`} - Score: ${bond.score}</li>`;
                    });
                    html += `</ul>`;
                } else {
                    html += `<p><em>${t('not_defined')}</em></p>`;
                }
                html += `       </div>

                            <!-- Motivations (neben Derived Attributes) -->
                            <h3 data-i18n="summary_section_motivations" style="margin-top: 15px;"></h3>
                            <div class="summary-section">`;
                const definedMotivations = character.motivations.filter(m => m && m.trim() !== "");
                if (definedMotivations.length > 0) {
                    html += `<ul>`;
                    definedMotivations.forEach((motivation) => {
                        html += `<li>${motivation}</li>`;
                    });
                    html += `</ul>`;
                } else {
                    html += `<p><em>${t('not_defined')}</em></p>`;
                }
                html += `       </div>
                        </div>
                    </div>


                    <!-- Fertigkeiten (mehrspaltig - wie vorher) -->
                    <h3 data-i18n="summary_section_skills" style="margin-top: 20px; border-top: 1px solid #eee; padding-top:15px;"></h3>
                    <div class="summary-section summary-skills-multicolumn">`;
                const allCharacterSkills = [];
                if (Array.isArray(character.skills)) { // Sicherstellen, dass es ein Array ist
                    character.skills.forEach(skillInstance => { // skillInstance ist ein Objekt
                        const baseSkillData = ALL_SKILLS[skillInstance.key];
                        if (!baseSkillData) return; // Skill-Definition nicht gefunden

                        let displayName = t(baseSkillData.nameKey);
                        if (skillInstance.typeName && skillInstance.typeName.trim() !== "") {
                            displayName += ` (${skillInstance.typeName.trim()})`;
                        }
                        // Nur Skills anzeigen, die einen Wert > 0 haben oder Modifikationen (Prof, Choice, Increases)
                        // oder wenn es ein typisierter Skill ist, der einen Typ hat (auch mit Wert 0)
                        if (skillInstance.value > 0 || skillInstance.increases > 0 || skillInstance.isProfessional || skillInstance.isChoiceSkill || (baseSkillData.type && skillInstance.typeName)) {
                             allCharacterSkills.push({ name: displayName, value: skillInstance.value });
                        }
                    });
                }
                allCharacterSkills.sort((a, b) => a.name.localeCompare(b.name, currentLanguage));
                if (allCharacterSkills.length > 0) {
                    const numSkillColumns = 3; 
                    const skillsPerColumn = Math.ceil(allCharacterSkills.length / numSkillColumns);
                    for (let i = 0; i < numSkillColumns; i++) {
                        html += `<ul class="skill-column">`;
                        for (let j = 0; j < skillsPerColumn; j++) {
                            const skillIndex = i * skillsPerColumn + j;
                            if (skillIndex < allCharacterSkills.length) {
                                const skill = allCharacterSkills[skillIndex];
                                html += `<li>${skill.name}: <strong>${skill.value}%</strong></li>`;
                            }
                        }
                        html += `</ul>`;
                    }
                } else {
                    html += `<p><em>No skills available.</em></p>`; 
                }
                html += `</div>

                    <div class="summary-actions" style="margin-top: 30px;">
                        <button id="btn-print-summary" class="action-button" data-i18n="btn_print_summary"></button>
                        <button id="btn-download-txt" class="action-button" data-i18n="btn_download_txt"></button>
                    </div>
                </div>`; 

                html += `<style>
                    .summary-section { margin-bottom: 10px; padding-left: 0; }
                    .summary-section ul { list-style-type: none; padding-left: 0; margin-left: 0; }
                    .summary-section li { margin-bottom: 2px; font-size: 0.95em; }

                    .summary-header-line {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 10px 20px;
                        margin-bottom: 20px;
                        padding-bottom: 10px;
                        border-bottom: 1px solid #ccc;
                    }
                    .summary-header-line span { display: inline-block; }
                    .summary-header-line strong { margin-right: 3px; }
                    .summary-profession-header strong { font-weight: bold; }

                    .summary-main-columns-container {
                        display: grid;
                        grid-template-columns: 1fr 1fr; 
                        gap: 20px 30px; 
                        margin-bottom: 20px;
                    }
                    .summary-main-columns-container h3 {
                        margin-top: 0; 
                        margin-bottom: 8px;
                        font-size: 1.2em;
                    }

                    .summary-stats-grid, .summary-derived-grid { 
                        display: grid; 
                        grid-template-columns: 1fr; 
                        gap: 2px; 
                    }
                    .summary-stat-item { margin-bottom: 1px; font-size: 0.95em;} /* Weniger Margin hier */
                    .summary-derived-grid div { font-size: 0.95em; margin-bottom: 1px; }


                    .summary-skills-multicolumn {
                        display: grid;
                        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); 
                        gap: 0px 15px; 
                        align-items: start;
                        margin-top: 10px;
                        padding-top: 15px;
                        border-top: 1px solid #eee;
                    }
                    .summary-skills-multicolumn .skill-column {
                        list-style-type: none;
                        padding-left: 0;
                        margin: 0 0 5px 0; 
                    }
                     .summary-skills-multicolumn .skill-column li {
                        padding: 1px 0; 
                        font-size: 0.9em; 
                    }
                </style>`;
                return html;
            }

            function attachStep5Listeners() {
                const btnPrint = document.getElementById('btn-print-summary');
                if (btnPrint) {
                    btnPrint.addEventListener('click', () => {
                        window.print();
                    });
                }

                const btnDownload = document.getElementById('btn-download-txt');
                if (btnDownload) {
                    btnDownload.addEventListener('click', generateAndDownloadTxtSummary);
                }
            }

            function generateAndDownloadTxtSummary() {
                let summaryText = `${t('summary_title')}\n\n`;

                summaryText += `== ${t('summary_section_personal_details')} ==\n`;
                summaryText += `${t('summary_placeholder_name')}\n`;
                summaryText += `${t('summary_placeholder_age')}\n`;
                summaryText += `${t('summary_placeholder_sex')}\n\n`;

                summaryText += `== ${t('summary_section_profession')} ==\n`;
                let professionDisplayNameTxt = t('not_selected');
                if (character.professionKey) {
                    if (character.professionKey === 'custom_profession') {
                        professionDisplayNameTxt = character.customProfessionName.trim() !== "" ? character.customProfessionName : t(PROFESSIONS.custom_profession.nameKey);
                    } else if (PROFESSIONS[character.professionKey]) {
                        professionDisplayNameTxt = t(PROFESSIONS[character.professionKey].nameKey);
                    } else {
                        professionDisplayNameTxt = character.professionKey.replace(/_/g, ' ');
                    }
                }
                summaryText += `${professionDisplayNameTxt}\n\n`;

                summaryText += `== ${t('summary_section_statistics')} ==\n`;
                STAT_KEYS.forEach(key => {
                    const statName = t('stat_' + key.toLowerCase() + '_name');
                    const statValue = character.stats[key] || 0;
                    const percentile = statValue * 5;
                    const feature = character.distinguishingFeatures[key] || "";
                    summaryText += `${statName}: ${statValue} (${percentile}%) ${feature ? `(${feature})` : ''}\n`;
                });
                summaryText += "\n";

                summaryText += `== ${t('summary_section_derived_attr')} ==\n`;
                summaryText += `${t('attr_hp_name')}: ${character.derivedAttributes.HP}\n`;
                summaryText += `${t('attr_wp_name')}: ${character.derivedAttributes.WP}\n`;
                summaryText += `${t('attr_san_name')}: ${character.derivedAttributes.SAN}\n`;
                summaryText += `${t('attr_bp_name')}: ${character.derivedAttributes.BP}\n\n`;

                summaryText += `== ${t('summary_section_skills')} ==\n`;
                const relevantSkills = []; // Dieselbe Logik wie in renderStep5_Summary
                for (const skillKey in character.skills) { /* ... */ } // (Code kopieren)
                // ... (Schleife kopieren und anpassen für Textausgabe)
                 for (const skillKey in character.skills) {
                    const skill = character.skills[skillKey];
                    const baseSkillData = ALL_SKILLS[skillKey];
                    if (skill.value > baseSkillData.base || skill.increases > 0 || skill.isProfessional || skill.isChoiceSkill || (baseSkillData.type && skill.typeName)) {
                        let displayName = t(baseSkillData.nameKey);
                        if (baseSkillData.type && skill.typeName && skill.typeName.trim() !== "") {
                            displayName += ` (${skill.typeName.trim()})`;
                        }
                        relevantSkills.push({ name: displayName, value: skill.value });
                    }
                }
                relevantSkills.sort((a, b) => a.name.localeCompare(b.name, currentLanguage));
                if (relevantSkills.length > 0) {
                    relevantSkills.forEach(skill => {
                        summaryText += `${skill.name}: ${skill.value}%\n`;
                    });
                } else {
                    summaryText += `(${t('not_defined')})\n`;
                }
                summaryText += "\n";


                summaryText += `== ${t('summary_section_bonds')} ==\n`;
                if (character.bonds && character.bonds.length > 0) {
                    character.bonds.forEach((bond, index) => {
                        summaryText += `${t('bond_label_number', {number: index + 1})}: ${bond.description || `(${t('not_defined')})`} - Score: ${bond.score}\n`;
                    });
                } else {
                    summaryText += `(${t('not_defined')})\n`;
                }
                summaryText += "\n";

                summaryText += `== ${t('summary_section_motivations')} ==\n`;
                const definedMotivations = character.motivations.filter(m => m && m.trim() !== "");
                if (definedMotivations.length > 0) {
                    definedMotivations.forEach((motivation) => {
                        summaryText += `- ${motivation}\n`;
                    });
                } else {
                    summaryText += `(${t('not_defined')})\n`;
                }

                // Download initiieren
                const blob = new Blob([summaryText], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "delta_green_character.txt");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
            
            function validateStep5() { return true; }
            function saveStep5() { /* Nichts zu speichern */ }

            const steps = [
                { render: renderIntro, validate: () => true, save: () => {}, nameKey: "step_name_0" },
                { render: renderStep1_ProfessionSkills, validate: validateStep1, save: saveStep1, nameKey: "step_name_1", attachListeners: attachStep1Listeners },
                { render: renderStep2_Statistics, validate: validateStep2, save: saveStep2, nameKey: "step_name_2", attachListeners: attachStep2Listeners },
                { render: renderStep3_DerivedAttributes, validate: validateStep3, save: saveStep3, nameKey: "step_name_3", attachListeners: attachStep3Listeners },
                { render: renderStep4_BondsMotivations, validate: validateStep4, save: saveStep4, nameKey: "step_name_4", attachListeners: attachStep4Listeners },
                { render: renderStep5_Summary, validate: validateStep5, save: saveStep5, nameKey: "step_name_5", attachListeners: attachStep5Listeners }
            ];

            function initialize() {
                stepContainer = document.getElementById('step-content-container');
                progressBarContainer = document.getElementById('progress-bar-container');
                btnNext = document.getElementById('btn-next');
                btnBack = document.getElementById('btn-back');
                
                initI18n(); // Setzt die globale `currentLanguage` basierend auf der neuen Logik

                setLanguage(currentLanguage); // Wendet die initial bestimmte Sprache an

                resetCharacter();
                
                btnNext.addEventListener('click', handleNextStep);
                btnBack.addEventListener('click', handlePreviousStep);
                document.getElementById('lang-de').addEventListener('click', () => setLanguage('de'));
                document.getElementById('lang-en').addEventListener('click', () => setLanguage('en'));
                
                renderCurrentStep();
            }
            function handleNextStep() {
                if (!validateStep(currentStep, true)) return;
                saveStepData(currentStep);
                if (currentStep < steps.length - 1) {
                    currentStep++;
                    renderCurrentStep();
                }
            }
            function handlePreviousStep() {
                if (currentStep > 0) {
                    currentStep--;
                    renderCurrentStep();
                }
            }
            function updateNavigationButtons() {
                btnBack.disabled = currentStep === 0;

                if (currentStep === steps.length - 1) { // Letzter Schritt (Summary)
                    // Den "Weiter"-Button auf der Zusammenfassungsseite komplett ausblenden
                    btnNext.style.display = 'none'; // Button unsichtbar machen
                    // Optional: btnNext.disabled = true; (ist redundant, wenn er eh nicht sichtbar ist)
                    // Der Text des Buttons ist hier irrelevant, da er nicht angezeigt wird.
                } else {
                    // Für alle anderen Schritte den Button wieder sichtbar machen und Text/Status setzen
                    btnNext.style.display = 'inline-block'; // Oder 'block', je nach ursprünglichem Display-Typ
                    btnNext.textContent = t('btn_next_text');
                    
                    let isStepValid = validateStep(currentStep, false);

                    if (currentStep === 1) { // Spezifische Logik für Schritt 1 (Profession & Skills)
                        if (character.isCustomProfession) {
                            if (character.customProfessionSetupStage === 'bonds' || character.customProfessionSetupStage === 'skills') {
                                btnNext.disabled = true; // "Next" ist deaktiviert, interne Buttons nutzen
                            } else { // customProfessionSetupStage === 'done'
                                btnNext.disabled = !isStepValid;
                            }
                        } else { // Standard Beruf
                            btnNext.disabled = !isStepValid;
                        }
                    } else { // Für alle anderen Schritte (außer dem letzten)
                        btnNext.disabled = !isStepValid;
                    }
                }
            }
            function renderCurrentStep() {
                if (steps[currentStep] && typeof steps[currentStep].render === 'function') {
                    const stepData = steps[currentStep];
                    const stepContentOrHtml = stepData.render();
                    if (typeof stepContentOrHtml === 'string') {
                        stepContainer.innerHTML = stepContentOrHtml;
                    } else if (stepContentOrHtml instanceof Node) {
                        stepContainer.innerHTML = ''; 
                        stepContainer.appendChild(stepContentOrHtml);
                    }
                    translateAllElements(stepContainer);
                    if (stepData.attachListeners) {
                        stepData.attachListeners();
                    }
                    updateProgressBar(); 
                    updateNavigationButtons(); 
                }
            }
            function updateProgressBar() {
                const stepName = t(steps[currentStep].nameKey) || `Step ${currentStep}`;
                progressBarContainer.textContent = t('progress_bar_text', { current: currentStep , total: steps.length -1, stepName: stepName });
            }
            function validateStep(stepIndex, showAlerts = true) {
                if (steps[stepIndex] && typeof steps[stepIndex].validate === 'function') {
                    return steps[stepIndex].validate(showAlerts);
                }
                return true; 
            }
            function saveStepData(stepIndex) {
                if (steps[stepIndex] && typeof steps[stepIndex].save === 'function') {
                    steps[stepIndex].save();
                }
            }
            function getCurrentCharacterData() {
                return character; // Gibt das aktuelle character Objekt zurück
            }

            // Public API
            return {
                initialize,
                renderCurrentStep,
                getCurrentCharacterData // Exponiere die Methode
            };
        })();

        document.addEventListener('DOMContentLoaded', app.initialize);
    </script>
</body>
</html>
